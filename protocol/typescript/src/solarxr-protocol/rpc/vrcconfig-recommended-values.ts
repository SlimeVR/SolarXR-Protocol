// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

import { VRCAvatarMeasurementType } from '../../solarxr-protocol/rpc/vrcavatar-measurement-type.js';
import { VRCSpineMode } from '../../solarxr-protocol/rpc/vrcspine-mode.js';
import { VRCTrackerModel } from '../../solarxr-protocol/rpc/vrctracker-model.js';


export class VRCConfigRecommendedValues implements flatbuffers.IUnpackableObject<VRCConfigRecommendedValuesT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):VRCConfigRecommendedValues {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsVRCConfigRecommendedValues(bb:flatbuffers.ByteBuffer, obj?:VRCConfigRecommendedValues):VRCConfigRecommendedValues {
  return (obj || new VRCConfigRecommendedValues()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsVRCConfigRecommendedValues(bb:flatbuffers.ByteBuffer, obj?:VRCConfigRecommendedValues):VRCConfigRecommendedValues {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new VRCConfigRecommendedValues()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

legacyMode():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

shoulderTrackingDisabled():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

userHeight():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

calibrationRange():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

calibrationVisuals():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

trackerModel():VRCTrackerModel {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : VRCTrackerModel.UNKNOWN;
}

spineMode(index: number):VRCSpineMode|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

spineModeLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

spineModeArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

avatarMeasurementType():VRCAvatarMeasurementType {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : VRCAvatarMeasurementType.UNKNOWN;
}

shoulderWidthCompensation():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

static startVRCConfigRecommendedValues(builder:flatbuffers.Builder) {
  builder.startObject(9);
}

static addLegacyMode(builder:flatbuffers.Builder, legacyMode:boolean) {
  builder.addFieldInt8(0, +legacyMode, +false);
}

static addShoulderTrackingDisabled(builder:flatbuffers.Builder, shoulderTrackingDisabled:boolean) {
  builder.addFieldInt8(1, +shoulderTrackingDisabled, +false);
}

static addUserHeight(builder:flatbuffers.Builder, userHeight:number) {
  builder.addFieldFloat32(2, userHeight, 0.0);
}

static addCalibrationRange(builder:flatbuffers.Builder, calibrationRange:number) {
  builder.addFieldFloat32(3, calibrationRange, 0.0);
}

static addCalibrationVisuals(builder:flatbuffers.Builder, calibrationVisuals:boolean) {
  builder.addFieldInt8(4, +calibrationVisuals, +false);
}

static addTrackerModel(builder:flatbuffers.Builder, trackerModel:VRCTrackerModel) {
  builder.addFieldInt8(5, trackerModel, VRCTrackerModel.UNKNOWN);
}

static addSpineMode(builder:flatbuffers.Builder, spineModeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, spineModeOffset, 0);
}

static createSpineModeVector(builder:flatbuffers.Builder, data:VRCSpineMode[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startSpineModeVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addAvatarMeasurementType(builder:flatbuffers.Builder, avatarMeasurementType:VRCAvatarMeasurementType) {
  builder.addFieldInt8(7, avatarMeasurementType, VRCAvatarMeasurementType.UNKNOWN);
}

static addShoulderWidthCompensation(builder:flatbuffers.Builder, shoulderWidthCompensation:boolean) {
  builder.addFieldInt8(8, +shoulderWidthCompensation, +false);
}

static endVRCConfigRecommendedValues(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createVRCConfigRecommendedValues(builder:flatbuffers.Builder, legacyMode:boolean, shoulderTrackingDisabled:boolean, userHeight:number, calibrationRange:number, calibrationVisuals:boolean, trackerModel:VRCTrackerModel, spineModeOffset:flatbuffers.Offset, avatarMeasurementType:VRCAvatarMeasurementType, shoulderWidthCompensation:boolean):flatbuffers.Offset {
  VRCConfigRecommendedValues.startVRCConfigRecommendedValues(builder);
  VRCConfigRecommendedValues.addLegacyMode(builder, legacyMode);
  VRCConfigRecommendedValues.addShoulderTrackingDisabled(builder, shoulderTrackingDisabled);
  VRCConfigRecommendedValues.addUserHeight(builder, userHeight);
  VRCConfigRecommendedValues.addCalibrationRange(builder, calibrationRange);
  VRCConfigRecommendedValues.addCalibrationVisuals(builder, calibrationVisuals);
  VRCConfigRecommendedValues.addTrackerModel(builder, trackerModel);
  VRCConfigRecommendedValues.addSpineMode(builder, spineModeOffset);
  VRCConfigRecommendedValues.addAvatarMeasurementType(builder, avatarMeasurementType);
  VRCConfigRecommendedValues.addShoulderWidthCompensation(builder, shoulderWidthCompensation);
  return VRCConfigRecommendedValues.endVRCConfigRecommendedValues(builder);
}

unpack(): VRCConfigRecommendedValuesT {
  return new VRCConfigRecommendedValuesT(
    this.legacyMode(),
    this.shoulderTrackingDisabled(),
    this.userHeight(),
    this.calibrationRange(),
    this.calibrationVisuals(),
    this.trackerModel(),
    this.bb!.createScalarList<VRCSpineMode>(this.spineMode.bind(this), this.spineModeLength()),
    this.avatarMeasurementType(),
    this.shoulderWidthCompensation()
  );
}


unpackTo(_o: VRCConfigRecommendedValuesT): void {
  _o.legacyMode = this.legacyMode();
  _o.shoulderTrackingDisabled = this.shoulderTrackingDisabled();
  _o.userHeight = this.userHeight();
  _o.calibrationRange = this.calibrationRange();
  _o.calibrationVisuals = this.calibrationVisuals();
  _o.trackerModel = this.trackerModel();
  _o.spineMode = this.bb!.createScalarList<VRCSpineMode>(this.spineMode.bind(this), this.spineModeLength());
  _o.avatarMeasurementType = this.avatarMeasurementType();
  _o.shoulderWidthCompensation = this.shoulderWidthCompensation();
}
}

export class VRCConfigRecommendedValuesT implements flatbuffers.IGeneratedObject {
constructor(
  public legacyMode: boolean = false,
  public shoulderTrackingDisabled: boolean = false,
  public userHeight: number = 0.0,
  public calibrationRange: number = 0.0,
  public calibrationVisuals: boolean = false,
  public trackerModel: VRCTrackerModel = VRCTrackerModel.UNKNOWN,
  public spineMode: (VRCSpineMode)[] = [],
  public avatarMeasurementType: VRCAvatarMeasurementType = VRCAvatarMeasurementType.UNKNOWN,
  public shoulderWidthCompensation: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const spineMode = VRCConfigRecommendedValues.createSpineModeVector(builder, this.spineMode);

  return VRCConfigRecommendedValues.createVRCConfigRecommendedValues(builder,
    this.legacyMode,
    this.shoulderTrackingDisabled,
    this.userHeight,
    this.calibrationRange,
    this.calibrationVisuals,
    this.trackerModel,
    spineMode,
    this.avatarMeasurementType,
    this.shoulderWidthCompensation
  );
}
}
