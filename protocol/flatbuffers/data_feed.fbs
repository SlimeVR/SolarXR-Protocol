/// This file contains types related to the data feed system. This allows sending
/// information about the device whether static or dynamic, to any application,
/// with a unified API.
///
/// The core datatype is `DataFeedUpdate`, which contains a table of optional fields,
/// representing all of the data about both physical and synthetic(software) devices.
/// There is a corresponding mask on those fields called `, which defaults to all
/// fields false, meaning no data.
///
/// It is important to note that the absence of a value in a serialized flatbuffer
/// binary corresponds to the default value in the schema, which means that only
/// fields that are actually populated have any impact on the bandwidth of data
/// used by flatbuffer messages. This allows us to lump basically all fields that
/// could possibly be needed into `DeviceStatus` or `TrackerStatus`, without
/// impacting performance.
///
/// There are two ways of getting `DataFeedUpdate`s - one way is by requesting a single
/// update, via `PollDataFeed`. Another way is by requesting a persistent data feed via
/// a `DataFeedRequest`, which itself is simply a list of `DataFeedConfig`s, one for
/// each data feed that is being requested.
///
/// `DataFeedConfig` allows fine grained control over the type of data sent (via
/// `DeviceStatusMask` ), and the frequency of that data.

include "datatypes/hardware_info.fbs";
include "datatypes/datatypes.fbs";
include "datatypes/tracker.fbs";

namespace slimevr_protocol.data_feed;

/// Requests for a single `DataFeedUpdate` to be sent. This is helpful when getting
/// initial info about the device.
table PollDataFeed {
    config: DataFeedConfig;
}


/// Requests for the other party to send `data_feeds`.
/// For example, GUI requests for position data to be sent from server.
///
/// When sending a new `DataFeedRequest`, the old data feeds will stop existing.
/// We still support multiple data feeds at the same time, because `data_feeds`
/// is a list.
///
/// Multiple data feeds are useful to get data at different frequencies.
table DataFeedRequest {
    data_feeds: [DataFeedConfig];
}


/// A single update of the `DeviceStatus` updates.
///
/// A data feed might send data only when it changes/updates, and we should make no
/// assumptions that the data is actually delivered. If you want to guarantee
/// delivery and avoid dropped observations of data (such as a user-initiated
/// button press), it is better to use the RPC system.
table DataFeedUpdate {
    // In the future, we may add an `id` field to disambiguate different `DataFeeds`
    devices: [DeviceStatus];
    synthetic_trackers: [slimevr_protocol.datatypes.tracker.TrackerStatus];
}


/// All information related to the configuration of a data feed. This may be sent
/// as part of a `DataFeedRequest` or a `DataFeedNotify`.
table DataFeedConfig {
    /// Minimum delay in milliseconds between new data updates. This value will be
    /// ignored when used for a `PollDataFeed`.
    minimum_time_since_last: uint16 = 0;
    data_mask: DeviceStatusMask;
    synthetic_trackers: bool;
}

/// A mask of values to be reported in subsequent DeviceStatus. Values set to `false`
/// or `null` will not reported. By default, all fields are false/null.
///
/// If you set a value to `true`, it is not guaranteed that the sender actually has
/// such a value to send. In this case, they will probably send `null`, and the receiver
/// has the choice to disconnect due to missing data.
table DeviceStatusMask {
    custom_name: bool;
    firmware_info: slimevr_protocol.datatypes.hardware_info.FirmwareInfoMask;
    firmware_status: slimevr_protocol.datatypes.hardware_info.FirmwareStatusMask;
    tracker_statuses: slimevr_protocol.datatypes.tracker.TrackerStatusMask;
}

/// All possible info related to a hardware device. For example a vive tracker is a
/// single hardware device, and a slime tracker with two extensions is a single hardware
/// device.
///
/// Each `DeviceStatus` contains data about one or more `TrackerStatus`es. For example,
/// a SlimeVR waist tracker with a chest extension has two `TrackerStatus`es, because
/// it is tracking information about two different parts of the body.
table DeviceStatus {
    /// A unique ID for the device. IDs are not guaranteed to be the same after
    /// the connection is terminated.
    id: uint8;

    // Everything else below here is optional and controlled by `DeviceStatusMask`

    /// The dynamically changeable name of the device. This might be set by the
    /// user to help them remember which tracker is which.
    custom_name: string;

    /// Mostly-static info about the device hardware
    firmware_info: slimevr_protocol.datatypes.hardware_info.FirmwareInfo;
    /// General info about the status of the device
    firmware_status: slimevr_protocol.datatypes.hardware_info.FirmwareStatus;

    /// All the relevant information from the different trackers, in an order
    /// dictated by the conventions of the firmware running on the device
    tracker_statuses: [slimevr_protocol.datatypes.tracker.TrackerStatus];
}
