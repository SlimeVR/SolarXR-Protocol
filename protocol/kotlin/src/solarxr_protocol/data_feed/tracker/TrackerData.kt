// automatically generated by the FlatBuffers compiler, do not modify

package solarxr_protocol.data_feed.tracker

import java.nio.*
import kotlin.math.sign
import com.google.flatbuffers.*

/**
 * Describes all possible information about a tracker. A tracker is anything that
 * provides kinematic data about a particular body part.
 *
 * Trackers may be synthetic/computed or instead part of an actual hardware device.
 * There can be multiple trackers per hardware device.
 */
@Suppress("unused")
class TrackerData : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : TrackerData {
        __init(_i, _bb)
        return this
    }
    val trackerId : solarxr_protocol.datatypes.TrackerId? get() = trackerId(solarxr_protocol.datatypes.TrackerId())
    fun trackerId(obj: solarxr_protocol.datatypes.TrackerId) : solarxr_protocol.datatypes.TrackerId? {
        val o = __offset(4)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    val info : solarxr_protocol.data_feed.tracker.TrackerInfo? get() = info(solarxr_protocol.data_feed.tracker.TrackerInfo())
    fun info(obj: solarxr_protocol.data_feed.tracker.TrackerInfo) : solarxr_protocol.data_feed.tracker.TrackerInfo? {
        val o = __offset(6)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    val status : UByte
        get() {
            val o = __offset(8)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    /**
     * Sensor rotation after fusion
     */
    val rotation : solarxr_protocol.datatypes.math.Quat? get() = rotation(solarxr_protocol.datatypes.math.Quat())
    fun rotation(obj: solarxr_protocol.datatypes.math.Quat) : solarxr_protocol.datatypes.math.Quat? {
        val o = __offset(10)
        return if (o != 0) {
            obj.__assign(o + bb_pos, bb)
        } else {
            null
        }
    }
    /**
     * Position, in meters
     */
    val position : solarxr_protocol.datatypes.math.Vec3f? get() = position(solarxr_protocol.datatypes.math.Vec3f())
    fun position(obj: solarxr_protocol.datatypes.math.Vec3f) : solarxr_protocol.datatypes.math.Vec3f? {
        val o = __offset(12)
        return if (o != 0) {
            obj.__assign(o + bb_pos, bb)
        } else {
            null
        }
    }
    /**
     * Raw angular velocity, in euler angles, rad/s
     */
    val rawAngularVelocity : solarxr_protocol.datatypes.math.Vec3f? get() = rawAngularVelocity(solarxr_protocol.datatypes.math.Vec3f())
    fun rawAngularVelocity(obj: solarxr_protocol.datatypes.math.Vec3f) : solarxr_protocol.datatypes.math.Vec3f? {
        val o = __offset(14)
        return if (o != 0) {
            obj.__assign(o + bb_pos, bb)
        } else {
            null
        }
    }
    /**
     * Raw acceleration, in m/s^2
     */
    val rawAcceleration : solarxr_protocol.datatypes.math.Vec3f? get() = rawAcceleration(solarxr_protocol.datatypes.math.Vec3f())
    fun rawAcceleration(obj: solarxr_protocol.datatypes.math.Vec3f) : solarxr_protocol.datatypes.math.Vec3f? {
        val o = __offset(16)
        return if (o != 0) {
            obj.__assign(o + bb_pos, bb)
        } else {
            null
        }
    }
    /**
     * Temperature, in degrees celsius
     */
    val temp : solarxr_protocol.datatypes.Temperature? get() = temp(solarxr_protocol.datatypes.Temperature())
    fun temp(obj: solarxr_protocol.datatypes.Temperature) : solarxr_protocol.datatypes.Temperature? {
        val o = __offset(18)
        return if (o != 0) {
            obj.__assign(o + bb_pos, bb)
        } else {
            null
        }
    }
    /**
     * Acceleration without gravity, in m/s^2
     */
    val linearAcceleration : solarxr_protocol.datatypes.math.Vec3f? get() = linearAcceleration(solarxr_protocol.datatypes.math.Vec3f())
    fun linearAcceleration(obj: solarxr_protocol.datatypes.math.Vec3f) : solarxr_protocol.datatypes.math.Vec3f? {
        val o = __offset(20)
        return if (o != 0) {
            obj.__assign(o + bb_pos, bb)
        } else {
            null
        }
    }
    /**
     * Reference-adjusted rotation for IMU-only trackers (VR HMD yaw is used as a reset reference).
     * In other words, a rotation that is aligned to a reliable source of rotation ((0, VR HMD YAW, 0)),
     * triggered after user input (using reset buttons).
     * This is a SlimeVR-specific field and computed exclusively by SlimeVR server.
     * Includes: mounting orientation, full, quick and mounting reset adjustments.
     * This rotation can be used to reconstruct a skeleton pose using forward kinematics.
     */
    val rotationReferenceAdjusted : solarxr_protocol.datatypes.math.Quat? get() = rotationReferenceAdjusted(solarxr_protocol.datatypes.math.Quat())
    fun rotationReferenceAdjusted(obj: solarxr_protocol.datatypes.math.Quat) : solarxr_protocol.datatypes.math.Quat? {
        val o = __offset(22)
        return if (o != 0) {
            obj.__assign(o + bb_pos, bb)
        } else {
            null
        }
    }
    /**
     * Zero-reference-adjusted rotation for IMU-only trackers (identity quaternion is used as a reset reference).
     * In other words, a rotation that is aligned to a zero vector ((0, 0, 0)) by
     * inverting the current rotation, triggered after user input (using reset buttons).
     * This is a SlimeVR-specific field and computed exclusively by SlimeVR server.
     * Includes: only full and quick reset adjustments.
     * This rotation can be used in visualizations for IMU debugging.
     */
    val rotationIdentityAdjusted : solarxr_protocol.datatypes.math.Quat? get() = rotationIdentityAdjusted(solarxr_protocol.datatypes.math.Quat())
    fun rotationIdentityAdjusted(obj: solarxr_protocol.datatypes.math.Quat) : solarxr_protocol.datatypes.math.Quat? {
        val o = __offset(24)
        return if (o != 0) {
            obj.__assign(o + bb_pos, bb)
        } else {
            null
        }
    }
    /**
     * Data ticks per second, processed by SlimeVR server
     */
    val tps : UShort?
        get() {
            val o = __offset(26)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else null
        }
    companion object {
        @JvmStatic
        fun validateVersion() = Constants.FLATBUFFERS_22_10_26()
        @JvmStatic
        fun getRootAsTrackerData(_bb: ByteBuffer): TrackerData = getRootAsTrackerData(_bb, TrackerData())
        @JvmStatic
        fun getRootAsTrackerData(_bb: ByteBuffer, obj: TrackerData): TrackerData {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        @JvmStatic
        fun startTrackerData(builder: FlatBufferBuilder) = builder.startTable(12)
        @JvmStatic
        fun addTrackerId(builder: FlatBufferBuilder, trackerId: Int) = builder.addOffset(0, trackerId, 0)
        @JvmStatic
        fun addInfo(builder: FlatBufferBuilder, info: Int) = builder.addOffset(1, info, 0)
        @JvmStatic
        fun addStatus(builder: FlatBufferBuilder, status: UByte) = builder.addByte(2, status.toByte(), 0)
        @JvmStatic
        fun addRotation(builder: FlatBufferBuilder, rotation: Int) = builder.addStruct(3, rotation, 0)
        @JvmStatic
        fun addPosition(builder: FlatBufferBuilder, position: Int) = builder.addStruct(4, position, 0)
        @JvmStatic
        fun addRawAngularVelocity(builder: FlatBufferBuilder, rawAngularVelocity: Int) = builder.addStruct(5, rawAngularVelocity, 0)
        @JvmStatic
        fun addRawAcceleration(builder: FlatBufferBuilder, rawAcceleration: Int) = builder.addStruct(6, rawAcceleration, 0)
        @JvmStatic
        fun addTemp(builder: FlatBufferBuilder, temp: Int) = builder.addStruct(7, temp, 0)
        @JvmStatic
        fun addLinearAcceleration(builder: FlatBufferBuilder, linearAcceleration: Int) = builder.addStruct(8, linearAcceleration, 0)
        @JvmStatic
        fun addRotationReferenceAdjusted(builder: FlatBufferBuilder, rotationReferenceAdjusted: Int) = builder.addStruct(9, rotationReferenceAdjusted, 0)
        @JvmStatic
        fun addRotationIdentityAdjusted(builder: FlatBufferBuilder, rotationIdentityAdjusted: Int) = builder.addStruct(10, rotationIdentityAdjusted, 0)
        @JvmStatic
        fun addTps(builder: FlatBufferBuilder, tps: UShort) = builder.addShort(11, tps.toShort(), 0)
        @JvmStatic
        fun endTrackerData(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
