// automatically generated by the FlatBuffers compiler, do not modify

package solarxr_protocol.data_feed

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * All of the data components related to a single data feed. A data feed is comprised
 * of device data, and tracker data.
 *
 * A data feed might send data only when it changes/updates, and we should make no
 * assumptions that the data is actually delivered. If you want to guarantee
 * delivery and avoid dropped observations of data (such as a user-initiated
 * button press), it is better to use the RPC system.
 */
@Suppress("unused")
class DataFeedUpdate : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : DataFeedUpdate {
        __init(_i, _bb)
        return this
    }
    fun devices(j: Int) : solarxr_protocol.data_feed.device_data.DeviceData? = devices(solarxr_protocol.data_feed.device_data.DeviceData(), j)
    fun devices(obj: solarxr_protocol.data_feed.device_data.DeviceData, j: Int) : solarxr_protocol.data_feed.device_data.DeviceData? {
        val o = __offset(4)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val devicesLength : Int
        get() {
            val o = __offset(4); return if (o != 0) __vector_len(o) else 0
        }
    fun syntheticTrackers(j: Int) : solarxr_protocol.data_feed.tracker.TrackerData? = syntheticTrackers(solarxr_protocol.data_feed.tracker.TrackerData(), j)
    fun syntheticTrackers(obj: solarxr_protocol.data_feed.tracker.TrackerData, j: Int) : solarxr_protocol.data_feed.tracker.TrackerData? {
        val o = __offset(6)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val syntheticTrackersLength : Int
        get() {
            val o = __offset(6); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * This must represent a set, where there is no more than one bone for a `BodyPart`.
     */
    fun bones(j: Int) : solarxr_protocol.data_feed.Bone? = bones(solarxr_protocol.data_feed.Bone(), j)
    fun bones(obj: solarxr_protocol.data_feed.Bone, j: Int) : solarxr_protocol.data_feed.Bone? {
        val o = __offset(8)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val bonesLength : Int
        get() {
            val o = __offset(8); return if (o != 0) __vector_len(o) else 0
        }
    val stayAlignedPose : solarxr_protocol.data_feed.stay_aligned.StayAlignedPose? get() = stayAlignedPose(solarxr_protocol.data_feed.stay_aligned.StayAlignedPose())
    fun stayAlignedPose(obj: solarxr_protocol.data_feed.stay_aligned.StayAlignedPose) : solarxr_protocol.data_feed.stay_aligned.StayAlignedPose? {
        val o = __offset(10)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    val index : UByte
        get() {
            val o = __offset(12)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val serverGuards : solarxr_protocol.data_feed.server.ServerGuards? get() = serverGuards(solarxr_protocol.data_feed.server.ServerGuards())
    fun serverGuards(obj: solarxr_protocol.data_feed.server.ServerGuards) : solarxr_protocol.data_feed.server.ServerGuards? {
        val o = __offset(14)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    companion object {
        @JvmStatic
        fun validateVersion() = Constants.FLATBUFFERS_25_9_23()
        @JvmStatic
        fun getRootAsDataFeedUpdate(_bb: ByteBuffer): DataFeedUpdate = getRootAsDataFeedUpdate(_bb, DataFeedUpdate())
        @JvmStatic
        fun getRootAsDataFeedUpdate(_bb: ByteBuffer, obj: DataFeedUpdate): DataFeedUpdate {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        @JvmStatic
        fun createDataFeedUpdate(builder: FlatBufferBuilder, devicesOffset: Int, syntheticTrackersOffset: Int, bonesOffset: Int, stayAlignedPoseOffset: Int, index: UByte, serverGuardsOffset: Int) : Int {
            builder.startTable(6)
            addServerGuards(builder, serverGuardsOffset)
            addStayAlignedPose(builder, stayAlignedPoseOffset)
            addBones(builder, bonesOffset)
            addSyntheticTrackers(builder, syntheticTrackersOffset)
            addDevices(builder, devicesOffset)
            addIndex(builder, index)
            return endDataFeedUpdate(builder)
        }
        @JvmStatic
        fun startDataFeedUpdate(builder: FlatBufferBuilder) = builder.startTable(6)
        @JvmStatic
        fun addDevices(builder: FlatBufferBuilder, devices: Int) = builder.addOffset(0, devices, 0)
        @JvmStatic
        fun createDevicesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        @JvmStatic
        fun startDevicesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        @JvmStatic
        fun addSyntheticTrackers(builder: FlatBufferBuilder, syntheticTrackers: Int) = builder.addOffset(1, syntheticTrackers, 0)
        @JvmStatic
        fun createSyntheticTrackersVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        @JvmStatic
        fun startSyntheticTrackersVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        @JvmStatic
        fun addBones(builder: FlatBufferBuilder, bones: Int) = builder.addOffset(2, bones, 0)
        @JvmStatic
        fun createBonesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        @JvmStatic
        fun startBonesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        @JvmStatic
        fun addStayAlignedPose(builder: FlatBufferBuilder, stayAlignedPose: Int) = builder.addOffset(3, stayAlignedPose, 0)
        @JvmStatic
        fun addIndex(builder: FlatBufferBuilder, index: UByte) = builder.addByte(4, index.toByte(), 0)
        @JvmStatic
        fun addServerGuards(builder: FlatBufferBuilder, serverGuards: Int) = builder.addOffset(5, serverGuards, 0)
        @JvmStatic
        fun endDataFeedUpdate(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
