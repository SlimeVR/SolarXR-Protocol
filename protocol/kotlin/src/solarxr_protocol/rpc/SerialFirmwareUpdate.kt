// automatically generated by the FlatBuffers compiler, do not modify

package solarxr_protocol.rpc

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

@Suppress("unused")
class SerialFirmwareUpdate : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : SerialFirmwareUpdate {
        __init(_i, _bb)
        return this
    }
    /**
     * id of the device, this refer to a serial port id
     */
    val deviceId : solarxr_protocol.rpc.SerialDevicePort? get() = deviceId(solarxr_protocol.rpc.SerialDevicePort())
    fun deviceId(obj: solarxr_protocol.rpc.SerialDevicePort) : solarxr_protocol.rpc.SerialDevicePort? {
        val o = __offset(4)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Will make the server ask for the tracker to be manually rebooted by the user
     * after the tracker is done flashing
     */
    val needManualReboot : Boolean
        get() {
            val o = __offset(6)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Credentials to provision after the flashing
     * Only used with Serial flashing, because OTA is already connected to the wifi
     */
    val ssid : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ssidAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun ssidInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    val password : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val passwordAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun passwordInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * A list of urls and offsets of the different firmware files to flash
     */
    fun firmwarePart(j: Int) : solarxr_protocol.rpc.FirmwarePart? = firmwarePart(solarxr_protocol.rpc.FirmwarePart(), j)
    fun firmwarePart(obj: solarxr_protocol.rpc.FirmwarePart, j: Int) : solarxr_protocol.rpc.FirmwarePart? {
        val o = __offset(12)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val firmwarePartLength : Int
        get() {
            val o = __offset(12); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        @JvmStatic
        fun validateVersion() = Constants.FLATBUFFERS_25_9_23()
        @JvmStatic
        fun getRootAsSerialFirmwareUpdate(_bb: ByteBuffer): SerialFirmwareUpdate = getRootAsSerialFirmwareUpdate(_bb, SerialFirmwareUpdate())
        @JvmStatic
        fun getRootAsSerialFirmwareUpdate(_bb: ByteBuffer, obj: SerialFirmwareUpdate): SerialFirmwareUpdate {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        @JvmStatic
        fun createSerialFirmwareUpdate(builder: FlatBufferBuilder, deviceIdOffset: Int, needManualReboot: Boolean, ssidOffset: Int, passwordOffset: Int, firmwarePartOffset: Int) : Int {
            builder.startTable(5)
            addFirmwarePart(builder, firmwarePartOffset)
            addPassword(builder, passwordOffset)
            addSsid(builder, ssidOffset)
            addDeviceId(builder, deviceIdOffset)
            addNeedManualReboot(builder, needManualReboot)
            return endSerialFirmwareUpdate(builder)
        }
        @JvmStatic
        fun startSerialFirmwareUpdate(builder: FlatBufferBuilder) = builder.startTable(5)
        @JvmStatic
        fun addDeviceId(builder: FlatBufferBuilder, deviceId: Int) = builder.addOffset(0, deviceId, 0)
        @JvmStatic
        fun addNeedManualReboot(builder: FlatBufferBuilder, needManualReboot: Boolean) = builder.addBoolean(1, needManualReboot, false)
        @JvmStatic
        fun addSsid(builder: FlatBufferBuilder, ssid: Int) = builder.addOffset(2, ssid, 0)
        @JvmStatic
        fun addPassword(builder: FlatBufferBuilder, password: Int) = builder.addOffset(3, password, 0)
        @JvmStatic
        fun addFirmwarePart(builder: FlatBufferBuilder, firmwarePart: Int) = builder.addOffset(4, firmwarePart, 0)
        @JvmStatic
        fun createFirmwarePartVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        @JvmStatic
        fun startFirmwarePartVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        @JvmStatic
        fun endSerialFirmwareUpdate(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
