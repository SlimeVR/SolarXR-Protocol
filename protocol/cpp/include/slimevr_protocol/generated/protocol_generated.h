// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTOCOL_SLIMEVR_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_PROTOCOL_SLIMEVR_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

#include "datatypes_generated.h"
#include "hardware_info_generated.h"

namespace slimevr_protocol {

struct InboundPacket;
struct InboundPacketBuilder;

struct OutboundPacket;
struct OutboundPacketBuilder;

struct LogData;
struct LogDataBuilder;

struct ConfigureSensorReporting;
struct ConfigureSensorReportingBuilder;

struct SensorReport;
struct SensorReportBuilder;

struct Acknowledgement;
struct AcknowledgementBuilder;

struct HeartbeatRequest;
struct HeartbeatRequestBuilder;

struct HandshakeRequest;
struct HandshakeRequestBuilder;

struct DeviceInfoRequest;
struct DeviceInfoRequestBuilder;

struct DeviceStatusRequest;
struct DeviceStatusRequestBuilder;

struct DeviceStatusResponse;
struct DeviceStatusResponseBuilder;

enum class InboundUnion : uint8_t {
  NONE = 0,
  LogData = 1,
  SensorReport = 2,
  Acknowledgement = 3,
  HeartbeatRequest = 4,
  HandshakeRequest = 5,
  slimevr_protocol_hardware_info_DeviceInfo = 6,
  DeviceStatusResponse = 7,
  MIN = NONE,
  MAX = DeviceStatusResponse
};

inline const InboundUnion (&EnumValuesInboundUnion())[8] {
  static const InboundUnion values[] = {
    InboundUnion::NONE,
    InboundUnion::LogData,
    InboundUnion::SensorReport,
    InboundUnion::Acknowledgement,
    InboundUnion::HeartbeatRequest,
    InboundUnion::HandshakeRequest,
    InboundUnion::slimevr_protocol_hardware_info_DeviceInfo,
    InboundUnion::DeviceStatusResponse
  };
  return values;
}

inline const char * const *EnumNamesInboundUnion() {
  static const char * const names[9] = {
    "NONE",
    "LogData",
    "SensorReport",
    "Acknowledgement",
    "HeartbeatRequest",
    "HandshakeRequest",
    "slimevr_protocol_hardware_info_DeviceInfo",
    "DeviceStatusResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameInboundUnion(InboundUnion e) {
  if (flatbuffers::IsOutRange(e, InboundUnion::NONE, InboundUnion::DeviceStatusResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInboundUnion()[index];
}

template<typename T> struct InboundUnionTraits {
  static const InboundUnion enum_value = InboundUnion::NONE;
};

template<> struct InboundUnionTraits<slimevr_protocol::LogData> {
  static const InboundUnion enum_value = InboundUnion::LogData;
};

template<> struct InboundUnionTraits<slimevr_protocol::SensorReport> {
  static const InboundUnion enum_value = InboundUnion::SensorReport;
};

template<> struct InboundUnionTraits<slimevr_protocol::Acknowledgement> {
  static const InboundUnion enum_value = InboundUnion::Acknowledgement;
};

template<> struct InboundUnionTraits<slimevr_protocol::HeartbeatRequest> {
  static const InboundUnion enum_value = InboundUnion::HeartbeatRequest;
};

template<> struct InboundUnionTraits<slimevr_protocol::HandshakeRequest> {
  static const InboundUnion enum_value = InboundUnion::HandshakeRequest;
};

template<> struct InboundUnionTraits<slimevr_protocol::hardware_info::DeviceInfo> {
  static const InboundUnion enum_value = InboundUnion::slimevr_protocol_hardware_info_DeviceInfo;
};

template<> struct InboundUnionTraits<slimevr_protocol::DeviceStatusResponse> {
  static const InboundUnion enum_value = InboundUnion::DeviceStatusResponse;
};

bool VerifyInboundUnion(flatbuffers::Verifier &verifier, const void *obj, InboundUnion type);
bool VerifyInboundUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<InboundUnion> *types);

enum class OutboundUnion : uint8_t {
  NONE = 0,
  ConfigureSensorReporting = 1,
  Acknowledgement = 2,
  HeartbeatRequest = 3,
  DeviceInfoRequest = 4,
  DeviceStatusRequest = 5,
  MIN = NONE,
  MAX = DeviceStatusRequest
};

inline const OutboundUnion (&EnumValuesOutboundUnion())[6] {
  static const OutboundUnion values[] = {
    OutboundUnion::NONE,
    OutboundUnion::ConfigureSensorReporting,
    OutboundUnion::Acknowledgement,
    OutboundUnion::HeartbeatRequest,
    OutboundUnion::DeviceInfoRequest,
    OutboundUnion::DeviceStatusRequest
  };
  return values;
}

inline const char * const *EnumNamesOutboundUnion() {
  static const char * const names[7] = {
    "NONE",
    "ConfigureSensorReporting",
    "Acknowledgement",
    "HeartbeatRequest",
    "DeviceInfoRequest",
    "DeviceStatusRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameOutboundUnion(OutboundUnion e) {
  if (flatbuffers::IsOutRange(e, OutboundUnion::NONE, OutboundUnion::DeviceStatusRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOutboundUnion()[index];
}

template<typename T> struct OutboundUnionTraits {
  static const OutboundUnion enum_value = OutboundUnion::NONE;
};

template<> struct OutboundUnionTraits<slimevr_protocol::ConfigureSensorReporting> {
  static const OutboundUnion enum_value = OutboundUnion::ConfigureSensorReporting;
};

template<> struct OutboundUnionTraits<slimevr_protocol::Acknowledgement> {
  static const OutboundUnion enum_value = OutboundUnion::Acknowledgement;
};

template<> struct OutboundUnionTraits<slimevr_protocol::HeartbeatRequest> {
  static const OutboundUnion enum_value = OutboundUnion::HeartbeatRequest;
};

template<> struct OutboundUnionTraits<slimevr_protocol::DeviceInfoRequest> {
  static const OutboundUnion enum_value = OutboundUnion::DeviceInfoRequest;
};

template<> struct OutboundUnionTraits<slimevr_protocol::DeviceStatusRequest> {
  static const OutboundUnion enum_value = OutboundUnion::DeviceStatusRequest;
};

bool VerifyOutboundUnion(flatbuffers::Verifier &verifier, const void *obj, OutboundUnion type);
bool VerifyOutboundUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<OutboundUnion> *types);

struct InboundPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InboundPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACKET_COUNTER = 4,
    VT_ACKNOWLEDGE_ME = 6,
    VT_PACKET_TYPE = 8,
    VT_PACKET = 10
  };
  uint64_t packet_counter() const {
    return GetField<uint64_t>(VT_PACKET_COUNTER, 0);
  }
  bool acknowledge_me() const {
    return GetField<uint8_t>(VT_ACKNOWLEDGE_ME, 0) != 0;
  }
  slimevr_protocol::InboundUnion packet_type() const {
    return static_cast<slimevr_protocol::InboundUnion>(GetField<uint8_t>(VT_PACKET_TYPE, 0));
  }
  const void *packet() const {
    return GetPointer<const void *>(VT_PACKET);
  }
  template<typename T> const T *packet_as() const;
  const slimevr_protocol::LogData *packet_as_LogData() const {
    return packet_type() == slimevr_protocol::InboundUnion::LogData ? static_cast<const slimevr_protocol::LogData *>(packet()) : nullptr;
  }
  const slimevr_protocol::SensorReport *packet_as_SensorReport() const {
    return packet_type() == slimevr_protocol::InboundUnion::SensorReport ? static_cast<const slimevr_protocol::SensorReport *>(packet()) : nullptr;
  }
  const slimevr_protocol::Acknowledgement *packet_as_Acknowledgement() const {
    return packet_type() == slimevr_protocol::InboundUnion::Acknowledgement ? static_cast<const slimevr_protocol::Acknowledgement *>(packet()) : nullptr;
  }
  const slimevr_protocol::HeartbeatRequest *packet_as_HeartbeatRequest() const {
    return packet_type() == slimevr_protocol::InboundUnion::HeartbeatRequest ? static_cast<const slimevr_protocol::HeartbeatRequest *>(packet()) : nullptr;
  }
  const slimevr_protocol::HandshakeRequest *packet_as_HandshakeRequest() const {
    return packet_type() == slimevr_protocol::InboundUnion::HandshakeRequest ? static_cast<const slimevr_protocol::HandshakeRequest *>(packet()) : nullptr;
  }
  const slimevr_protocol::hardware_info::DeviceInfo *packet_as_slimevr_protocol_hardware_info_DeviceInfo() const {
    return packet_type() == slimevr_protocol::InboundUnion::slimevr_protocol_hardware_info_DeviceInfo ? static_cast<const slimevr_protocol::hardware_info::DeviceInfo *>(packet()) : nullptr;
  }
  const slimevr_protocol::DeviceStatusResponse *packet_as_DeviceStatusResponse() const {
    return packet_type() == slimevr_protocol::InboundUnion::DeviceStatusResponse ? static_cast<const slimevr_protocol::DeviceStatusResponse *>(packet()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PACKET_COUNTER, 8) &&
           VerifyField<uint8_t>(verifier, VT_ACKNOWLEDGE_ME, 1) &&
           VerifyField<uint8_t>(verifier, VT_PACKET_TYPE, 1) &&
           VerifyOffset(verifier, VT_PACKET) &&
           VerifyInboundUnion(verifier, packet(), packet_type()) &&
           verifier.EndTable();
  }
};

template<> inline const slimevr_protocol::LogData *InboundPacket::packet_as<slimevr_protocol::LogData>() const {
  return packet_as_LogData();
}

template<> inline const slimevr_protocol::SensorReport *InboundPacket::packet_as<slimevr_protocol::SensorReport>() const {
  return packet_as_SensorReport();
}

template<> inline const slimevr_protocol::Acknowledgement *InboundPacket::packet_as<slimevr_protocol::Acknowledgement>() const {
  return packet_as_Acknowledgement();
}

template<> inline const slimevr_protocol::HeartbeatRequest *InboundPacket::packet_as<slimevr_protocol::HeartbeatRequest>() const {
  return packet_as_HeartbeatRequest();
}

template<> inline const slimevr_protocol::HandshakeRequest *InboundPacket::packet_as<slimevr_protocol::HandshakeRequest>() const {
  return packet_as_HandshakeRequest();
}

template<> inline const slimevr_protocol::hardware_info::DeviceInfo *InboundPacket::packet_as<slimevr_protocol::hardware_info::DeviceInfo>() const {
  return packet_as_slimevr_protocol_hardware_info_DeviceInfo();
}

template<> inline const slimevr_protocol::DeviceStatusResponse *InboundPacket::packet_as<slimevr_protocol::DeviceStatusResponse>() const {
  return packet_as_DeviceStatusResponse();
}

struct InboundPacketBuilder {
  typedef InboundPacket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_packet_counter(uint64_t packet_counter) {
    fbb_.AddElement<uint64_t>(InboundPacket::VT_PACKET_COUNTER, packet_counter, 0);
  }
  void add_acknowledge_me(bool acknowledge_me) {
    fbb_.AddElement<uint8_t>(InboundPacket::VT_ACKNOWLEDGE_ME, static_cast<uint8_t>(acknowledge_me), 0);
  }
  void add_packet_type(slimevr_protocol::InboundUnion packet_type) {
    fbb_.AddElement<uint8_t>(InboundPacket::VT_PACKET_TYPE, static_cast<uint8_t>(packet_type), 0);
  }
  void add_packet(flatbuffers::Offset<void> packet) {
    fbb_.AddOffset(InboundPacket::VT_PACKET, packet);
  }
  explicit InboundPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InboundPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InboundPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<InboundPacket> CreateInboundPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t packet_counter = 0,
    bool acknowledge_me = false,
    slimevr_protocol::InboundUnion packet_type = slimevr_protocol::InboundUnion::NONE,
    flatbuffers::Offset<void> packet = 0) {
  InboundPacketBuilder builder_(_fbb);
  builder_.add_packet_counter(packet_counter);
  builder_.add_packet(packet);
  builder_.add_packet_type(packet_type);
  builder_.add_acknowledge_me(acknowledge_me);
  return builder_.Finish();
}

struct OutboundPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OutboundPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACKET_COUNTER = 4,
    VT_ACKNOWLEDGE_ME = 6,
    VT_PACKET_TYPE = 8,
    VT_PACKET = 10
  };
  uint64_t packet_counter() const {
    return GetField<uint64_t>(VT_PACKET_COUNTER, 0);
  }
  bool acknowledge_me() const {
    return GetField<uint8_t>(VT_ACKNOWLEDGE_ME, 0) != 0;
  }
  slimevr_protocol::OutboundUnion packet_type() const {
    return static_cast<slimevr_protocol::OutboundUnion>(GetField<uint8_t>(VT_PACKET_TYPE, 0));
  }
  const void *packet() const {
    return GetPointer<const void *>(VT_PACKET);
  }
  template<typename T> const T *packet_as() const;
  const slimevr_protocol::ConfigureSensorReporting *packet_as_ConfigureSensorReporting() const {
    return packet_type() == slimevr_protocol::OutboundUnion::ConfigureSensorReporting ? static_cast<const slimevr_protocol::ConfigureSensorReporting *>(packet()) : nullptr;
  }
  const slimevr_protocol::Acknowledgement *packet_as_Acknowledgement() const {
    return packet_type() == slimevr_protocol::OutboundUnion::Acknowledgement ? static_cast<const slimevr_protocol::Acknowledgement *>(packet()) : nullptr;
  }
  const slimevr_protocol::HeartbeatRequest *packet_as_HeartbeatRequest() const {
    return packet_type() == slimevr_protocol::OutboundUnion::HeartbeatRequest ? static_cast<const slimevr_protocol::HeartbeatRequest *>(packet()) : nullptr;
  }
  const slimevr_protocol::DeviceInfoRequest *packet_as_DeviceInfoRequest() const {
    return packet_type() == slimevr_protocol::OutboundUnion::DeviceInfoRequest ? static_cast<const slimevr_protocol::DeviceInfoRequest *>(packet()) : nullptr;
  }
  const slimevr_protocol::DeviceStatusRequest *packet_as_DeviceStatusRequest() const {
    return packet_type() == slimevr_protocol::OutboundUnion::DeviceStatusRequest ? static_cast<const slimevr_protocol::DeviceStatusRequest *>(packet()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PACKET_COUNTER, 8) &&
           VerifyField<uint8_t>(verifier, VT_ACKNOWLEDGE_ME, 1) &&
           VerifyField<uint8_t>(verifier, VT_PACKET_TYPE, 1) &&
           VerifyOffset(verifier, VT_PACKET) &&
           VerifyOutboundUnion(verifier, packet(), packet_type()) &&
           verifier.EndTable();
  }
};

template<> inline const slimevr_protocol::ConfigureSensorReporting *OutboundPacket::packet_as<slimevr_protocol::ConfigureSensorReporting>() const {
  return packet_as_ConfigureSensorReporting();
}

template<> inline const slimevr_protocol::Acknowledgement *OutboundPacket::packet_as<slimevr_protocol::Acknowledgement>() const {
  return packet_as_Acknowledgement();
}

template<> inline const slimevr_protocol::HeartbeatRequest *OutboundPacket::packet_as<slimevr_protocol::HeartbeatRequest>() const {
  return packet_as_HeartbeatRequest();
}

template<> inline const slimevr_protocol::DeviceInfoRequest *OutboundPacket::packet_as<slimevr_protocol::DeviceInfoRequest>() const {
  return packet_as_DeviceInfoRequest();
}

template<> inline const slimevr_protocol::DeviceStatusRequest *OutboundPacket::packet_as<slimevr_protocol::DeviceStatusRequest>() const {
  return packet_as_DeviceStatusRequest();
}

struct OutboundPacketBuilder {
  typedef OutboundPacket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_packet_counter(uint64_t packet_counter) {
    fbb_.AddElement<uint64_t>(OutboundPacket::VT_PACKET_COUNTER, packet_counter, 0);
  }
  void add_acknowledge_me(bool acknowledge_me) {
    fbb_.AddElement<uint8_t>(OutboundPacket::VT_ACKNOWLEDGE_ME, static_cast<uint8_t>(acknowledge_me), 0);
  }
  void add_packet_type(slimevr_protocol::OutboundUnion packet_type) {
    fbb_.AddElement<uint8_t>(OutboundPacket::VT_PACKET_TYPE, static_cast<uint8_t>(packet_type), 0);
  }
  void add_packet(flatbuffers::Offset<void> packet) {
    fbb_.AddOffset(OutboundPacket::VT_PACKET, packet);
  }
  explicit OutboundPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OutboundPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OutboundPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<OutboundPacket> CreateOutboundPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t packet_counter = 0,
    bool acknowledge_me = false,
    slimevr_protocol::OutboundUnion packet_type = slimevr_protocol::OutboundUnion::NONE,
    flatbuffers::Offset<void> packet = 0) {
  OutboundPacketBuilder builder_(_fbb);
  builder_.add_packet_counter(packet_counter);
  builder_.add_packet(packet);
  builder_.add_packet_type(packet_type);
  builder_.add_acknowledge_me(acknowledge_me);
  return builder_.Finish();
}

struct LogData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct LogDataBuilder {
  typedef LogData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(LogData::VT_MESSAGE, message);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(LogData::VT_DATA, data);
  }
  explicit LogDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogData> CreateLogData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  LogDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogData> CreateLogDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return slimevr_protocol::CreateLogData(
      _fbb,
      message__,
      data__);
}

struct ConfigureSensorReporting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConfigureSensorReportingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIENTATION = 4,
    VT_RAW_TRANS_ACCEL = 6,
    VT_RAW_ROT_VEL = 8
  };
  bool orientation() const {
    return GetField<uint8_t>(VT_ORIENTATION, 0) != 0;
  }
  bool raw_trans_accel() const {
    return GetField<uint8_t>(VT_RAW_TRANS_ACCEL, 0) != 0;
  }
  bool raw_rot_vel() const {
    return GetField<uint8_t>(VT_RAW_ROT_VEL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ORIENTATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_RAW_TRANS_ACCEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_RAW_ROT_VEL, 1) &&
           verifier.EndTable();
  }
};

struct ConfigureSensorReportingBuilder {
  typedef ConfigureSensorReporting Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_orientation(bool orientation) {
    fbb_.AddElement<uint8_t>(ConfigureSensorReporting::VT_ORIENTATION, static_cast<uint8_t>(orientation), 0);
  }
  void add_raw_trans_accel(bool raw_trans_accel) {
    fbb_.AddElement<uint8_t>(ConfigureSensorReporting::VT_RAW_TRANS_ACCEL, static_cast<uint8_t>(raw_trans_accel), 0);
  }
  void add_raw_rot_vel(bool raw_rot_vel) {
    fbb_.AddElement<uint8_t>(ConfigureSensorReporting::VT_RAW_ROT_VEL, static_cast<uint8_t>(raw_rot_vel), 0);
  }
  explicit ConfigureSensorReportingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConfigureSensorReporting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConfigureSensorReporting>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConfigureSensorReporting> CreateConfigureSensorReporting(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool orientation = false,
    bool raw_trans_accel = false,
    bool raw_rot_vel = false) {
  ConfigureSensorReportingBuilder builder_(_fbb);
  builder_.add_raw_rot_vel(raw_rot_vel);
  builder_.add_raw_trans_accel(raw_trans_accel);
  builder_.add_orientation(orientation);
  return builder_.Finish();
}

struct SensorReport FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SensorReportBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIENTATION = 4,
    VT_RAW_TRANS_ACCEL = 6,
    VT_RAW_ROT_VEL = 8
  };
  const flatbuffers::Vector<const slimevr_protocol::datatypes::Quat *> *orientation() const {
    return GetPointer<const flatbuffers::Vector<const slimevr_protocol::datatypes::Quat *> *>(VT_ORIENTATION);
  }
  const flatbuffers::Vector<const slimevr_protocol::datatypes::Vec3f *> *raw_trans_accel() const {
    return GetPointer<const flatbuffers::Vector<const slimevr_protocol::datatypes::Vec3f *> *>(VT_RAW_TRANS_ACCEL);
  }
  const flatbuffers::Vector<const slimevr_protocol::datatypes::Vec3f *> *raw_rot_vel() const {
    return GetPointer<const flatbuffers::Vector<const slimevr_protocol::datatypes::Vec3f *> *>(VT_RAW_ROT_VEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORIENTATION) &&
           verifier.VerifyVector(orientation()) &&
           VerifyOffset(verifier, VT_RAW_TRANS_ACCEL) &&
           verifier.VerifyVector(raw_trans_accel()) &&
           VerifyOffset(verifier, VT_RAW_ROT_VEL) &&
           verifier.VerifyVector(raw_rot_vel()) &&
           verifier.EndTable();
  }
};

struct SensorReportBuilder {
  typedef SensorReport Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_orientation(flatbuffers::Offset<flatbuffers::Vector<const slimevr_protocol::datatypes::Quat *>> orientation) {
    fbb_.AddOffset(SensorReport::VT_ORIENTATION, orientation);
  }
  void add_raw_trans_accel(flatbuffers::Offset<flatbuffers::Vector<const slimevr_protocol::datatypes::Vec3f *>> raw_trans_accel) {
    fbb_.AddOffset(SensorReport::VT_RAW_TRANS_ACCEL, raw_trans_accel);
  }
  void add_raw_rot_vel(flatbuffers::Offset<flatbuffers::Vector<const slimevr_protocol::datatypes::Vec3f *>> raw_rot_vel) {
    fbb_.AddOffset(SensorReport::VT_RAW_ROT_VEL, raw_rot_vel);
  }
  explicit SensorReportBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SensorReport> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SensorReport>(end);
    return o;
  }
};

inline flatbuffers::Offset<SensorReport> CreateSensorReport(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const slimevr_protocol::datatypes::Quat *>> orientation = 0,
    flatbuffers::Offset<flatbuffers::Vector<const slimevr_protocol::datatypes::Vec3f *>> raw_trans_accel = 0,
    flatbuffers::Offset<flatbuffers::Vector<const slimevr_protocol::datatypes::Vec3f *>> raw_rot_vel = 0) {
  SensorReportBuilder builder_(_fbb);
  builder_.add_raw_rot_vel(raw_rot_vel);
  builder_.add_raw_trans_accel(raw_trans_accel);
  builder_.add_orientation(orientation);
  return builder_.Finish();
}

inline flatbuffers::Offset<SensorReport> CreateSensorReportDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<slimevr_protocol::datatypes::Quat> *orientation = nullptr,
    const std::vector<slimevr_protocol::datatypes::Vec3f> *raw_trans_accel = nullptr,
    const std::vector<slimevr_protocol::datatypes::Vec3f> *raw_rot_vel = nullptr) {
  auto orientation__ = orientation ? _fbb.CreateVectorOfStructs<slimevr_protocol::datatypes::Quat>(*orientation) : 0;
  auto raw_trans_accel__ = raw_trans_accel ? _fbb.CreateVectorOfStructs<slimevr_protocol::datatypes::Vec3f>(*raw_trans_accel) : 0;
  auto raw_rot_vel__ = raw_rot_vel ? _fbb.CreateVectorOfStructs<slimevr_protocol::datatypes::Vec3f>(*raw_rot_vel) : 0;
  return slimevr_protocol::CreateSensorReport(
      _fbb,
      orientation__,
      raw_trans_accel__,
      raw_rot_vel__);
}

struct Acknowledgement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AcknowledgementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACKET_ID = 4
  };
  uint64_t packet_id() const {
    return GetField<uint64_t>(VT_PACKET_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PACKET_ID, 8) &&
           verifier.EndTable();
  }
};

struct AcknowledgementBuilder {
  typedef Acknowledgement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_packet_id(uint64_t packet_id) {
    fbb_.AddElement<uint64_t>(Acknowledgement::VT_PACKET_ID, packet_id, 0);
  }
  explicit AcknowledgementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Acknowledgement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Acknowledgement>(end);
    return o;
  }
};

inline flatbuffers::Offset<Acknowledgement> CreateAcknowledgement(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t packet_id = 0) {
  AcknowledgementBuilder builder_(_fbb);
  builder_.add_packet_id(packet_id);
  return builder_.Finish();
}

struct HeartbeatRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeartbeatRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HeartbeatRequestBuilder {
  typedef HeartbeatRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HeartbeatRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HeartbeatRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeartbeatRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeartbeatRequest> CreateHeartbeatRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HeartbeatRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HandshakeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HandshakeRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICE_INFO = 4
  };
  const slimevr_protocol::hardware_info::DeviceInfo *device_info() const {
    return GetPointer<const slimevr_protocol::hardware_info::DeviceInfo *>(VT_DEVICE_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICE_INFO) &&
           verifier.VerifyTable(device_info()) &&
           verifier.EndTable();
  }
};

struct HandshakeRequestBuilder {
  typedef HandshakeRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_device_info(flatbuffers::Offset<slimevr_protocol::hardware_info::DeviceInfo> device_info) {
    fbb_.AddOffset(HandshakeRequest::VT_DEVICE_INFO, device_info);
  }
  explicit HandshakeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HandshakeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HandshakeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HandshakeRequest> CreateHandshakeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<slimevr_protocol::hardware_info::DeviceInfo> device_info = 0) {
  HandshakeRequestBuilder builder_(_fbb);
  builder_.add_device_info(device_info);
  return builder_.Finish();
}

struct DeviceInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceInfoRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DeviceInfoRequestBuilder {
  typedef DeviceInfoRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DeviceInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceInfoRequest> CreateDeviceInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DeviceInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DeviceStatusRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceStatusRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DeviceStatusRequestBuilder {
  typedef DeviceStatusRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DeviceStatusRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceStatusRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceStatusRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceStatusRequest> CreateDeviceStatusRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DeviceStatusRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DeviceStatusResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceStatusResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RSSI = 4,
    VT_IMU_STATUS = 6,
    VT_MCU_STATUS = 8,
    VT_BATTERY_VOLTAGE = 10,
    VT_BATTERY_PCT_ESTIMATE = 12
  };
  int64_t rssi() const {
    return GetField<int64_t>(VT_RSSI, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::hardware_info::ImuStatus>> *imu_status() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::hardware_info::ImuStatus>> *>(VT_IMU_STATUS);
  }
  const slimevr_protocol::hardware_info::McuStatus *mcu_status() const {
    return GetPointer<const slimevr_protocol::hardware_info::McuStatus *>(VT_MCU_STATUS);
  }
  float battery_voltage() const {
    return GetField<float>(VT_BATTERY_VOLTAGE, 0.0f);
  }
  float battery_pct_estimate() const {
    return GetField<float>(VT_BATTERY_PCT_ESTIMATE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_RSSI, 8) &&
           VerifyOffset(verifier, VT_IMU_STATUS) &&
           verifier.VerifyVector(imu_status()) &&
           verifier.VerifyVectorOfTables(imu_status()) &&
           VerifyOffset(verifier, VT_MCU_STATUS) &&
           verifier.VerifyTable(mcu_status()) &&
           VerifyField<float>(verifier, VT_BATTERY_VOLTAGE, 4) &&
           VerifyField<float>(verifier, VT_BATTERY_PCT_ESTIMATE, 4) &&
           verifier.EndTable();
  }
};

struct DeviceStatusResponseBuilder {
  typedef DeviceStatusResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rssi(int64_t rssi) {
    fbb_.AddElement<int64_t>(DeviceStatusResponse::VT_RSSI, rssi, 0);
  }
  void add_imu_status(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::hardware_info::ImuStatus>>> imu_status) {
    fbb_.AddOffset(DeviceStatusResponse::VT_IMU_STATUS, imu_status);
  }
  void add_mcu_status(flatbuffers::Offset<slimevr_protocol::hardware_info::McuStatus> mcu_status) {
    fbb_.AddOffset(DeviceStatusResponse::VT_MCU_STATUS, mcu_status);
  }
  void add_battery_voltage(float battery_voltage) {
    fbb_.AddElement<float>(DeviceStatusResponse::VT_BATTERY_VOLTAGE, battery_voltage, 0.0f);
  }
  void add_battery_pct_estimate(float battery_pct_estimate) {
    fbb_.AddElement<float>(DeviceStatusResponse::VT_BATTERY_PCT_ESTIMATE, battery_pct_estimate, 0.0f);
  }
  explicit DeviceStatusResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceStatusResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceStatusResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceStatusResponse> CreateDeviceStatusResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t rssi = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::hardware_info::ImuStatus>>> imu_status = 0,
    flatbuffers::Offset<slimevr_protocol::hardware_info::McuStatus> mcu_status = 0,
    float battery_voltage = 0.0f,
    float battery_pct_estimate = 0.0f) {
  DeviceStatusResponseBuilder builder_(_fbb);
  builder_.add_rssi(rssi);
  builder_.add_battery_pct_estimate(battery_pct_estimate);
  builder_.add_battery_voltage(battery_voltage);
  builder_.add_mcu_status(mcu_status);
  builder_.add_imu_status(imu_status);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceStatusResponse> CreateDeviceStatusResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t rssi = 0,
    const std::vector<flatbuffers::Offset<slimevr_protocol::hardware_info::ImuStatus>> *imu_status = nullptr,
    flatbuffers::Offset<slimevr_protocol::hardware_info::McuStatus> mcu_status = 0,
    float battery_voltage = 0.0f,
    float battery_pct_estimate = 0.0f) {
  auto imu_status__ = imu_status ? _fbb.CreateVector<flatbuffers::Offset<slimevr_protocol::hardware_info::ImuStatus>>(*imu_status) : 0;
  return slimevr_protocol::CreateDeviceStatusResponse(
      _fbb,
      rssi,
      imu_status__,
      mcu_status,
      battery_voltage,
      battery_pct_estimate);
}

inline bool VerifyInboundUnion(flatbuffers::Verifier &verifier, const void *obj, InboundUnion type) {
  switch (type) {
    case InboundUnion::NONE: {
      return true;
    }
    case InboundUnion::LogData: {
      auto ptr = reinterpret_cast<const slimevr_protocol::LogData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InboundUnion::SensorReport: {
      auto ptr = reinterpret_cast<const slimevr_protocol::SensorReport *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InboundUnion::Acknowledgement: {
      auto ptr = reinterpret_cast<const slimevr_protocol::Acknowledgement *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InboundUnion::HeartbeatRequest: {
      auto ptr = reinterpret_cast<const slimevr_protocol::HeartbeatRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InboundUnion::HandshakeRequest: {
      auto ptr = reinterpret_cast<const slimevr_protocol::HandshakeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InboundUnion::slimevr_protocol_hardware_info_DeviceInfo: {
      auto ptr = reinterpret_cast<const slimevr_protocol::hardware_info::DeviceInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InboundUnion::DeviceStatusResponse: {
      auto ptr = reinterpret_cast<const slimevr_protocol::DeviceStatusResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyInboundUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<InboundUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyInboundUnion(
        verifier,  values->Get(i), types->GetEnum<InboundUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyOutboundUnion(flatbuffers::Verifier &verifier, const void *obj, OutboundUnion type) {
  switch (type) {
    case OutboundUnion::NONE: {
      return true;
    }
    case OutboundUnion::ConfigureSensorReporting: {
      auto ptr = reinterpret_cast<const slimevr_protocol::ConfigureSensorReporting *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OutboundUnion::Acknowledgement: {
      auto ptr = reinterpret_cast<const slimevr_protocol::Acknowledgement *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OutboundUnion::HeartbeatRequest: {
      auto ptr = reinterpret_cast<const slimevr_protocol::HeartbeatRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OutboundUnion::DeviceInfoRequest: {
      auto ptr = reinterpret_cast<const slimevr_protocol::DeviceInfoRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OutboundUnion::DeviceStatusRequest: {
      auto ptr = reinterpret_cast<const slimevr_protocol::DeviceStatusRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOutboundUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<OutboundUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOutboundUnion(
        verifier,  values->Get(i), types->GetEnum<OutboundUnion>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace slimevr_protocol

#endif  // FLATBUFFERS_GENERATED_PROTOCOL_SLIMEVR_PROTOCOL_H_
