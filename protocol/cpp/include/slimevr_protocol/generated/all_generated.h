// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ALL_SLIMEVR_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_ALL_SLIMEVR_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace slimevr_protocol {
namespace datatypes {

struct Acknowledgement;
struct AcknowledgementBuilder;

struct LogData;
struct LogDataBuilder;

namespace hardware_info {

struct MacAddress;

struct FirmwareInfo;
struct FirmwareInfoBuilder;

struct FirmwareInfoMask;
struct FirmwareInfoMaskBuilder;

struct FirmwareStatus;
struct FirmwareStatusBuilder;

struct FirmwareStatusMask;
struct FirmwareStatusMaskBuilder;

}  // namespace hardware_info

namespace math {

struct Quat;

struct Vec3f;

}  // namespace math

namespace tracker {

struct TrackerStatus;
struct TrackerStatusBuilder;

struct TrackerStatusMask;
struct TrackerStatusMaskBuilder;

}  // namespace tracker
}  // namespace datatypes

namespace data_feed {

struct PollDataFeed;
struct PollDataFeedBuilder;

struct DataFeedRequest;
struct DataFeedRequestBuilder;

struct DataFeedUpdate;
struct DataFeedUpdateBuilder;

struct DataFeedConfig;
struct DataFeedConfigBuilder;

struct DeviceStatusMask;
struct DeviceStatusMaskBuilder;

struct DeviceStatus;
struct DeviceStatusBuilder;

}  // namespace data_feed

namespace rpc {

struct HeartbeatRequest;
struct HeartbeatRequestBuilder;

struct ResetRequest;
struct ResetRequestBuilder;

struct AssignTrackerRequest;
struct AssignTrackerRequestBuilder;

struct SettingsRequest;
struct SettingsRequestBuilder;

struct SettingsResponse;
struct SettingsResponseBuilder;

struct ChangeSettingsRequest;
struct ChangeSettingsRequestBuilder;

struct SteamVRTrackersSetting;
struct SteamVRTrackersSettingBuilder;

struct FilteringSettings;
struct FilteringSettingsBuilder;

}  // namespace rpc

struct InboundPacket;
struct InboundPacketBuilder;

struct OutboundPacket;
struct OutboundPacketBuilder;

namespace datatypes {

/// A list of error codes for error conditions on the device
enum class FirmwareErrorCode : uint8_t {
  Other = 0,
  Disconnected = 1,
  Occluded = 2,
  ImuError = 3,
  MIN = Other,
  MAX = ImuError
};

inline const FirmwareErrorCode (&EnumValuesFirmwareErrorCode())[4] {
  static const FirmwareErrorCode values[] = {
    FirmwareErrorCode::Other,
    FirmwareErrorCode::Disconnected,
    FirmwareErrorCode::Occluded,
    FirmwareErrorCode::ImuError
  };
  return values;
}

inline const char * const *EnumNamesFirmwareErrorCode() {
  static const char * const names[5] = {
    "Other",
    "Disconnected",
    "Occluded",
    "ImuError",
    nullptr
  };
  return names;
}

inline const char *EnumNameFirmwareErrorCode(FirmwareErrorCode e) {
  if (flatbuffers::IsOutRange(e, FirmwareErrorCode::Other, FirmwareErrorCode::ImuError)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFirmwareErrorCode()[index];
}

/// Used for prediction in firmware
enum class FilteringType : uint8_t {
  NONE = 0,
  INTERPOLATION = 1,
  EXTRAPOLATION = 2,
  MIN = NONE,
  MAX = EXTRAPOLATION
};

inline const FilteringType (&EnumValuesFilteringType())[3] {
  static const FilteringType values[] = {
    FilteringType::NONE,
    FilteringType::INTERPOLATION,
    FilteringType::EXTRAPOLATION
  };
  return values;
}

inline const char * const *EnumNamesFilteringType() {
  static const char * const names[4] = {
    "NONE",
    "INTERPOLATION",
    "EXTRAPOLATION",
    nullptr
  };
  return names;
}

inline const char *EnumNameFilteringType(FilteringType e) {
  if (flatbuffers::IsOutRange(e, FilteringType::NONE, FilteringType::EXTRAPOLATION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFilteringType()[index];
}

/// Currently from SlimeVR server.
enum class TrackerRole : uint8_t {
  NONE = 0,
  WAIST = 1,
  LEFT_FOOT = 2,
  RIGHT_FOOT = 3,
  CHEST = 4,
  LEFT_KNEE = 5,
  RIGHT_KNEE = 6,
  LEFT_ELBOW = 7,
  RIGHT_ELBOW = 8,
  LEFT_SHOULDER = 9,
  RIGHT_SHOULDER = 10,
  LEFT_HAND = 11,
  RIGHT_HAND = 12,
  LEFT_CONTROLLER = 13,
  RIGHT_CONTROLLER = 14,
  HEAD = 15,
  NECK = 16,
  CAMERA = 17,
  KEYBOARD = 18,
  HMD = 19,
  BEACON = 20,
  GENERIC_CONTROLLER = 21,
  MIN = NONE,
  MAX = GENERIC_CONTROLLER
};

inline const TrackerRole (&EnumValuesTrackerRole())[22] {
  static const TrackerRole values[] = {
    TrackerRole::NONE,
    TrackerRole::WAIST,
    TrackerRole::LEFT_FOOT,
    TrackerRole::RIGHT_FOOT,
    TrackerRole::CHEST,
    TrackerRole::LEFT_KNEE,
    TrackerRole::RIGHT_KNEE,
    TrackerRole::LEFT_ELBOW,
    TrackerRole::RIGHT_ELBOW,
    TrackerRole::LEFT_SHOULDER,
    TrackerRole::RIGHT_SHOULDER,
    TrackerRole::LEFT_HAND,
    TrackerRole::RIGHT_HAND,
    TrackerRole::LEFT_CONTROLLER,
    TrackerRole::RIGHT_CONTROLLER,
    TrackerRole::HEAD,
    TrackerRole::NECK,
    TrackerRole::CAMERA,
    TrackerRole::KEYBOARD,
    TrackerRole::HMD,
    TrackerRole::BEACON,
    TrackerRole::GENERIC_CONTROLLER
  };
  return values;
}

inline const char * const *EnumNamesTrackerRole() {
  static const char * const names[23] = {
    "NONE",
    "WAIST",
    "LEFT_FOOT",
    "RIGHT_FOOT",
    "CHEST",
    "LEFT_KNEE",
    "RIGHT_KNEE",
    "LEFT_ELBOW",
    "RIGHT_ELBOW",
    "LEFT_SHOULDER",
    "RIGHT_SHOULDER",
    "LEFT_HAND",
    "RIGHT_HAND",
    "LEFT_CONTROLLER",
    "RIGHT_CONTROLLER",
    "HEAD",
    "NECK",
    "CAMERA",
    "KEYBOARD",
    "HMD",
    "BEACON",
    "GENERIC_CONTROLLER",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrackerRole(TrackerRole e) {
  if (flatbuffers::IsOutRange(e, TrackerRole::NONE, TrackerRole::GENERIC_CONTROLLER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrackerRole()[index];
}

namespace hardware_info {

enum class McuType : uint16_t {
  Other = 0,
  ESP8266 = 1,
  ESP32_S2 = 2,
  ESP32_S3 = 3,
  ESP32_C3 = 4,
  MIN = Other,
  MAX = ESP32_C3
};

inline const McuType (&EnumValuesMcuType())[5] {
  static const McuType values[] = {
    McuType::Other,
    McuType::ESP8266,
    McuType::ESP32_S2,
    McuType::ESP32_S3,
    McuType::ESP32_C3
  };
  return values;
}

inline const char * const *EnumNamesMcuType() {
  static const char * const names[6] = {
    "Other",
    "ESP8266",
    "ESP32_S2",
    "ESP32_S3",
    "ESP32_C3",
    nullptr
  };
  return names;
}

inline const char *EnumNameMcuType(McuType e) {
  if (flatbuffers::IsOutRange(e, McuType::Other, McuType::ESP32_C3)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMcuType()[index];
}

enum class ImuType : uint16_t {
  Other = 0,
  BNO085 = 1,
  BNO080 = 2,
  MPU6050 = 3,
  MPU9250 = 4,
  MPU6500 = 5,
  MIN = Other,
  MAX = MPU6500
};

inline const ImuType (&EnumValuesImuType())[6] {
  static const ImuType values[] = {
    ImuType::Other,
    ImuType::BNO085,
    ImuType::BNO080,
    ImuType::MPU6050,
    ImuType::MPU9250,
    ImuType::MPU6500
  };
  return values;
}

inline const char * const *EnumNamesImuType() {
  static const char * const names[7] = {
    "Other",
    "BNO085",
    "BNO080",
    "MPU6050",
    "MPU9250",
    "MPU6500",
    nullptr
  };
  return names;
}

inline const char *EnumNameImuType(ImuType e) {
  if (flatbuffers::IsOutRange(e, ImuType::Other, ImuType::MPU6500)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesImuType()[index];
}

}  // namespace hardware_info
}  // namespace datatypes

enum class InboundUnion : uint8_t {
  NONE = 0,
  slimevr_protocol_rpc_HeartbeatRequest = 1,
  slimevr_protocol_rpc_ResetRequest = 2,
  slimevr_protocol_rpc_AssignTrackerRequest = 3,
  slimevr_protocol_rpc_SettingsRequest = 4,
  slimevr_protocol_rpc_ChangeSettingsRequest = 5,
  slimevr_protocol_data_feed_PollDataFeed = 6,
  slimevr_protocol_data_feed_DataFeedRequest = 7,
  slimevr_protocol_data_feed_DataFeedUpdate = 8,
  MIN = NONE,
  MAX = slimevr_protocol_data_feed_DataFeedUpdate
};

inline const InboundUnion (&EnumValuesInboundUnion())[9] {
  static const InboundUnion values[] = {
    InboundUnion::NONE,
    InboundUnion::slimevr_protocol_rpc_HeartbeatRequest,
    InboundUnion::slimevr_protocol_rpc_ResetRequest,
    InboundUnion::slimevr_protocol_rpc_AssignTrackerRequest,
    InboundUnion::slimevr_protocol_rpc_SettingsRequest,
    InboundUnion::slimevr_protocol_rpc_ChangeSettingsRequest,
    InboundUnion::slimevr_protocol_data_feed_PollDataFeed,
    InboundUnion::slimevr_protocol_data_feed_DataFeedRequest,
    InboundUnion::slimevr_protocol_data_feed_DataFeedUpdate
  };
  return values;
}

inline const char * const *EnumNamesInboundUnion() {
  static const char * const names[10] = {
    "NONE",
    "slimevr_protocol_rpc_HeartbeatRequest",
    "slimevr_protocol_rpc_ResetRequest",
    "slimevr_protocol_rpc_AssignTrackerRequest",
    "slimevr_protocol_rpc_SettingsRequest",
    "slimevr_protocol_rpc_ChangeSettingsRequest",
    "slimevr_protocol_data_feed_PollDataFeed",
    "slimevr_protocol_data_feed_DataFeedRequest",
    "slimevr_protocol_data_feed_DataFeedUpdate",
    nullptr
  };
  return names;
}

inline const char *EnumNameInboundUnion(InboundUnion e) {
  if (flatbuffers::IsOutRange(e, InboundUnion::NONE, InboundUnion::slimevr_protocol_data_feed_DataFeedUpdate)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInboundUnion()[index];
}

template<typename T> struct InboundUnionTraits {
  static const InboundUnion enum_value = InboundUnion::NONE;
};

template<> struct InboundUnionTraits<slimevr_protocol::rpc::HeartbeatRequest> {
  static const InboundUnion enum_value = InboundUnion::slimevr_protocol_rpc_HeartbeatRequest;
};

template<> struct InboundUnionTraits<slimevr_protocol::rpc::ResetRequest> {
  static const InboundUnion enum_value = InboundUnion::slimevr_protocol_rpc_ResetRequest;
};

template<> struct InboundUnionTraits<slimevr_protocol::rpc::AssignTrackerRequest> {
  static const InboundUnion enum_value = InboundUnion::slimevr_protocol_rpc_AssignTrackerRequest;
};

template<> struct InboundUnionTraits<slimevr_protocol::rpc::SettingsRequest> {
  static const InboundUnion enum_value = InboundUnion::slimevr_protocol_rpc_SettingsRequest;
};

template<> struct InboundUnionTraits<slimevr_protocol::rpc::ChangeSettingsRequest> {
  static const InboundUnion enum_value = InboundUnion::slimevr_protocol_rpc_ChangeSettingsRequest;
};

template<> struct InboundUnionTraits<slimevr_protocol::data_feed::PollDataFeed> {
  static const InboundUnion enum_value = InboundUnion::slimevr_protocol_data_feed_PollDataFeed;
};

template<> struct InboundUnionTraits<slimevr_protocol::data_feed::DataFeedRequest> {
  static const InboundUnion enum_value = InboundUnion::slimevr_protocol_data_feed_DataFeedRequest;
};

template<> struct InboundUnionTraits<slimevr_protocol::data_feed::DataFeedUpdate> {
  static const InboundUnion enum_value = InboundUnion::slimevr_protocol_data_feed_DataFeedUpdate;
};

bool VerifyInboundUnion(flatbuffers::Verifier &verifier, const void *obj, InboundUnion type);
bool VerifyInboundUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<InboundUnion> *types);

enum class OutboundUnion : uint8_t {
  NONE = 0,
  slimevr_protocol_rpc_HeartbeatRequest = 1,
  slimevr_protocol_rpc_SettingsResponse = 2,
  slimevr_protocol_data_feed_PollDataFeed = 3,
  slimevr_protocol_data_feed_DataFeedRequest = 4,
  slimevr_protocol_data_feed_DataFeedUpdate = 5,
  MIN = NONE,
  MAX = slimevr_protocol_data_feed_DataFeedUpdate
};

inline const OutboundUnion (&EnumValuesOutboundUnion())[6] {
  static const OutboundUnion values[] = {
    OutboundUnion::NONE,
    OutboundUnion::slimevr_protocol_rpc_HeartbeatRequest,
    OutboundUnion::slimevr_protocol_rpc_SettingsResponse,
    OutboundUnion::slimevr_protocol_data_feed_PollDataFeed,
    OutboundUnion::slimevr_protocol_data_feed_DataFeedRequest,
    OutboundUnion::slimevr_protocol_data_feed_DataFeedUpdate
  };
  return values;
}

inline const char * const *EnumNamesOutboundUnion() {
  static const char * const names[7] = {
    "NONE",
    "slimevr_protocol_rpc_HeartbeatRequest",
    "slimevr_protocol_rpc_SettingsResponse",
    "slimevr_protocol_data_feed_PollDataFeed",
    "slimevr_protocol_data_feed_DataFeedRequest",
    "slimevr_protocol_data_feed_DataFeedUpdate",
    nullptr
  };
  return names;
}

inline const char *EnumNameOutboundUnion(OutboundUnion e) {
  if (flatbuffers::IsOutRange(e, OutboundUnion::NONE, OutboundUnion::slimevr_protocol_data_feed_DataFeedUpdate)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOutboundUnion()[index];
}

template<typename T> struct OutboundUnionTraits {
  static const OutboundUnion enum_value = OutboundUnion::NONE;
};

template<> struct OutboundUnionTraits<slimevr_protocol::rpc::HeartbeatRequest> {
  static const OutboundUnion enum_value = OutboundUnion::slimevr_protocol_rpc_HeartbeatRequest;
};

template<> struct OutboundUnionTraits<slimevr_protocol::rpc::SettingsResponse> {
  static const OutboundUnion enum_value = OutboundUnion::slimevr_protocol_rpc_SettingsResponse;
};

template<> struct OutboundUnionTraits<slimevr_protocol::data_feed::PollDataFeed> {
  static const OutboundUnion enum_value = OutboundUnion::slimevr_protocol_data_feed_PollDataFeed;
};

template<> struct OutboundUnionTraits<slimevr_protocol::data_feed::DataFeedRequest> {
  static const OutboundUnion enum_value = OutboundUnion::slimevr_protocol_data_feed_DataFeedRequest;
};

template<> struct OutboundUnionTraits<slimevr_protocol::data_feed::DataFeedUpdate> {
  static const OutboundUnion enum_value = OutboundUnion::slimevr_protocol_data_feed_DataFeedUpdate;
};

bool VerifyOutboundUnion(flatbuffers::Verifier &verifier, const void *obj, OutboundUnion type);
bool VerifyOutboundUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<OutboundUnion> *types);

namespace datatypes {
namespace hardware_info {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) MacAddress FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t byte_0_;
  uint8_t byte_1_;
  uint8_t byte_2_;
  uint8_t byte_3_;
  uint8_t byte_4_;
  uint8_t byte_5_;

 public:
  MacAddress()
      : byte_0_(0),
        byte_1_(0),
        byte_2_(0),
        byte_3_(0),
        byte_4_(0),
        byte_5_(0) {
  }
  MacAddress(uint8_t _byte_0, uint8_t _byte_1, uint8_t _byte_2, uint8_t _byte_3, uint8_t _byte_4, uint8_t _byte_5)
      : byte_0_(flatbuffers::EndianScalar(_byte_0)),
        byte_1_(flatbuffers::EndianScalar(_byte_1)),
        byte_2_(flatbuffers::EndianScalar(_byte_2)),
        byte_3_(flatbuffers::EndianScalar(_byte_3)),
        byte_4_(flatbuffers::EndianScalar(_byte_4)),
        byte_5_(flatbuffers::EndianScalar(_byte_5)) {
  }
  uint8_t byte_0() const {
    return flatbuffers::EndianScalar(byte_0_);
  }
  uint8_t byte_1() const {
    return flatbuffers::EndianScalar(byte_1_);
  }
  uint8_t byte_2() const {
    return flatbuffers::EndianScalar(byte_2_);
  }
  uint8_t byte_3() const {
    return flatbuffers::EndianScalar(byte_3_);
  }
  uint8_t byte_4() const {
    return flatbuffers::EndianScalar(byte_4_);
  }
  uint8_t byte_5() const {
    return flatbuffers::EndianScalar(byte_5_);
  }
};
FLATBUFFERS_STRUCT_END(MacAddress, 6);

}  // namespace hardware_info

namespace math {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Quat FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Quat()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Quat(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Quat, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3f()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3f(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3f, 12);

}  // namespace math

/// Sent as a response to a request for acknowledgement via the `acknowledge_me`
/// field. `packet_id` should be the packet that is being acknowledged.
struct Acknowledgement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AcknowledgementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACKET_ID = 4
  };
  uint32_t packet_id() const {
    return GetField<uint32_t>(VT_PACKET_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PACKET_ID, 4) &&
           verifier.EndTable();
  }
};

struct AcknowledgementBuilder {
  typedef Acknowledgement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_packet_id(uint32_t packet_id) {
    fbb_.AddElement<uint32_t>(Acknowledgement::VT_PACKET_ID, packet_id, 0);
  }
  explicit AcknowledgementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Acknowledgement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Acknowledgement>(end);
    return o;
  }
};

inline flatbuffers::Offset<Acknowledgement> CreateAcknowledgement(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t packet_id = 0) {
  AcknowledgementBuilder builder_(_fbb);
  builder_.add_packet_id(packet_id);
  return builder_.Finish();
}

/// General purpose logging datatype
struct LogData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct LogDataBuilder {
  typedef LogData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(LogData::VT_MESSAGE, message);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(LogData::VT_DATA, data);
  }
  explicit LogDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogData> CreateLogData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  LogDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogData> CreateLogDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return slimevr_protocol::datatypes::CreateLogData(
      _fbb,
      message__,
      data__);
}

namespace hardware_info {

/// Mostly static info about the device's hardware/firmware.
struct FirmwareInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FirmwareInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MCU_ID = 4,
    VT_IMU_IDS = 6,
    VT_DISPLAY_NAME = 8,
    VT_MODEL = 10,
    VT_MANUFACTURER = 12,
    VT_HARDWARE_REVISION = 14,
    VT_FIRMWARE_VERSION = 16,
    VT_MAC_ADDRESS = 18
  };
  slimevr_protocol::datatypes::hardware_info::McuType mcu_id() const {
    return static_cast<slimevr_protocol::datatypes::hardware_info::McuType>(GetField<uint16_t>(VT_MCU_ID, 0));
  }
  /// The Imu types, enumerated in the same order that they are referred to in
  /// the firmware.
  const flatbuffers::Vector<slimevr_protocol::datatypes::hardware_info::ImuType> *imu_ids() const {
    return GetPointer<const flatbuffers::Vector<slimevr_protocol::datatypes::hardware_info::ImuType> *>(VT_IMU_IDS);
  }
  /// A human-friendly name to display as the name of the device.
  const flatbuffers::String *display_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  /// A human-friendly string for the device model.
  const flatbuffers::String *model() const {
    return GetPointer<const flatbuffers::String *>(VT_MODEL);
  }
  /// A human-friendly string for the manufacturer of the device.
  const flatbuffers::String *manufacturer() const {
    return GetPointer<const flatbuffers::String *>(VT_MANUFACTURER);
  }
  /// The hardware version of the device. For example, pcb version.
  const flatbuffers::String *hardware_revision() const {
    return GetPointer<const flatbuffers::String *>(VT_HARDWARE_REVISION);
  }
  /// The version of the slimevr firmware that the device is running.
  const flatbuffers::String *firmware_version() const {
    return GetPointer<const flatbuffers::String *>(VT_FIRMWARE_VERSION);
  }
  const slimevr_protocol::datatypes::hardware_info::MacAddress *mac_address() const {
    return GetStruct<const slimevr_protocol::datatypes::hardware_info::MacAddress *>(VT_MAC_ADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MCU_ID, 2) &&
           VerifyOffset(verifier, VT_IMU_IDS) &&
           verifier.VerifyVector(imu_ids()) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyOffset(verifier, VT_MODEL) &&
           verifier.VerifyString(model()) &&
           VerifyOffset(verifier, VT_MANUFACTURER) &&
           verifier.VerifyString(manufacturer()) &&
           VerifyOffset(verifier, VT_HARDWARE_REVISION) &&
           verifier.VerifyString(hardware_revision()) &&
           VerifyOffset(verifier, VT_FIRMWARE_VERSION) &&
           verifier.VerifyString(firmware_version()) &&
           VerifyField<slimevr_protocol::datatypes::hardware_info::MacAddress>(verifier, VT_MAC_ADDRESS, 1) &&
           verifier.EndTable();
  }
};

struct FirmwareInfoBuilder {
  typedef FirmwareInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mcu_id(slimevr_protocol::datatypes::hardware_info::McuType mcu_id) {
    fbb_.AddElement<uint16_t>(FirmwareInfo::VT_MCU_ID, static_cast<uint16_t>(mcu_id), 0);
  }
  void add_imu_ids(flatbuffers::Offset<flatbuffers::Vector<slimevr_protocol::datatypes::hardware_info::ImuType>> imu_ids) {
    fbb_.AddOffset(FirmwareInfo::VT_IMU_IDS, imu_ids);
  }
  void add_display_name(flatbuffers::Offset<flatbuffers::String> display_name) {
    fbb_.AddOffset(FirmwareInfo::VT_DISPLAY_NAME, display_name);
  }
  void add_model(flatbuffers::Offset<flatbuffers::String> model) {
    fbb_.AddOffset(FirmwareInfo::VT_MODEL, model);
  }
  void add_manufacturer(flatbuffers::Offset<flatbuffers::String> manufacturer) {
    fbb_.AddOffset(FirmwareInfo::VT_MANUFACTURER, manufacturer);
  }
  void add_hardware_revision(flatbuffers::Offset<flatbuffers::String> hardware_revision) {
    fbb_.AddOffset(FirmwareInfo::VT_HARDWARE_REVISION, hardware_revision);
  }
  void add_firmware_version(flatbuffers::Offset<flatbuffers::String> firmware_version) {
    fbb_.AddOffset(FirmwareInfo::VT_FIRMWARE_VERSION, firmware_version);
  }
  void add_mac_address(const slimevr_protocol::datatypes::hardware_info::MacAddress *mac_address) {
    fbb_.AddStruct(FirmwareInfo::VT_MAC_ADDRESS, mac_address);
  }
  explicit FirmwareInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FirmwareInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FirmwareInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<FirmwareInfo> CreateFirmwareInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    slimevr_protocol::datatypes::hardware_info::McuType mcu_id = slimevr_protocol::datatypes::hardware_info::McuType::Other,
    flatbuffers::Offset<flatbuffers::Vector<slimevr_protocol::datatypes::hardware_info::ImuType>> imu_ids = 0,
    flatbuffers::Offset<flatbuffers::String> display_name = 0,
    flatbuffers::Offset<flatbuffers::String> model = 0,
    flatbuffers::Offset<flatbuffers::String> manufacturer = 0,
    flatbuffers::Offset<flatbuffers::String> hardware_revision = 0,
    flatbuffers::Offset<flatbuffers::String> firmware_version = 0,
    const slimevr_protocol::datatypes::hardware_info::MacAddress *mac_address = nullptr) {
  FirmwareInfoBuilder builder_(_fbb);
  builder_.add_mac_address(mac_address);
  builder_.add_firmware_version(firmware_version);
  builder_.add_hardware_revision(hardware_revision);
  builder_.add_manufacturer(manufacturer);
  builder_.add_model(model);
  builder_.add_display_name(display_name);
  builder_.add_imu_ids(imu_ids);
  builder_.add_mcu_id(mcu_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<FirmwareInfo> CreateFirmwareInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    slimevr_protocol::datatypes::hardware_info::McuType mcu_id = slimevr_protocol::datatypes::hardware_info::McuType::Other,
    const std::vector<slimevr_protocol::datatypes::hardware_info::ImuType> *imu_ids = nullptr,
    const char *display_name = nullptr,
    const char *model = nullptr,
    const char *manufacturer = nullptr,
    const char *hardware_revision = nullptr,
    const char *firmware_version = nullptr,
    const slimevr_protocol::datatypes::hardware_info::MacAddress *mac_address = nullptr) {
  auto imu_ids__ = imu_ids ? _fbb.CreateVector<slimevr_protocol::datatypes::hardware_info::ImuType>(*imu_ids) : 0;
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  auto model__ = model ? _fbb.CreateString(model) : 0;
  auto manufacturer__ = manufacturer ? _fbb.CreateString(manufacturer) : 0;
  auto hardware_revision__ = hardware_revision ? _fbb.CreateString(hardware_revision) : 0;
  auto firmware_version__ = firmware_version ? _fbb.CreateString(firmware_version) : 0;
  return slimevr_protocol::datatypes::hardware_info::CreateFirmwareInfo(
      _fbb,
      mcu_id,
      imu_ids__,
      display_name__,
      model__,
      manufacturer__,
      hardware_revision__,
      firmware_version__,
      mac_address);
}

/// A mask of the info in `FirmwareInfo`
struct FirmwareInfoMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FirmwareInfoMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MCU_ID = 4,
    VT_IMU_IDS = 6,
    VT_DISPLAY_NAME = 8,
    VT_MODEL = 10,
    VT_MANUFACTURER = 12,
    VT_HARDWARE_REVISION = 14,
    VT_FIRMWARE_VERSION = 16,
    VT_MAC_ADDRESS = 18
  };
  bool mcu_id() const {
    return GetField<uint8_t>(VT_MCU_ID, 0) != 0;
  }
  bool imu_ids() const {
    return GetField<uint8_t>(VT_IMU_IDS, 0) != 0;
  }
  bool display_name() const {
    return GetField<uint8_t>(VT_DISPLAY_NAME, 0) != 0;
  }
  bool model() const {
    return GetField<uint8_t>(VT_MODEL, 0) != 0;
  }
  bool manufacturer() const {
    return GetField<uint8_t>(VT_MANUFACTURER, 0) != 0;
  }
  bool hardware_revision() const {
    return GetField<uint8_t>(VT_HARDWARE_REVISION, 0) != 0;
  }
  bool firmware_version() const {
    return GetField<uint8_t>(VT_FIRMWARE_VERSION, 0) != 0;
  }
  bool mac_address() const {
    return GetField<uint8_t>(VT_MAC_ADDRESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MCU_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_IMU_IDS, 1) &&
           VerifyField<uint8_t>(verifier, VT_DISPLAY_NAME, 1) &&
           VerifyField<uint8_t>(verifier, VT_MODEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_MANUFACTURER, 1) &&
           VerifyField<uint8_t>(verifier, VT_HARDWARE_REVISION, 1) &&
           VerifyField<uint8_t>(verifier, VT_FIRMWARE_VERSION, 1) &&
           VerifyField<uint8_t>(verifier, VT_MAC_ADDRESS, 1) &&
           verifier.EndTable();
  }
};

struct FirmwareInfoMaskBuilder {
  typedef FirmwareInfoMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mcu_id(bool mcu_id) {
    fbb_.AddElement<uint8_t>(FirmwareInfoMask::VT_MCU_ID, static_cast<uint8_t>(mcu_id), 0);
  }
  void add_imu_ids(bool imu_ids) {
    fbb_.AddElement<uint8_t>(FirmwareInfoMask::VT_IMU_IDS, static_cast<uint8_t>(imu_ids), 0);
  }
  void add_display_name(bool display_name) {
    fbb_.AddElement<uint8_t>(FirmwareInfoMask::VT_DISPLAY_NAME, static_cast<uint8_t>(display_name), 0);
  }
  void add_model(bool model) {
    fbb_.AddElement<uint8_t>(FirmwareInfoMask::VT_MODEL, static_cast<uint8_t>(model), 0);
  }
  void add_manufacturer(bool manufacturer) {
    fbb_.AddElement<uint8_t>(FirmwareInfoMask::VT_MANUFACTURER, static_cast<uint8_t>(manufacturer), 0);
  }
  void add_hardware_revision(bool hardware_revision) {
    fbb_.AddElement<uint8_t>(FirmwareInfoMask::VT_HARDWARE_REVISION, static_cast<uint8_t>(hardware_revision), 0);
  }
  void add_firmware_version(bool firmware_version) {
    fbb_.AddElement<uint8_t>(FirmwareInfoMask::VT_FIRMWARE_VERSION, static_cast<uint8_t>(firmware_version), 0);
  }
  void add_mac_address(bool mac_address) {
    fbb_.AddElement<uint8_t>(FirmwareInfoMask::VT_MAC_ADDRESS, static_cast<uint8_t>(mac_address), 0);
  }
  explicit FirmwareInfoMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FirmwareInfoMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FirmwareInfoMask>(end);
    return o;
  }
};

inline flatbuffers::Offset<FirmwareInfoMask> CreateFirmwareInfoMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool mcu_id = false,
    bool imu_ids = false,
    bool display_name = false,
    bool model = false,
    bool manufacturer = false,
    bool hardware_revision = false,
    bool firmware_version = false,
    bool mac_address = false) {
  FirmwareInfoMaskBuilder builder_(_fbb);
  builder_.add_mac_address(mac_address);
  builder_.add_firmware_version(firmware_version);
  builder_.add_hardware_revision(hardware_revision);
  builder_.add_manufacturer(manufacturer);
  builder_.add_model(model);
  builder_.add_display_name(display_name);
  builder_.add_imu_ids(imu_ids);
  builder_.add_mcu_id(mcu_id);
  return builder_.Finish();
}

/// Mostly-dynamic status info about a tracked device's firmware
struct FirmwareStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FirmwareStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_STATUS = 4,
    VT_TPS = 6,
    VT_PING = 8,
    VT_RSSI = 10,
    VT_MCU_TEMP = 12,
    VT_BATTERY_VOLTAGE = 14,
    VT_BATTERY_PCT_ESTIMATE = 16,
    VT_LOG_DATA = 18
  };
  flatbuffers::Optional<slimevr_protocol::datatypes::FirmwareErrorCode> error_status() const {
    return GetOptional<uint8_t, slimevr_protocol::datatypes::FirmwareErrorCode>(VT_ERROR_STATUS);
  }
  flatbuffers::Optional<uint8_t> tps() const {
    return GetOptional<uint8_t, uint8_t>(VT_TPS);
  }
  flatbuffers::Optional<uint16_t> ping() const {
    return GetOptional<uint16_t, uint16_t>(VT_PING);
  }
  /// “Received Signal Strength Indicator" between device and wifi adapter in dBm
  flatbuffers::Optional<int16_t> rssi() const {
    return GetOptional<int16_t, int16_t>(VT_RSSI);
  }
  /// Temperature in degrees celsius
  flatbuffers::Optional<float> mcu_temp() const {
    return GetOptional<float, float>(VT_MCU_TEMP);
  }
  flatbuffers::Optional<float> battery_voltage() const {
    return GetOptional<float, float>(VT_BATTERY_VOLTAGE);
  }
  flatbuffers::Optional<uint8_t> battery_pct_estimate() const {
    return GetOptional<uint8_t, uint8_t>(VT_BATTERY_PCT_ESTIMATE);
  }
  const slimevr_protocol::datatypes::LogData *log_data() const {
    return GetPointer<const slimevr_protocol::datatypes::LogData *>(VT_LOG_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ERROR_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_TPS, 1) &&
           VerifyField<uint16_t>(verifier, VT_PING, 2) &&
           VerifyField<int16_t>(verifier, VT_RSSI, 2) &&
           VerifyField<float>(verifier, VT_MCU_TEMP, 4) &&
           VerifyField<float>(verifier, VT_BATTERY_VOLTAGE, 4) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_PCT_ESTIMATE, 1) &&
           VerifyOffset(verifier, VT_LOG_DATA) &&
           verifier.VerifyTable(log_data()) &&
           verifier.EndTable();
  }
};

struct FirmwareStatusBuilder {
  typedef FirmwareStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_status(slimevr_protocol::datatypes::FirmwareErrorCode error_status) {
    fbb_.AddElement<uint8_t>(FirmwareStatus::VT_ERROR_STATUS, static_cast<uint8_t>(error_status));
  }
  void add_tps(uint8_t tps) {
    fbb_.AddElement<uint8_t>(FirmwareStatus::VT_TPS, tps);
  }
  void add_ping(uint16_t ping) {
    fbb_.AddElement<uint16_t>(FirmwareStatus::VT_PING, ping);
  }
  void add_rssi(int16_t rssi) {
    fbb_.AddElement<int16_t>(FirmwareStatus::VT_RSSI, rssi);
  }
  void add_mcu_temp(float mcu_temp) {
    fbb_.AddElement<float>(FirmwareStatus::VT_MCU_TEMP, mcu_temp);
  }
  void add_battery_voltage(float battery_voltage) {
    fbb_.AddElement<float>(FirmwareStatus::VT_BATTERY_VOLTAGE, battery_voltage);
  }
  void add_battery_pct_estimate(uint8_t battery_pct_estimate) {
    fbb_.AddElement<uint8_t>(FirmwareStatus::VT_BATTERY_PCT_ESTIMATE, battery_pct_estimate);
  }
  void add_log_data(flatbuffers::Offset<slimevr_protocol::datatypes::LogData> log_data) {
    fbb_.AddOffset(FirmwareStatus::VT_LOG_DATA, log_data);
  }
  explicit FirmwareStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FirmwareStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FirmwareStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<FirmwareStatus> CreateFirmwareStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<slimevr_protocol::datatypes::FirmwareErrorCode> error_status = flatbuffers::nullopt,
    flatbuffers::Optional<uint8_t> tps = flatbuffers::nullopt,
    flatbuffers::Optional<uint16_t> ping = flatbuffers::nullopt,
    flatbuffers::Optional<int16_t> rssi = flatbuffers::nullopt,
    flatbuffers::Optional<float> mcu_temp = flatbuffers::nullopt,
    flatbuffers::Optional<float> battery_voltage = flatbuffers::nullopt,
    flatbuffers::Optional<uint8_t> battery_pct_estimate = flatbuffers::nullopt,
    flatbuffers::Offset<slimevr_protocol::datatypes::LogData> log_data = 0) {
  FirmwareStatusBuilder builder_(_fbb);
  builder_.add_log_data(log_data);
  if(battery_voltage) { builder_.add_battery_voltage(*battery_voltage); }
  if(mcu_temp) { builder_.add_mcu_temp(*mcu_temp); }
  if(rssi) { builder_.add_rssi(*rssi); }
  if(ping) { builder_.add_ping(*ping); }
  if(battery_pct_estimate) { builder_.add_battery_pct_estimate(*battery_pct_estimate); }
  if(tps) { builder_.add_tps(*tps); }
  if(error_status) { builder_.add_error_status(*error_status); }
  return builder_.Finish();
}

/// A mask of the data in `FirmwareStatus`
struct FirmwareStatusMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FirmwareStatusMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_STATUS = 4,
    VT_TPS = 6,
    VT_PING = 8,
    VT_RSSI = 10,
    VT_MCU_TEMP = 12,
    VT_BATTERY_VOLTAGE = 14,
    VT_BATTERY_PCT_ESTIMATE = 16
  };
  bool error_status() const {
    return GetField<uint8_t>(VT_ERROR_STATUS, 0) != 0;
  }
  bool tps() const {
    return GetField<uint8_t>(VT_TPS, 0) != 0;
  }
  bool ping() const {
    return GetField<uint8_t>(VT_PING, 0) != 0;
  }
  bool rssi() const {
    return GetField<uint8_t>(VT_RSSI, 0) != 0;
  }
  bool mcu_temp() const {
    return GetField<uint8_t>(VT_MCU_TEMP, 0) != 0;
  }
  bool battery_voltage() const {
    return GetField<uint8_t>(VT_BATTERY_VOLTAGE, 0) != 0;
  }
  bool battery_pct_estimate() const {
    return GetField<uint8_t>(VT_BATTERY_PCT_ESTIMATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ERROR_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_TPS, 1) &&
           VerifyField<uint8_t>(verifier, VT_PING, 1) &&
           VerifyField<uint8_t>(verifier, VT_RSSI, 1) &&
           VerifyField<uint8_t>(verifier, VT_MCU_TEMP, 1) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_VOLTAGE, 1) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_PCT_ESTIMATE, 1) &&
           verifier.EndTable();
  }
};

struct FirmwareStatusMaskBuilder {
  typedef FirmwareStatusMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_status(bool error_status) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_ERROR_STATUS, static_cast<uint8_t>(error_status), 0);
  }
  void add_tps(bool tps) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_TPS, static_cast<uint8_t>(tps), 0);
  }
  void add_ping(bool ping) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_PING, static_cast<uint8_t>(ping), 0);
  }
  void add_rssi(bool rssi) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_RSSI, static_cast<uint8_t>(rssi), 0);
  }
  void add_mcu_temp(bool mcu_temp) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_MCU_TEMP, static_cast<uint8_t>(mcu_temp), 0);
  }
  void add_battery_voltage(bool battery_voltage) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_BATTERY_VOLTAGE, static_cast<uint8_t>(battery_voltage), 0);
  }
  void add_battery_pct_estimate(bool battery_pct_estimate) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_BATTERY_PCT_ESTIMATE, static_cast<uint8_t>(battery_pct_estimate), 0);
  }
  explicit FirmwareStatusMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FirmwareStatusMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FirmwareStatusMask>(end);
    return o;
  }
};

inline flatbuffers::Offset<FirmwareStatusMask> CreateFirmwareStatusMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool error_status = false,
    bool tps = false,
    bool ping = false,
    bool rssi = false,
    bool mcu_temp = false,
    bool battery_voltage = false,
    bool battery_pct_estimate = false) {
  FirmwareStatusMaskBuilder builder_(_fbb);
  builder_.add_battery_pct_estimate(battery_pct_estimate);
  builder_.add_battery_voltage(battery_voltage);
  builder_.add_mcu_temp(mcu_temp);
  builder_.add_rssi(rssi);
  builder_.add_ping(ping);
  builder_.add_tps(tps);
  builder_.add_error_status(error_status);
  return builder_.Finish();
}

}  // namespace hardware_info

namespace tracker {

/// Contains all the relevant sensor data about a tracker. A tracker is anything that
/// provides kinematic data about a particular body part.
///
/// Trackers may be synthetic/computed or instead part of an actual hardware device.
struct TrackerStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackerStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROLE = 4,
    VT_ORIENTATION = 6,
    VT_POSITION = 8,
    VT_RAW_ROT_VEL = 10,
    VT_RAW_TRANS_ACCEL = 12,
    VT_TEMP = 14,
    VT_POLL_RATE = 16,
    VT_MOUNTING_ORIENTATION = 18
  };
  /// The user-assigned role of the tracker.
  flatbuffers::Optional<slimevr_protocol::datatypes::TrackerRole> role() const {
    return GetOptional<uint8_t, slimevr_protocol::datatypes::TrackerRole>(VT_ROLE);
  }
  const slimevr_protocol::datatypes::math::Quat *orientation() const {
    return GetStruct<const slimevr_protocol::datatypes::math::Quat *>(VT_ORIENTATION);
  }
  /// Position, in meters
  const slimevr_protocol::datatypes::math::Vec3f *position() const {
    return GetStruct<const slimevr_protocol::datatypes::math::Vec3f *>(VT_POSITION);
  }
  /// Raw rotational velocity, in euler angles
  const slimevr_protocol::datatypes::math::Vec3f *raw_rot_vel() const {
    return GetStruct<const slimevr_protocol::datatypes::math::Vec3f *>(VT_RAW_ROT_VEL);
  }
  /// Raw translational acceleration, in m/s^2
  const slimevr_protocol::datatypes::math::Vec3f *raw_trans_accel() const {
    return GetStruct<const slimevr_protocol::datatypes::math::Vec3f *>(VT_RAW_TRANS_ACCEL);
  }
  /// Temperature in degrees celsius
  flatbuffers::Optional<float> temp() const {
    return GetOptional<float, float>(VT_TEMP);
  }
  /// average samples per second
  flatbuffers::Optional<float> poll_rate() const {
    return GetOptional<float, float>(VT_POLL_RATE);
  }
  /// The orientation of the tracker when mounted on the body
  const slimevr_protocol::datatypes::math::Quat *mounting_orientation() const {
    return GetStruct<const slimevr_protocol::datatypes::math::Quat *>(VT_MOUNTING_ORIENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ROLE, 1) &&
           VerifyField<slimevr_protocol::datatypes::math::Quat>(verifier, VT_ORIENTATION, 4) &&
           VerifyField<slimevr_protocol::datatypes::math::Vec3f>(verifier, VT_POSITION, 4) &&
           VerifyField<slimevr_protocol::datatypes::math::Vec3f>(verifier, VT_RAW_ROT_VEL, 4) &&
           VerifyField<slimevr_protocol::datatypes::math::Vec3f>(verifier, VT_RAW_TRANS_ACCEL, 4) &&
           VerifyField<float>(verifier, VT_TEMP, 4) &&
           VerifyField<float>(verifier, VT_POLL_RATE, 4) &&
           VerifyField<slimevr_protocol::datatypes::math::Quat>(verifier, VT_MOUNTING_ORIENTATION, 4) &&
           verifier.EndTable();
  }
};

struct TrackerStatusBuilder {
  typedef TrackerStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_role(slimevr_protocol::datatypes::TrackerRole role) {
    fbb_.AddElement<uint8_t>(TrackerStatus::VT_ROLE, static_cast<uint8_t>(role));
  }
  void add_orientation(const slimevr_protocol::datatypes::math::Quat *orientation) {
    fbb_.AddStruct(TrackerStatus::VT_ORIENTATION, orientation);
  }
  void add_position(const slimevr_protocol::datatypes::math::Vec3f *position) {
    fbb_.AddStruct(TrackerStatus::VT_POSITION, position);
  }
  void add_raw_rot_vel(const slimevr_protocol::datatypes::math::Vec3f *raw_rot_vel) {
    fbb_.AddStruct(TrackerStatus::VT_RAW_ROT_VEL, raw_rot_vel);
  }
  void add_raw_trans_accel(const slimevr_protocol::datatypes::math::Vec3f *raw_trans_accel) {
    fbb_.AddStruct(TrackerStatus::VT_RAW_TRANS_ACCEL, raw_trans_accel);
  }
  void add_temp(float temp) {
    fbb_.AddElement<float>(TrackerStatus::VT_TEMP, temp);
  }
  void add_poll_rate(float poll_rate) {
    fbb_.AddElement<float>(TrackerStatus::VT_POLL_RATE, poll_rate);
  }
  void add_mounting_orientation(const slimevr_protocol::datatypes::math::Quat *mounting_orientation) {
    fbb_.AddStruct(TrackerStatus::VT_MOUNTING_ORIENTATION, mounting_orientation);
  }
  explicit TrackerStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrackerStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackerStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackerStatus> CreateTrackerStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<slimevr_protocol::datatypes::TrackerRole> role = flatbuffers::nullopt,
    const slimevr_protocol::datatypes::math::Quat *orientation = nullptr,
    const slimevr_protocol::datatypes::math::Vec3f *position = nullptr,
    const slimevr_protocol::datatypes::math::Vec3f *raw_rot_vel = nullptr,
    const slimevr_protocol::datatypes::math::Vec3f *raw_trans_accel = nullptr,
    flatbuffers::Optional<float> temp = flatbuffers::nullopt,
    flatbuffers::Optional<float> poll_rate = flatbuffers::nullopt,
    const slimevr_protocol::datatypes::math::Quat *mounting_orientation = nullptr) {
  TrackerStatusBuilder builder_(_fbb);
  builder_.add_mounting_orientation(mounting_orientation);
  if(poll_rate) { builder_.add_poll_rate(*poll_rate); }
  if(temp) { builder_.add_temp(*temp); }
  builder_.add_raw_trans_accel(raw_trans_accel);
  builder_.add_raw_rot_vel(raw_rot_vel);
  builder_.add_position(position);
  builder_.add_orientation(orientation);
  if(role) { builder_.add_role(*role); }
  return builder_.Finish();
}

/// A mask of the data in `TrackerStatus`
struct TrackerStatusMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackerStatusMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROLE = 4,
    VT_ORIENTATION = 6,
    VT_POSITION = 8,
    VT_RAW_ROT_VEL = 10,
    VT_RAW_TRANS_ACCEL = 12,
    VT_TEMP = 14,
    VT_POLL_RATE = 16,
    VT_MOUNTING_ROTATION = 18
  };
  bool role() const {
    return GetField<uint8_t>(VT_ROLE, 0) != 0;
  }
  bool orientation() const {
    return GetField<uint8_t>(VT_ORIENTATION, 0) != 0;
  }
  bool position() const {
    return GetField<uint8_t>(VT_POSITION, 0) != 0;
  }
  bool raw_rot_vel() const {
    return GetField<uint8_t>(VT_RAW_ROT_VEL, 0) != 0;
  }
  bool raw_trans_accel() const {
    return GetField<uint8_t>(VT_RAW_TRANS_ACCEL, 0) != 0;
  }
  bool temp() const {
    return GetField<uint8_t>(VT_TEMP, 0) != 0;
  }
  bool poll_rate() const {
    return GetField<uint8_t>(VT_POLL_RATE, 0) != 0;
  }
  bool mounting_rotation() const {
    return GetField<uint8_t>(VT_MOUNTING_ROTATION, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ROLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ORIENTATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_POSITION, 1) &&
           VerifyField<uint8_t>(verifier, VT_RAW_ROT_VEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_RAW_TRANS_ACCEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_TEMP, 1) &&
           VerifyField<uint8_t>(verifier, VT_POLL_RATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_MOUNTING_ROTATION, 1) &&
           verifier.EndTable();
  }
};

struct TrackerStatusMaskBuilder {
  typedef TrackerStatusMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_role(bool role) {
    fbb_.AddElement<uint8_t>(TrackerStatusMask::VT_ROLE, static_cast<uint8_t>(role), 0);
  }
  void add_orientation(bool orientation) {
    fbb_.AddElement<uint8_t>(TrackerStatusMask::VT_ORIENTATION, static_cast<uint8_t>(orientation), 0);
  }
  void add_position(bool position) {
    fbb_.AddElement<uint8_t>(TrackerStatusMask::VT_POSITION, static_cast<uint8_t>(position), 0);
  }
  void add_raw_rot_vel(bool raw_rot_vel) {
    fbb_.AddElement<uint8_t>(TrackerStatusMask::VT_RAW_ROT_VEL, static_cast<uint8_t>(raw_rot_vel), 0);
  }
  void add_raw_trans_accel(bool raw_trans_accel) {
    fbb_.AddElement<uint8_t>(TrackerStatusMask::VT_RAW_TRANS_ACCEL, static_cast<uint8_t>(raw_trans_accel), 0);
  }
  void add_temp(bool temp) {
    fbb_.AddElement<uint8_t>(TrackerStatusMask::VT_TEMP, static_cast<uint8_t>(temp), 0);
  }
  void add_poll_rate(bool poll_rate) {
    fbb_.AddElement<uint8_t>(TrackerStatusMask::VT_POLL_RATE, static_cast<uint8_t>(poll_rate), 0);
  }
  void add_mounting_rotation(bool mounting_rotation) {
    fbb_.AddElement<uint8_t>(TrackerStatusMask::VT_MOUNTING_ROTATION, static_cast<uint8_t>(mounting_rotation), 0);
  }
  explicit TrackerStatusMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrackerStatusMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackerStatusMask>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackerStatusMask> CreateTrackerStatusMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool role = false,
    bool orientation = false,
    bool position = false,
    bool raw_rot_vel = false,
    bool raw_trans_accel = false,
    bool temp = false,
    bool poll_rate = false,
    bool mounting_rotation = false) {
  TrackerStatusMaskBuilder builder_(_fbb);
  builder_.add_mounting_rotation(mounting_rotation);
  builder_.add_poll_rate(poll_rate);
  builder_.add_temp(temp);
  builder_.add_raw_trans_accel(raw_trans_accel);
  builder_.add_raw_rot_vel(raw_rot_vel);
  builder_.add_position(position);
  builder_.add_orientation(orientation);
  builder_.add_role(role);
  return builder_.Finish();
}

}  // namespace tracker
}  // namespace datatypes

namespace data_feed {

/// Requests for a single `DataFeedUpdate` to be sent. This is helpful when getting
/// initial info about the device.
struct PollDataFeed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PollDataFeedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIG = 4
  };
  const slimevr_protocol::data_feed::DataFeedConfig *config() const {
    return GetPointer<const slimevr_protocol::data_feed::DataFeedConfig *>(VT_CONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           verifier.EndTable();
  }
};

struct PollDataFeedBuilder {
  typedef PollDataFeed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_config(flatbuffers::Offset<slimevr_protocol::data_feed::DataFeedConfig> config) {
    fbb_.AddOffset(PollDataFeed::VT_CONFIG, config);
  }
  explicit PollDataFeedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PollDataFeed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PollDataFeed>(end);
    return o;
  }
};

inline flatbuffers::Offset<PollDataFeed> CreatePollDataFeed(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<slimevr_protocol::data_feed::DataFeedConfig> config = 0) {
  PollDataFeedBuilder builder_(_fbb);
  builder_.add_config(config);
  return builder_.Finish();
}

/// Requests for the other party to send `data_feeds`.
/// For example, GUI requests for position data to be sent from server.
///
/// When sending a new `DataFeedRequest`, the old data feeds will stop existing.
/// We still support multiple data feeds at the same time, because `data_feeds`
/// is a list.
///
/// Multiple data feeds are useful to get data at different frequencies.
struct DataFeedRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataFeedRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_FEEDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::data_feed::DataFeedConfig>> *data_feeds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::data_feed::DataFeedConfig>> *>(VT_DATA_FEEDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA_FEEDS) &&
           verifier.VerifyVector(data_feeds()) &&
           verifier.VerifyVectorOfTables(data_feeds()) &&
           verifier.EndTable();
  }
};

struct DataFeedRequestBuilder {
  typedef DataFeedRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_feeds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::data_feed::DataFeedConfig>>> data_feeds) {
    fbb_.AddOffset(DataFeedRequest::VT_DATA_FEEDS, data_feeds);
  }
  explicit DataFeedRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataFeedRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFeedRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFeedRequest> CreateDataFeedRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::data_feed::DataFeedConfig>>> data_feeds = 0) {
  DataFeedRequestBuilder builder_(_fbb);
  builder_.add_data_feeds(data_feeds);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataFeedRequest> CreateDataFeedRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<slimevr_protocol::data_feed::DataFeedConfig>> *data_feeds = nullptr) {
  auto data_feeds__ = data_feeds ? _fbb.CreateVector<flatbuffers::Offset<slimevr_protocol::data_feed::DataFeedConfig>>(*data_feeds) : 0;
  return slimevr_protocol::data_feed::CreateDataFeedRequest(
      _fbb,
      data_feeds__);
}

/// A single update of the `DeviceStatus` updates.
///
/// A data feed might send data only when it changes/updates, and we should make no
/// assumptions that the data is actually delivered. If you want to guarantee
/// delivery and avoid dropped observations of data (such as a user-initiated
/// button press), it is better to use the RPC system.
struct DataFeedUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataFeedUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICES = 4,
    VT_SYNTHETIC_TRACKERS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::data_feed::DeviceStatus>> *devices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::data_feed::DeviceStatus>> *>(VT_DEVICES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::datatypes::tracker::TrackerStatus>> *synthetic_trackers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::datatypes::tracker::TrackerStatus>> *>(VT_SYNTHETIC_TRACKERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICES) &&
           verifier.VerifyVector(devices()) &&
           verifier.VerifyVectorOfTables(devices()) &&
           VerifyOffset(verifier, VT_SYNTHETIC_TRACKERS) &&
           verifier.VerifyVector(synthetic_trackers()) &&
           verifier.VerifyVectorOfTables(synthetic_trackers()) &&
           verifier.EndTable();
  }
};

struct DataFeedUpdateBuilder {
  typedef DataFeedUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_devices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::data_feed::DeviceStatus>>> devices) {
    fbb_.AddOffset(DataFeedUpdate::VT_DEVICES, devices);
  }
  void add_synthetic_trackers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::datatypes::tracker::TrackerStatus>>> synthetic_trackers) {
    fbb_.AddOffset(DataFeedUpdate::VT_SYNTHETIC_TRACKERS, synthetic_trackers);
  }
  explicit DataFeedUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataFeedUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFeedUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFeedUpdate> CreateDataFeedUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::data_feed::DeviceStatus>>> devices = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::datatypes::tracker::TrackerStatus>>> synthetic_trackers = 0) {
  DataFeedUpdateBuilder builder_(_fbb);
  builder_.add_synthetic_trackers(synthetic_trackers);
  builder_.add_devices(devices);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataFeedUpdate> CreateDataFeedUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<slimevr_protocol::data_feed::DeviceStatus>> *devices = nullptr,
    const std::vector<flatbuffers::Offset<slimevr_protocol::datatypes::tracker::TrackerStatus>> *synthetic_trackers = nullptr) {
  auto devices__ = devices ? _fbb.CreateVector<flatbuffers::Offset<slimevr_protocol::data_feed::DeviceStatus>>(*devices) : 0;
  auto synthetic_trackers__ = synthetic_trackers ? _fbb.CreateVector<flatbuffers::Offset<slimevr_protocol::datatypes::tracker::TrackerStatus>>(*synthetic_trackers) : 0;
  return slimevr_protocol::data_feed::CreateDataFeedUpdate(
      _fbb,
      devices__,
      synthetic_trackers__);
}

/// All information related to the configuration of a data feed. This may be sent
/// as part of a `DataFeedRequest` or a `DataFeedNotify`.
struct DataFeedConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataFeedConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINIMUM_TIME_SINCE_LAST = 4,
    VT_DATA_MASK = 6,
    VT_SYNTHETIC_TRACKERS = 8
  };
  /// Minimum delay in milliseconds between new data updates. This value will be
  /// ignored when used for a `PollDataFeed`.
  uint16_t minimum_time_since_last() const {
    return GetField<uint16_t>(VT_MINIMUM_TIME_SINCE_LAST, 0);
  }
  const slimevr_protocol::data_feed::DeviceStatusMask *data_mask() const {
    return GetPointer<const slimevr_protocol::data_feed::DeviceStatusMask *>(VT_DATA_MASK);
  }
  bool synthetic_trackers() const {
    return GetField<uint8_t>(VT_SYNTHETIC_TRACKERS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MINIMUM_TIME_SINCE_LAST, 2) &&
           VerifyOffset(verifier, VT_DATA_MASK) &&
           verifier.VerifyTable(data_mask()) &&
           VerifyField<uint8_t>(verifier, VT_SYNTHETIC_TRACKERS, 1) &&
           verifier.EndTable();
  }
};

struct DataFeedConfigBuilder {
  typedef DataFeedConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minimum_time_since_last(uint16_t minimum_time_since_last) {
    fbb_.AddElement<uint16_t>(DataFeedConfig::VT_MINIMUM_TIME_SINCE_LAST, minimum_time_since_last, 0);
  }
  void add_data_mask(flatbuffers::Offset<slimevr_protocol::data_feed::DeviceStatusMask> data_mask) {
    fbb_.AddOffset(DataFeedConfig::VT_DATA_MASK, data_mask);
  }
  void add_synthetic_trackers(bool synthetic_trackers) {
    fbb_.AddElement<uint8_t>(DataFeedConfig::VT_SYNTHETIC_TRACKERS, static_cast<uint8_t>(synthetic_trackers), 0);
  }
  explicit DataFeedConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataFeedConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFeedConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFeedConfig> CreateDataFeedConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t minimum_time_since_last = 0,
    flatbuffers::Offset<slimevr_protocol::data_feed::DeviceStatusMask> data_mask = 0,
    bool synthetic_trackers = false) {
  DataFeedConfigBuilder builder_(_fbb);
  builder_.add_data_mask(data_mask);
  builder_.add_minimum_time_since_last(minimum_time_since_last);
  builder_.add_synthetic_trackers(synthetic_trackers);
  return builder_.Finish();
}

/// A mask of values to be reported in subsequent DeviceStatus. Values set to `false`
/// or `null` will not reported. By default, all fields are false/null.
///
/// If you set a value to `true`, it is not guaranteed that the sender actually has
/// such a value to send. In this case, they will probably send `null`, and the receiver
/// has the choice to disconnect due to missing data.
struct DeviceStatusMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceStatusMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CUSTOM_NAME = 4,
    VT_FIRMWARE_INFO = 6,
    VT_FIRMWARE_STATUS = 8,
    VT_TRACKER_STATUSES = 10
  };
  bool custom_name() const {
    return GetField<uint8_t>(VT_CUSTOM_NAME, 0) != 0;
  }
  const slimevr_protocol::datatypes::hardware_info::FirmwareInfoMask *firmware_info() const {
    return GetPointer<const slimevr_protocol::datatypes::hardware_info::FirmwareInfoMask *>(VT_FIRMWARE_INFO);
  }
  const slimevr_protocol::datatypes::hardware_info::FirmwareStatusMask *firmware_status() const {
    return GetPointer<const slimevr_protocol::datatypes::hardware_info::FirmwareStatusMask *>(VT_FIRMWARE_STATUS);
  }
  const slimevr_protocol::datatypes::tracker::TrackerStatusMask *tracker_statuses() const {
    return GetPointer<const slimevr_protocol::datatypes::tracker::TrackerStatusMask *>(VT_TRACKER_STATUSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CUSTOM_NAME, 1) &&
           VerifyOffset(verifier, VT_FIRMWARE_INFO) &&
           verifier.VerifyTable(firmware_info()) &&
           VerifyOffset(verifier, VT_FIRMWARE_STATUS) &&
           verifier.VerifyTable(firmware_status()) &&
           VerifyOffset(verifier, VT_TRACKER_STATUSES) &&
           verifier.VerifyTable(tracker_statuses()) &&
           verifier.EndTable();
  }
};

struct DeviceStatusMaskBuilder {
  typedef DeviceStatusMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_custom_name(bool custom_name) {
    fbb_.AddElement<uint8_t>(DeviceStatusMask::VT_CUSTOM_NAME, static_cast<uint8_t>(custom_name), 0);
  }
  void add_firmware_info(flatbuffers::Offset<slimevr_protocol::datatypes::hardware_info::FirmwareInfoMask> firmware_info) {
    fbb_.AddOffset(DeviceStatusMask::VT_FIRMWARE_INFO, firmware_info);
  }
  void add_firmware_status(flatbuffers::Offset<slimevr_protocol::datatypes::hardware_info::FirmwareStatusMask> firmware_status) {
    fbb_.AddOffset(DeviceStatusMask::VT_FIRMWARE_STATUS, firmware_status);
  }
  void add_tracker_statuses(flatbuffers::Offset<slimevr_protocol::datatypes::tracker::TrackerStatusMask> tracker_statuses) {
    fbb_.AddOffset(DeviceStatusMask::VT_TRACKER_STATUSES, tracker_statuses);
  }
  explicit DeviceStatusMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceStatusMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceStatusMask>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceStatusMask> CreateDeviceStatusMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool custom_name = false,
    flatbuffers::Offset<slimevr_protocol::datatypes::hardware_info::FirmwareInfoMask> firmware_info = 0,
    flatbuffers::Offset<slimevr_protocol::datatypes::hardware_info::FirmwareStatusMask> firmware_status = 0,
    flatbuffers::Offset<slimevr_protocol::datatypes::tracker::TrackerStatusMask> tracker_statuses = 0) {
  DeviceStatusMaskBuilder builder_(_fbb);
  builder_.add_tracker_statuses(tracker_statuses);
  builder_.add_firmware_status(firmware_status);
  builder_.add_firmware_info(firmware_info);
  builder_.add_custom_name(custom_name);
  return builder_.Finish();
}

/// All possible info related to a hardware device. For example a vive tracker is a
/// single hardware device, and a slime tracker with two extensions is a single hardware
/// device.
///
/// Each `DeviceStatus` contains data about one or more `TrackerStatus`es. For example,
/// a SlimeVR waist tracker with a chest extension has two `TrackerStatus`es, because
/// it is tracking information about two different parts of the body.
struct DeviceStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CUSTOM_NAME = 6,
    VT_FIRMWARE_INFO = 8,
    VT_FIRMWARE_STATUS = 10,
    VT_TRACKER_STATUSES = 12
  };
  /// A unique ID for the device. IDs are not guaranteed to be the same after
  /// the connection is terminated.
  uint8_t id() const {
    return GetField<uint8_t>(VT_ID, 0);
  }
  /// The dynamically changeable name of the device. This might be set by the
  /// user to help them remember which tracker is which.
  const flatbuffers::String *custom_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CUSTOM_NAME);
  }
  /// Mostly-static info about the device hardware
  const slimevr_protocol::datatypes::hardware_info::FirmwareInfo *firmware_info() const {
    return GetPointer<const slimevr_protocol::datatypes::hardware_info::FirmwareInfo *>(VT_FIRMWARE_INFO);
  }
  /// General info about the status of the device
  const slimevr_protocol::datatypes::hardware_info::FirmwareStatus *firmware_status() const {
    return GetPointer<const slimevr_protocol::datatypes::hardware_info::FirmwareStatus *>(VT_FIRMWARE_STATUS);
  }
  /// All the relevant information from the different trackers, in an order
  /// dictated by the conventions of the firmware running on the device
  const flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::datatypes::tracker::TrackerStatus>> *tracker_statuses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::datatypes::tracker::TrackerStatus>> *>(VT_TRACKER_STATUSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ID, 1) &&
           VerifyOffset(verifier, VT_CUSTOM_NAME) &&
           verifier.VerifyString(custom_name()) &&
           VerifyOffset(verifier, VT_FIRMWARE_INFO) &&
           verifier.VerifyTable(firmware_info()) &&
           VerifyOffset(verifier, VT_FIRMWARE_STATUS) &&
           verifier.VerifyTable(firmware_status()) &&
           VerifyOffset(verifier, VT_TRACKER_STATUSES) &&
           verifier.VerifyVector(tracker_statuses()) &&
           verifier.VerifyVectorOfTables(tracker_statuses()) &&
           verifier.EndTable();
  }
};

struct DeviceStatusBuilder {
  typedef DeviceStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint8_t id) {
    fbb_.AddElement<uint8_t>(DeviceStatus::VT_ID, id, 0);
  }
  void add_custom_name(flatbuffers::Offset<flatbuffers::String> custom_name) {
    fbb_.AddOffset(DeviceStatus::VT_CUSTOM_NAME, custom_name);
  }
  void add_firmware_info(flatbuffers::Offset<slimevr_protocol::datatypes::hardware_info::FirmwareInfo> firmware_info) {
    fbb_.AddOffset(DeviceStatus::VT_FIRMWARE_INFO, firmware_info);
  }
  void add_firmware_status(flatbuffers::Offset<slimevr_protocol::datatypes::hardware_info::FirmwareStatus> firmware_status) {
    fbb_.AddOffset(DeviceStatus::VT_FIRMWARE_STATUS, firmware_status);
  }
  void add_tracker_statuses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::datatypes::tracker::TrackerStatus>>> tracker_statuses) {
    fbb_.AddOffset(DeviceStatus::VT_TRACKER_STATUSES, tracker_statuses);
  }
  explicit DeviceStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceStatus> CreateDeviceStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t id = 0,
    flatbuffers::Offset<flatbuffers::String> custom_name = 0,
    flatbuffers::Offset<slimevr_protocol::datatypes::hardware_info::FirmwareInfo> firmware_info = 0,
    flatbuffers::Offset<slimevr_protocol::datatypes::hardware_info::FirmwareStatus> firmware_status = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<slimevr_protocol::datatypes::tracker::TrackerStatus>>> tracker_statuses = 0) {
  DeviceStatusBuilder builder_(_fbb);
  builder_.add_tracker_statuses(tracker_statuses);
  builder_.add_firmware_status(firmware_status);
  builder_.add_firmware_info(firmware_info);
  builder_.add_custom_name(custom_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceStatus> CreateDeviceStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t id = 0,
    const char *custom_name = nullptr,
    flatbuffers::Offset<slimevr_protocol::datatypes::hardware_info::FirmwareInfo> firmware_info = 0,
    flatbuffers::Offset<slimevr_protocol::datatypes::hardware_info::FirmwareStatus> firmware_status = 0,
    const std::vector<flatbuffers::Offset<slimevr_protocol::datatypes::tracker::TrackerStatus>> *tracker_statuses = nullptr) {
  auto custom_name__ = custom_name ? _fbb.CreateString(custom_name) : 0;
  auto tracker_statuses__ = tracker_statuses ? _fbb.CreateVector<flatbuffers::Offset<slimevr_protocol::datatypes::tracker::TrackerStatus>>(*tracker_statuses) : 0;
  return slimevr_protocol::data_feed::CreateDeviceStatus(
      _fbb,
      id,
      custom_name__,
      firmware_info,
      firmware_status,
      tracker_statuses__);
}

}  // namespace data_feed

namespace rpc {

/// Heartbeats should simply be acknowledged
struct HeartbeatRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeartbeatRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HeartbeatRequestBuilder {
  typedef HeartbeatRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HeartbeatRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HeartbeatRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeartbeatRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeartbeatRequest> CreateHeartbeatRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HeartbeatRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ResetRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResetRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QUICK = 4
  };
  bool quick() const {
    return GetField<uint8_t>(VT_QUICK, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_QUICK, 1) &&
           verifier.EndTable();
  }
};

struct ResetRequestBuilder {
  typedef ResetRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_quick(bool quick) {
    fbb_.AddElement<uint8_t>(ResetRequest::VT_QUICK, static_cast<uint8_t>(quick), 0);
  }
  explicit ResetRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResetRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResetRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResetRequest> CreateResetRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool quick = false) {
  ResetRequestBuilder builder_(_fbb);
  builder_.add_quick(quick);
  return builder_.Finish();
}

struct AssignTrackerRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssignTrackerRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ROLE = 6,
    VT_MOUNTING_ROTATION = 8
  };
  uint8_t id() const {
    return GetField<uint8_t>(VT_ID, 0);
  }
  slimevr_protocol::datatypes::TrackerRole role() const {
    return static_cast<slimevr_protocol::datatypes::TrackerRole>(GetField<uint8_t>(VT_ROLE, 0));
  }
  uint16_t mounting_rotation() const {
    return GetField<uint16_t>(VT_MOUNTING_ROTATION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_ROLE, 1) &&
           VerifyField<uint16_t>(verifier, VT_MOUNTING_ROTATION, 2) &&
           verifier.EndTable();
  }
};

struct AssignTrackerRequestBuilder {
  typedef AssignTrackerRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint8_t id) {
    fbb_.AddElement<uint8_t>(AssignTrackerRequest::VT_ID, id, 0);
  }
  void add_role(slimevr_protocol::datatypes::TrackerRole role) {
    fbb_.AddElement<uint8_t>(AssignTrackerRequest::VT_ROLE, static_cast<uint8_t>(role), 0);
  }
  void add_mounting_rotation(uint16_t mounting_rotation) {
    fbb_.AddElement<uint16_t>(AssignTrackerRequest::VT_MOUNTING_ROTATION, mounting_rotation, 0);
  }
  explicit AssignTrackerRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AssignTrackerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignTrackerRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignTrackerRequest> CreateAssignTrackerRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t id = 0,
    slimevr_protocol::datatypes::TrackerRole role = slimevr_protocol::datatypes::TrackerRole::NONE,
    uint16_t mounting_rotation = 0) {
  AssignTrackerRequestBuilder builder_(_fbb);
  builder_.add_mounting_rotation(mounting_rotation);
  builder_.add_role(role);
  builder_.add_id(id);
  return builder_.Finish();
}

struct SettingsRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SettingsRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SettingsRequestBuilder {
  typedef SettingsRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SettingsRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SettingsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SettingsRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SettingsRequest> CreateSettingsRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SettingsRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SettingsResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SettingsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEAM_VR_TRACKERS = 4,
    VT_FILTERING = 6
  };
  const slimevr_protocol::rpc::SteamVRTrackersSetting *steam_vr_trackers() const {
    return GetPointer<const slimevr_protocol::rpc::SteamVRTrackersSetting *>(VT_STEAM_VR_TRACKERS);
  }
  const slimevr_protocol::rpc::FilteringSettings *filtering() const {
    return GetPointer<const slimevr_protocol::rpc::FilteringSettings *>(VT_FILTERING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STEAM_VR_TRACKERS) &&
           verifier.VerifyTable(steam_vr_trackers()) &&
           VerifyOffset(verifier, VT_FILTERING) &&
           verifier.VerifyTable(filtering()) &&
           verifier.EndTable();
  }
};

struct SettingsResponseBuilder {
  typedef SettingsResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_steam_vr_trackers(flatbuffers::Offset<slimevr_protocol::rpc::SteamVRTrackersSetting> steam_vr_trackers) {
    fbb_.AddOffset(SettingsResponse::VT_STEAM_VR_TRACKERS, steam_vr_trackers);
  }
  void add_filtering(flatbuffers::Offset<slimevr_protocol::rpc::FilteringSettings> filtering) {
    fbb_.AddOffset(SettingsResponse::VT_FILTERING, filtering);
  }
  explicit SettingsResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SettingsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SettingsResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SettingsResponse> CreateSettingsResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<slimevr_protocol::rpc::SteamVRTrackersSetting> steam_vr_trackers = 0,
    flatbuffers::Offset<slimevr_protocol::rpc::FilteringSettings> filtering = 0) {
  SettingsResponseBuilder builder_(_fbb);
  builder_.add_filtering(filtering);
  builder_.add_steam_vr_trackers(steam_vr_trackers);
  return builder_.Finish();
}

struct ChangeSettingsRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChangeSettingsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEAM_VR_TRACKERS = 4,
    VT_FILTERING = 6
  };
  const slimevr_protocol::rpc::SteamVRTrackersSetting *steam_vr_trackers() const {
    return GetPointer<const slimevr_protocol::rpc::SteamVRTrackersSetting *>(VT_STEAM_VR_TRACKERS);
  }
  const slimevr_protocol::rpc::FilteringSettings *filtering() const {
    return GetPointer<const slimevr_protocol::rpc::FilteringSettings *>(VT_FILTERING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STEAM_VR_TRACKERS) &&
           verifier.VerifyTable(steam_vr_trackers()) &&
           VerifyOffset(verifier, VT_FILTERING) &&
           verifier.VerifyTable(filtering()) &&
           verifier.EndTable();
  }
};

struct ChangeSettingsRequestBuilder {
  typedef ChangeSettingsRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_steam_vr_trackers(flatbuffers::Offset<slimevr_protocol::rpc::SteamVRTrackersSetting> steam_vr_trackers) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_STEAM_VR_TRACKERS, steam_vr_trackers);
  }
  void add_filtering(flatbuffers::Offset<slimevr_protocol::rpc::FilteringSettings> filtering) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_FILTERING, filtering);
  }
  explicit ChangeSettingsRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ChangeSettingsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangeSettingsRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangeSettingsRequest> CreateChangeSettingsRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<slimevr_protocol::rpc::SteamVRTrackersSetting> steam_vr_trackers = 0,
    flatbuffers::Offset<slimevr_protocol::rpc::FilteringSettings> filtering = 0) {
  ChangeSettingsRequestBuilder builder_(_fbb);
  builder_.add_filtering(filtering);
  builder_.add_steam_vr_trackers(steam_vr_trackers);
  return builder_.Finish();
}

struct SteamVRTrackersSetting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SteamVRTrackersSettingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WAIST = 4,
    VT_CHEST = 6,
    VT_LEGS = 8,
    VT_KNEES = 10,
    VT_ELBOWS = 12
  };
  bool waist() const {
    return GetField<uint8_t>(VT_WAIST, 0) != 0;
  }
  bool chest() const {
    return GetField<uint8_t>(VT_CHEST, 0) != 0;
  }
  bool legs() const {
    return GetField<uint8_t>(VT_LEGS, 0) != 0;
  }
  bool knees() const {
    return GetField<uint8_t>(VT_KNEES, 0) != 0;
  }
  bool elbows() const {
    return GetField<uint8_t>(VT_ELBOWS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_WAIST, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHEST, 1) &&
           VerifyField<uint8_t>(verifier, VT_LEGS, 1) &&
           VerifyField<uint8_t>(verifier, VT_KNEES, 1) &&
           VerifyField<uint8_t>(verifier, VT_ELBOWS, 1) &&
           verifier.EndTable();
  }
};

struct SteamVRTrackersSettingBuilder {
  typedef SteamVRTrackersSetting Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_waist(bool waist) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_WAIST, static_cast<uint8_t>(waist), 0);
  }
  void add_chest(bool chest) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_CHEST, static_cast<uint8_t>(chest), 0);
  }
  void add_legs(bool legs) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_LEGS, static_cast<uint8_t>(legs), 0);
  }
  void add_knees(bool knees) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_KNEES, static_cast<uint8_t>(knees), 0);
  }
  void add_elbows(bool elbows) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_ELBOWS, static_cast<uint8_t>(elbows), 0);
  }
  explicit SteamVRTrackersSettingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SteamVRTrackersSetting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SteamVRTrackersSetting>(end);
    return o;
  }
};

inline flatbuffers::Offset<SteamVRTrackersSetting> CreateSteamVRTrackersSetting(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool waist = false,
    bool chest = false,
    bool legs = false,
    bool knees = false,
    bool elbows = false) {
  SteamVRTrackersSettingBuilder builder_(_fbb);
  builder_.add_elbows(elbows);
  builder_.add_knees(knees);
  builder_.add_legs(legs);
  builder_.add_chest(chest);
  builder_.add_waist(waist);
  return builder_.Finish();
}

struct FilteringSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FilteringSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_INTENSITY = 6,
    VT_TICKS = 8
  };
  slimevr_protocol::datatypes::FilteringType type() const {
    return static_cast<slimevr_protocol::datatypes::FilteringType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  uint8_t intensity() const {
    return GetField<uint8_t>(VT_INTENSITY, 0);
  }
  uint8_t ticks() const {
    return GetField<uint8_t>(VT_TICKS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_INTENSITY, 1) &&
           VerifyField<uint8_t>(verifier, VT_TICKS, 1) &&
           verifier.EndTable();
  }
};

struct FilteringSettingsBuilder {
  typedef FilteringSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(slimevr_protocol::datatypes::FilteringType type) {
    fbb_.AddElement<uint8_t>(FilteringSettings::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_intensity(uint8_t intensity) {
    fbb_.AddElement<uint8_t>(FilteringSettings::VT_INTENSITY, intensity, 0);
  }
  void add_ticks(uint8_t ticks) {
    fbb_.AddElement<uint8_t>(FilteringSettings::VT_TICKS, ticks, 0);
  }
  explicit FilteringSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FilteringSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FilteringSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<FilteringSettings> CreateFilteringSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    slimevr_protocol::datatypes::FilteringType type = slimevr_protocol::datatypes::FilteringType::NONE,
    uint8_t intensity = 0,
    uint8_t ticks = 0) {
  FilteringSettingsBuilder builder_(_fbb);
  builder_.add_ticks(ticks);
  builder_.add_intensity(intensity);
  builder_.add_type(type);
  return builder_.Finish();
}

}  // namespace rpc

struct InboundPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InboundPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACKNOWLEDGE_ME = 4,
    VT_PACKET_TYPE = 6,
    VT_PACKET = 8
  };
  bool acknowledge_me() const {
    return GetField<uint8_t>(VT_ACKNOWLEDGE_ME, 0) != 0;
  }
  slimevr_protocol::InboundUnion packet_type() const {
    return static_cast<slimevr_protocol::InboundUnion>(GetField<uint8_t>(VT_PACKET_TYPE, 0));
  }
  const void *packet() const {
    return GetPointer<const void *>(VT_PACKET);
  }
  template<typename T> const T *packet_as() const;
  const slimevr_protocol::rpc::HeartbeatRequest *packet_as_slimevr_protocol_rpc_HeartbeatRequest() const {
    return packet_type() == slimevr_protocol::InboundUnion::slimevr_protocol_rpc_HeartbeatRequest ? static_cast<const slimevr_protocol::rpc::HeartbeatRequest *>(packet()) : nullptr;
  }
  const slimevr_protocol::rpc::ResetRequest *packet_as_slimevr_protocol_rpc_ResetRequest() const {
    return packet_type() == slimevr_protocol::InboundUnion::slimevr_protocol_rpc_ResetRequest ? static_cast<const slimevr_protocol::rpc::ResetRequest *>(packet()) : nullptr;
  }
  const slimevr_protocol::rpc::AssignTrackerRequest *packet_as_slimevr_protocol_rpc_AssignTrackerRequest() const {
    return packet_type() == slimevr_protocol::InboundUnion::slimevr_protocol_rpc_AssignTrackerRequest ? static_cast<const slimevr_protocol::rpc::AssignTrackerRequest *>(packet()) : nullptr;
  }
  const slimevr_protocol::rpc::SettingsRequest *packet_as_slimevr_protocol_rpc_SettingsRequest() const {
    return packet_type() == slimevr_protocol::InboundUnion::slimevr_protocol_rpc_SettingsRequest ? static_cast<const slimevr_protocol::rpc::SettingsRequest *>(packet()) : nullptr;
  }
  const slimevr_protocol::rpc::ChangeSettingsRequest *packet_as_slimevr_protocol_rpc_ChangeSettingsRequest() const {
    return packet_type() == slimevr_protocol::InboundUnion::slimevr_protocol_rpc_ChangeSettingsRequest ? static_cast<const slimevr_protocol::rpc::ChangeSettingsRequest *>(packet()) : nullptr;
  }
  const slimevr_protocol::data_feed::PollDataFeed *packet_as_slimevr_protocol_data_feed_PollDataFeed() const {
    return packet_type() == slimevr_protocol::InboundUnion::slimevr_protocol_data_feed_PollDataFeed ? static_cast<const slimevr_protocol::data_feed::PollDataFeed *>(packet()) : nullptr;
  }
  const slimevr_protocol::data_feed::DataFeedRequest *packet_as_slimevr_protocol_data_feed_DataFeedRequest() const {
    return packet_type() == slimevr_protocol::InboundUnion::slimevr_protocol_data_feed_DataFeedRequest ? static_cast<const slimevr_protocol::data_feed::DataFeedRequest *>(packet()) : nullptr;
  }
  const slimevr_protocol::data_feed::DataFeedUpdate *packet_as_slimevr_protocol_data_feed_DataFeedUpdate() const {
    return packet_type() == slimevr_protocol::InboundUnion::slimevr_protocol_data_feed_DataFeedUpdate ? static_cast<const slimevr_protocol::data_feed::DataFeedUpdate *>(packet()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACKNOWLEDGE_ME, 1) &&
           VerifyField<uint8_t>(verifier, VT_PACKET_TYPE, 1) &&
           VerifyOffset(verifier, VT_PACKET) &&
           VerifyInboundUnion(verifier, packet(), packet_type()) &&
           verifier.EndTable();
  }
};

template<> inline const slimevr_protocol::rpc::HeartbeatRequest *InboundPacket::packet_as<slimevr_protocol::rpc::HeartbeatRequest>() const {
  return packet_as_slimevr_protocol_rpc_HeartbeatRequest();
}

template<> inline const slimevr_protocol::rpc::ResetRequest *InboundPacket::packet_as<slimevr_protocol::rpc::ResetRequest>() const {
  return packet_as_slimevr_protocol_rpc_ResetRequest();
}

template<> inline const slimevr_protocol::rpc::AssignTrackerRequest *InboundPacket::packet_as<slimevr_protocol::rpc::AssignTrackerRequest>() const {
  return packet_as_slimevr_protocol_rpc_AssignTrackerRequest();
}

template<> inline const slimevr_protocol::rpc::SettingsRequest *InboundPacket::packet_as<slimevr_protocol::rpc::SettingsRequest>() const {
  return packet_as_slimevr_protocol_rpc_SettingsRequest();
}

template<> inline const slimevr_protocol::rpc::ChangeSettingsRequest *InboundPacket::packet_as<slimevr_protocol::rpc::ChangeSettingsRequest>() const {
  return packet_as_slimevr_protocol_rpc_ChangeSettingsRequest();
}

template<> inline const slimevr_protocol::data_feed::PollDataFeed *InboundPacket::packet_as<slimevr_protocol::data_feed::PollDataFeed>() const {
  return packet_as_slimevr_protocol_data_feed_PollDataFeed();
}

template<> inline const slimevr_protocol::data_feed::DataFeedRequest *InboundPacket::packet_as<slimevr_protocol::data_feed::DataFeedRequest>() const {
  return packet_as_slimevr_protocol_data_feed_DataFeedRequest();
}

template<> inline const slimevr_protocol::data_feed::DataFeedUpdate *InboundPacket::packet_as<slimevr_protocol::data_feed::DataFeedUpdate>() const {
  return packet_as_slimevr_protocol_data_feed_DataFeedUpdate();
}

struct InboundPacketBuilder {
  typedef InboundPacket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acknowledge_me(bool acknowledge_me) {
    fbb_.AddElement<uint8_t>(InboundPacket::VT_ACKNOWLEDGE_ME, static_cast<uint8_t>(acknowledge_me), 0);
  }
  void add_packet_type(slimevr_protocol::InboundUnion packet_type) {
    fbb_.AddElement<uint8_t>(InboundPacket::VT_PACKET_TYPE, static_cast<uint8_t>(packet_type), 0);
  }
  void add_packet(flatbuffers::Offset<void> packet) {
    fbb_.AddOffset(InboundPacket::VT_PACKET, packet);
  }
  explicit InboundPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InboundPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InboundPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<InboundPacket> CreateInboundPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool acknowledge_me = false,
    slimevr_protocol::InboundUnion packet_type = slimevr_protocol::InboundUnion::NONE,
    flatbuffers::Offset<void> packet = 0) {
  InboundPacketBuilder builder_(_fbb);
  builder_.add_packet(packet);
  builder_.add_packet_type(packet_type);
  builder_.add_acknowledge_me(acknowledge_me);
  return builder_.Finish();
}

struct OutboundPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OutboundPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACKNOWLEDGE_ME = 4,
    VT_PACKET_TYPE = 6,
    VT_PACKET = 8
  };
  bool acknowledge_me() const {
    return GetField<uint8_t>(VT_ACKNOWLEDGE_ME, 0) != 0;
  }
  slimevr_protocol::OutboundUnion packet_type() const {
    return static_cast<slimevr_protocol::OutboundUnion>(GetField<uint8_t>(VT_PACKET_TYPE, 0));
  }
  const void *packet() const {
    return GetPointer<const void *>(VT_PACKET);
  }
  template<typename T> const T *packet_as() const;
  const slimevr_protocol::rpc::HeartbeatRequest *packet_as_slimevr_protocol_rpc_HeartbeatRequest() const {
    return packet_type() == slimevr_protocol::OutboundUnion::slimevr_protocol_rpc_HeartbeatRequest ? static_cast<const slimevr_protocol::rpc::HeartbeatRequest *>(packet()) : nullptr;
  }
  const slimevr_protocol::rpc::SettingsResponse *packet_as_slimevr_protocol_rpc_SettingsResponse() const {
    return packet_type() == slimevr_protocol::OutboundUnion::slimevr_protocol_rpc_SettingsResponse ? static_cast<const slimevr_protocol::rpc::SettingsResponse *>(packet()) : nullptr;
  }
  const slimevr_protocol::data_feed::PollDataFeed *packet_as_slimevr_protocol_data_feed_PollDataFeed() const {
    return packet_type() == slimevr_protocol::OutboundUnion::slimevr_protocol_data_feed_PollDataFeed ? static_cast<const slimevr_protocol::data_feed::PollDataFeed *>(packet()) : nullptr;
  }
  const slimevr_protocol::data_feed::DataFeedRequest *packet_as_slimevr_protocol_data_feed_DataFeedRequest() const {
    return packet_type() == slimevr_protocol::OutboundUnion::slimevr_protocol_data_feed_DataFeedRequest ? static_cast<const slimevr_protocol::data_feed::DataFeedRequest *>(packet()) : nullptr;
  }
  const slimevr_protocol::data_feed::DataFeedUpdate *packet_as_slimevr_protocol_data_feed_DataFeedUpdate() const {
    return packet_type() == slimevr_protocol::OutboundUnion::slimevr_protocol_data_feed_DataFeedUpdate ? static_cast<const slimevr_protocol::data_feed::DataFeedUpdate *>(packet()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACKNOWLEDGE_ME, 1) &&
           VerifyField<uint8_t>(verifier, VT_PACKET_TYPE, 1) &&
           VerifyOffset(verifier, VT_PACKET) &&
           VerifyOutboundUnion(verifier, packet(), packet_type()) &&
           verifier.EndTable();
  }
};

template<> inline const slimevr_protocol::rpc::HeartbeatRequest *OutboundPacket::packet_as<slimevr_protocol::rpc::HeartbeatRequest>() const {
  return packet_as_slimevr_protocol_rpc_HeartbeatRequest();
}

template<> inline const slimevr_protocol::rpc::SettingsResponse *OutboundPacket::packet_as<slimevr_protocol::rpc::SettingsResponse>() const {
  return packet_as_slimevr_protocol_rpc_SettingsResponse();
}

template<> inline const slimevr_protocol::data_feed::PollDataFeed *OutboundPacket::packet_as<slimevr_protocol::data_feed::PollDataFeed>() const {
  return packet_as_slimevr_protocol_data_feed_PollDataFeed();
}

template<> inline const slimevr_protocol::data_feed::DataFeedRequest *OutboundPacket::packet_as<slimevr_protocol::data_feed::DataFeedRequest>() const {
  return packet_as_slimevr_protocol_data_feed_DataFeedRequest();
}

template<> inline const slimevr_protocol::data_feed::DataFeedUpdate *OutboundPacket::packet_as<slimevr_protocol::data_feed::DataFeedUpdate>() const {
  return packet_as_slimevr_protocol_data_feed_DataFeedUpdate();
}

struct OutboundPacketBuilder {
  typedef OutboundPacket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acknowledge_me(bool acknowledge_me) {
    fbb_.AddElement<uint8_t>(OutboundPacket::VT_ACKNOWLEDGE_ME, static_cast<uint8_t>(acknowledge_me), 0);
  }
  void add_packet_type(slimevr_protocol::OutboundUnion packet_type) {
    fbb_.AddElement<uint8_t>(OutboundPacket::VT_PACKET_TYPE, static_cast<uint8_t>(packet_type), 0);
  }
  void add_packet(flatbuffers::Offset<void> packet) {
    fbb_.AddOffset(OutboundPacket::VT_PACKET, packet);
  }
  explicit OutboundPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OutboundPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OutboundPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<OutboundPacket> CreateOutboundPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool acknowledge_me = false,
    slimevr_protocol::OutboundUnion packet_type = slimevr_protocol::OutboundUnion::NONE,
    flatbuffers::Offset<void> packet = 0) {
  OutboundPacketBuilder builder_(_fbb);
  builder_.add_packet(packet);
  builder_.add_packet_type(packet_type);
  builder_.add_acknowledge_me(acknowledge_me);
  return builder_.Finish();
}

namespace datatypes {

namespace hardware_info {

}  // namespace hardware_info

namespace tracker {

}  // namespace tracker
}  // namespace datatypes

namespace data_feed {

}  // namespace data_feed

namespace rpc {

}  // namespace rpc

inline bool VerifyInboundUnion(flatbuffers::Verifier &verifier, const void *obj, InboundUnion type) {
  switch (type) {
    case InboundUnion::NONE: {
      return true;
    }
    case InboundUnion::slimevr_protocol_rpc_HeartbeatRequest: {
      auto ptr = reinterpret_cast<const slimevr_protocol::rpc::HeartbeatRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InboundUnion::slimevr_protocol_rpc_ResetRequest: {
      auto ptr = reinterpret_cast<const slimevr_protocol::rpc::ResetRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InboundUnion::slimevr_protocol_rpc_AssignTrackerRequest: {
      auto ptr = reinterpret_cast<const slimevr_protocol::rpc::AssignTrackerRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InboundUnion::slimevr_protocol_rpc_SettingsRequest: {
      auto ptr = reinterpret_cast<const slimevr_protocol::rpc::SettingsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InboundUnion::slimevr_protocol_rpc_ChangeSettingsRequest: {
      auto ptr = reinterpret_cast<const slimevr_protocol::rpc::ChangeSettingsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InboundUnion::slimevr_protocol_data_feed_PollDataFeed: {
      auto ptr = reinterpret_cast<const slimevr_protocol::data_feed::PollDataFeed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InboundUnion::slimevr_protocol_data_feed_DataFeedRequest: {
      auto ptr = reinterpret_cast<const slimevr_protocol::data_feed::DataFeedRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InboundUnion::slimevr_protocol_data_feed_DataFeedUpdate: {
      auto ptr = reinterpret_cast<const slimevr_protocol::data_feed::DataFeedUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyInboundUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<InboundUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyInboundUnion(
        verifier,  values->Get(i), types->GetEnum<InboundUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyOutboundUnion(flatbuffers::Verifier &verifier, const void *obj, OutboundUnion type) {
  switch (type) {
    case OutboundUnion::NONE: {
      return true;
    }
    case OutboundUnion::slimevr_protocol_rpc_HeartbeatRequest: {
      auto ptr = reinterpret_cast<const slimevr_protocol::rpc::HeartbeatRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OutboundUnion::slimevr_protocol_rpc_SettingsResponse: {
      auto ptr = reinterpret_cast<const slimevr_protocol::rpc::SettingsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OutboundUnion::slimevr_protocol_data_feed_PollDataFeed: {
      auto ptr = reinterpret_cast<const slimevr_protocol::data_feed::PollDataFeed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OutboundUnion::slimevr_protocol_data_feed_DataFeedRequest: {
      auto ptr = reinterpret_cast<const slimevr_protocol::data_feed::DataFeedRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OutboundUnion::slimevr_protocol_data_feed_DataFeedUpdate: {
      auto ptr = reinterpret_cast<const slimevr_protocol::data_feed::DataFeedUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOutboundUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<OutboundUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOutboundUnion(
        verifier,  values->Get(i), types->GetEnum<OutboundUnion>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace slimevr_protocol

#endif  // FLATBUFFERS_GENERATED_ALL_SLIMEVR_PROTOCOL_H_
