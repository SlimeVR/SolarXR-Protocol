// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ALL_SOLARXR_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_ALL_SOLARXR_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

namespace solarxr_protocol {
namespace datatypes {

struct HzF32;

struct TransactionId;

struct DeviceId;

struct TrackerId;
struct TrackerIdBuilder;

struct LogData;
struct LogDataBuilder;

struct Temperature;

namespace hardware_info {

struct HardwareAddress;

struct HardwareInfo;
struct HardwareInfoBuilder;

struct HardwareStatus;
struct HardwareStatusBuilder;

struct FirmwareStatusMask;
struct FirmwareStatusMaskBuilder;

}  // namespace hardware_info

namespace math {

struct Quat;

struct Vec3f;

}  // namespace math
}  // namespace datatypes

namespace data_feed {
namespace tracker {

struct TrackerData;
struct TrackerDataBuilder;

struct TrackerDataMask;
struct TrackerDataMaskBuilder;

struct TrackerInfo;
struct TrackerInfoBuilder;

}  // namespace tracker

namespace device_data {

struct DeviceDataMask;
struct DeviceDataMaskBuilder;

struct DeviceData;
struct DeviceDataBuilder;

}  // namespace device_data

struct Bone;
struct BoneBuilder;

struct DataFeedMessageHeader;
struct DataFeedMessageHeaderBuilder;

struct PollDataFeed;
struct PollDataFeedBuilder;

struct StartDataFeed;
struct StartDataFeedBuilder;

struct DataFeedUpdate;
struct DataFeedUpdateBuilder;

struct DataFeedConfig;
struct DataFeedConfigBuilder;

}  // namespace data_feed

namespace rpc {
namespace settings {

struct ModelToggles;
struct ModelTogglesBuilder;

struct ModelRatios;
struct ModelRatiosBuilder;

struct ModelSettings;
struct ModelSettingsBuilder;

}  // namespace settings

struct RpcMessageHeader;
struct RpcMessageHeaderBuilder;

struct HeartbeatRequest;
struct HeartbeatRequestBuilder;

struct HeartbeatResponse;
struct HeartbeatResponseBuilder;

struct ResetRequest;
struct ResetRequestBuilder;

struct ResetResponse;
struct ResetResponseBuilder;

struct AssignTrackerRequest;
struct AssignTrackerRequestBuilder;

struct SettingsRequest;
struct SettingsRequestBuilder;

struct SettingsResponse;
struct SettingsResponseBuilder;

struct ChangeSettingsRequest;
struct ChangeSettingsRequestBuilder;

struct SteamVRTrackersSetting;
struct SteamVRTrackersSettingBuilder;

struct FilteringSettings;
struct FilteringSettingsBuilder;

struct RecordBVHRequest;
struct RecordBVHRequestBuilder;

struct RecordBVHStatus;
struct RecordBVHStatusBuilder;

struct SkeletonPart;
struct SkeletonPartBuilder;

struct SkeletonConfigRequest;
struct SkeletonConfigRequestBuilder;

struct SkeletonConfigResponse;
struct SkeletonConfigResponseBuilder;

struct SkeletonResetAllRequest;
struct SkeletonResetAllRequestBuilder;

struct ChangeSkeletonConfigRequest;
struct ChangeSkeletonConfigRequestBuilder;

struct OpenSerialRequest;
struct OpenSerialRequestBuilder;

struct CloseSerialRequest;
struct CloseSerialRequestBuilder;

struct SetWifiRequest;
struct SetWifiRequestBuilder;

struct SerialUpdateResponse;
struct SerialUpdateResponseBuilder;

struct AutoBoneProcessRequest;
struct AutoBoneProcessRequestBuilder;

struct AutoBoneProcessStatusResponse;
struct AutoBoneProcessStatusResponseBuilder;

struct AutoBoneEpochResponse;
struct AutoBoneEpochResponseBuilder;

struct OverlayDisplayModeRequest;
struct OverlayDisplayModeRequestBuilder;

struct OverlayDisplayModeChangeRequest;
struct OverlayDisplayModeChangeRequestBuilder;

struct OverlayDisplayModeResponse;
struct OverlayDisplayModeResponseBuilder;

}  // namespace rpc

struct MessageBundle;
struct MessageBundleBuilder;

namespace datatypes {

/// A list of error codes for error conditions on the device
enum class FirmwareErrorCode : uint8_t {
  Other = 0,
  Disconnected = 1,
  Occluded = 2,
  ImuError = 3,
  MIN = Other,
  MAX = ImuError
};

inline const FirmwareErrorCode (&EnumValuesFirmwareErrorCode())[4] {
  static const FirmwareErrorCode values[] = {
    FirmwareErrorCode::Other,
    FirmwareErrorCode::Disconnected,
    FirmwareErrorCode::Occluded,
    FirmwareErrorCode::ImuError
  };
  return values;
}

inline const char * const *EnumNamesFirmwareErrorCode() {
  static const char * const names[5] = {
    "Other",
    "Disconnected",
    "Occluded",
    "ImuError",
    nullptr
  };
  return names;
}

inline const char *EnumNameFirmwareErrorCode(FirmwareErrorCode e) {
  if (flatbuffers::IsOutRange(e, FirmwareErrorCode::Other, FirmwareErrorCode::ImuError)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFirmwareErrorCode()[index];
}

/// Used for filtering tracker rotations in software
enum class FilteringType : uint8_t {
  NONE = 0,
  INTERPOLATION = 1,
  EXTRAPOLATION = 2,
  MIN = NONE,
  MAX = EXTRAPOLATION
};

inline const FilteringType (&EnumValuesFilteringType())[3] {
  static const FilteringType values[] = {
    FilteringType::NONE,
    FilteringType::INTERPOLATION,
    FilteringType::EXTRAPOLATION
  };
  return values;
}

inline const char * const *EnumNamesFilteringType() {
  static const char * const names[4] = {
    "NONE",
    "INTERPOLATION",
    "EXTRAPOLATION",
    nullptr
  };
  return names;
}

inline const char *EnumNameFilteringType(FilteringType e) {
  if (flatbuffers::IsOutRange(e, FilteringType::NONE, FilteringType::EXTRAPOLATION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFilteringType()[index];
}

/// Possible tracker roles
/// They're not perfect match for SteamVR tracker roles,
/// because we support more possible roles. Host can
/// chose how to map it to their supported role.
enum class TrackerRole : uint8_t {
  NONE = 0,
  WAIST = 1,
  LEFT_FOOT = 2,
  RIGHT_FOOT = 3,
  CHEST = 4,
  LEFT_KNEE = 5,
  RIGHT_KNEE = 6,
  LEFT_ELBOW = 7,
  RIGHT_ELBOW = 8,
  LEFT_SHOULDER = 9,
  RIGHT_SHOULDER = 10,
  LEFT_HAND = 11,
  RIGHT_HAND = 12,
  LEFT_CONTROLLER = 13,
  RIGHT_CONTROLLER = 14,
  HEAD = 15,
  NECK = 16,
  CAMERA = 17,
  KEYBOARD = 18,
  HMD = 19,
  BEACON = 20,
  GENERIC_CONTROLLER = 21,
  MIN = NONE,
  MAX = GENERIC_CONTROLLER
};

inline const TrackerRole (&EnumValuesTrackerRole())[22] {
  static const TrackerRole values[] = {
    TrackerRole::NONE,
    TrackerRole::WAIST,
    TrackerRole::LEFT_FOOT,
    TrackerRole::RIGHT_FOOT,
    TrackerRole::CHEST,
    TrackerRole::LEFT_KNEE,
    TrackerRole::RIGHT_KNEE,
    TrackerRole::LEFT_ELBOW,
    TrackerRole::RIGHT_ELBOW,
    TrackerRole::LEFT_SHOULDER,
    TrackerRole::RIGHT_SHOULDER,
    TrackerRole::LEFT_HAND,
    TrackerRole::RIGHT_HAND,
    TrackerRole::LEFT_CONTROLLER,
    TrackerRole::RIGHT_CONTROLLER,
    TrackerRole::HEAD,
    TrackerRole::NECK,
    TrackerRole::CAMERA,
    TrackerRole::KEYBOARD,
    TrackerRole::HMD,
    TrackerRole::BEACON,
    TrackerRole::GENERIC_CONTROLLER
  };
  return values;
}

inline const char * const *EnumNamesTrackerRole() {
  static const char * const names[23] = {
    "NONE",
    "WAIST",
    "LEFT_FOOT",
    "RIGHT_FOOT",
    "CHEST",
    "LEFT_KNEE",
    "RIGHT_KNEE",
    "LEFT_ELBOW",
    "RIGHT_ELBOW",
    "LEFT_SHOULDER",
    "RIGHT_SHOULDER",
    "LEFT_HAND",
    "RIGHT_HAND",
    "LEFT_CONTROLLER",
    "RIGHT_CONTROLLER",
    "HEAD",
    "NECK",
    "CAMERA",
    "KEYBOARD",
    "HMD",
    "BEACON",
    "GENERIC_CONTROLLER",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrackerRole(TrackerRole e) {
  if (flatbuffers::IsOutRange(e, TrackerRole::NONE, TrackerRole::GENERIC_CONTROLLER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrackerRole()[index];
}

/// Different parts of the body. Roughly maps to each possible bone in the skeleton.
/// These are *NOT* the trackers.
enum class BodyPart : uint8_t {
  NONE = 0,
  HEAD = 1,
  NECK = 2,
  CHEST = 3,
  WAIST = 4,
  HIP = 5,
  LEFT_UPPER_LEG = 6,
  RIGHT_UPPER_LEG = 7,
  LEFT_LOWER_LEG = 8,
  RIGHT_LOWER_LEG = 9,
  LEFT_FOOT = 10,
  RIGHT_FOOT = 11,
  LEFT_CONTROLLER = 12,
  RIGHT_CONTROLLER = 13,
  LEFT_LOWER_ARM = 14,
  RIGHT_LOWER_ARM = 15,
  LEFT_UPPER_ARM = 16,
  RIGHT_UPPER_ARM = 17,
  LEFT_HAND = 18,
  RIGHT_HAND = 19,
  LEFT_SHOULDER = 20,
  RIGHT_SHOULDER = 21,
  MIN = NONE,
  MAX = RIGHT_SHOULDER
};

inline const BodyPart (&EnumValuesBodyPart())[22] {
  static const BodyPart values[] = {
    BodyPart::NONE,
    BodyPart::HEAD,
    BodyPart::NECK,
    BodyPart::CHEST,
    BodyPart::WAIST,
    BodyPart::HIP,
    BodyPart::LEFT_UPPER_LEG,
    BodyPart::RIGHT_UPPER_LEG,
    BodyPart::LEFT_LOWER_LEG,
    BodyPart::RIGHT_LOWER_LEG,
    BodyPart::LEFT_FOOT,
    BodyPart::RIGHT_FOOT,
    BodyPart::LEFT_CONTROLLER,
    BodyPart::RIGHT_CONTROLLER,
    BodyPart::LEFT_LOWER_ARM,
    BodyPart::RIGHT_LOWER_ARM,
    BodyPart::LEFT_UPPER_ARM,
    BodyPart::RIGHT_UPPER_ARM,
    BodyPart::LEFT_HAND,
    BodyPart::RIGHT_HAND,
    BodyPart::LEFT_SHOULDER,
    BodyPart::RIGHT_SHOULDER
  };
  return values;
}

inline const char * const *EnumNamesBodyPart() {
  static const char * const names[23] = {
    "NONE",
    "HEAD",
    "NECK",
    "CHEST",
    "WAIST",
    "HIP",
    "LEFT_UPPER_LEG",
    "RIGHT_UPPER_LEG",
    "LEFT_LOWER_LEG",
    "RIGHT_LOWER_LEG",
    "LEFT_FOOT",
    "RIGHT_FOOT",
    "LEFT_CONTROLLER",
    "RIGHT_CONTROLLER",
    "LEFT_LOWER_ARM",
    "RIGHT_LOWER_ARM",
    "LEFT_UPPER_ARM",
    "RIGHT_UPPER_ARM",
    "LEFT_HAND",
    "RIGHT_HAND",
    "LEFT_SHOULDER",
    "RIGHT_SHOULDER",
    nullptr
  };
  return names;
}

inline const char *EnumNameBodyPart(BodyPart e) {
  if (flatbuffers::IsOutRange(e, BodyPart::NONE, BodyPart::RIGHT_SHOULDER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBodyPart()[index];
}

enum class TrackerStatus : uint8_t {
  NONE = 0,
  DISCONNECTED = 1,
  OK = 2,
  BUSY = 3,
  ERROR = 4,
  OCCLUDED = 5,
  MIN = NONE,
  MAX = OCCLUDED
};

inline const TrackerStatus (&EnumValuesTrackerStatus())[6] {
  static const TrackerStatus values[] = {
    TrackerStatus::NONE,
    TrackerStatus::DISCONNECTED,
    TrackerStatus::OK,
    TrackerStatus::BUSY,
    TrackerStatus::ERROR,
    TrackerStatus::OCCLUDED
  };
  return values;
}

inline const char * const *EnumNamesTrackerStatus() {
  static const char * const names[7] = {
    "NONE",
    "DISCONNECTED",
    "OK",
    "BUSY",
    "ERROR",
    "OCCLUDED",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrackerStatus(TrackerStatus e) {
  if (flatbuffers::IsOutRange(e, TrackerStatus::NONE, TrackerStatus::OCCLUDED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrackerStatus()[index];
}

namespace hardware_info {

enum class McuType : uint16_t {
  Other = 0,
  ESP8266 = 1,
  ESP32_S2 = 2,
  ESP32_S3 = 3,
  ESP32_C3 = 4,
  MIN = Other,
  MAX = ESP32_C3
};

inline const McuType (&EnumValuesMcuType())[5] {
  static const McuType values[] = {
    McuType::Other,
    McuType::ESP8266,
    McuType::ESP32_S2,
    McuType::ESP32_S3,
    McuType::ESP32_C3
  };
  return values;
}

inline const char * const *EnumNamesMcuType() {
  static const char * const names[6] = {
    "Other",
    "ESP8266",
    "ESP32_S2",
    "ESP32_S3",
    "ESP32_C3",
    nullptr
  };
  return names;
}

inline const char *EnumNameMcuType(McuType e) {
  if (flatbuffers::IsOutRange(e, McuType::Other, McuType::ESP32_C3)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMcuType()[index];
}

enum class ImuType : uint16_t {
  Other = 0,
  BNO085 = 1,
  BNO080 = 2,
  MPU6050 = 3,
  MPU9250 = 4,
  MPU6500 = 5,
  MIN = Other,
  MAX = MPU6500
};

inline const ImuType (&EnumValuesImuType())[6] {
  static const ImuType values[] = {
    ImuType::Other,
    ImuType::BNO085,
    ImuType::BNO080,
    ImuType::MPU6050,
    ImuType::MPU9250,
    ImuType::MPU6500
  };
  return values;
}

inline const char * const *EnumNamesImuType() {
  static const char * const names[7] = {
    "Other",
    "BNO085",
    "BNO080",
    "MPU6050",
    "MPU9250",
    "MPU6500",
    nullptr
  };
  return names;
}

inline const char *EnumNameImuType(ImuType e) {
  if (flatbuffers::IsOutRange(e, ImuType::Other, ImuType::MPU6500)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesImuType()[index];
}

}  // namespace hardware_info
}  // namespace datatypes

namespace data_feed {

enum class DataFeedMessage : uint8_t {
  NONE = 0,
  PollDataFeed = 1,
  StartDataFeed = 2,
  DataFeedUpdate = 3,
  DataFeedConfig = 4,
  MIN = NONE,
  MAX = DataFeedConfig
};

inline const DataFeedMessage (&EnumValuesDataFeedMessage())[5] {
  static const DataFeedMessage values[] = {
    DataFeedMessage::NONE,
    DataFeedMessage::PollDataFeed,
    DataFeedMessage::StartDataFeed,
    DataFeedMessage::DataFeedUpdate,
    DataFeedMessage::DataFeedConfig
  };
  return values;
}

inline const char * const *EnumNamesDataFeedMessage() {
  static const char * const names[6] = {
    "NONE",
    "PollDataFeed",
    "StartDataFeed",
    "DataFeedUpdate",
    "DataFeedConfig",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataFeedMessage(DataFeedMessage e) {
  if (flatbuffers::IsOutRange(e, DataFeedMessage::NONE, DataFeedMessage::DataFeedConfig)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataFeedMessage()[index];
}

template<typename T> struct DataFeedMessageTraits {
  static const DataFeedMessage enum_value = DataFeedMessage::NONE;
};

template<> struct DataFeedMessageTraits<solarxr_protocol::data_feed::PollDataFeed> {
  static const DataFeedMessage enum_value = DataFeedMessage::PollDataFeed;
};

template<> struct DataFeedMessageTraits<solarxr_protocol::data_feed::StartDataFeed> {
  static const DataFeedMessage enum_value = DataFeedMessage::StartDataFeed;
};

template<> struct DataFeedMessageTraits<solarxr_protocol::data_feed::DataFeedUpdate> {
  static const DataFeedMessage enum_value = DataFeedMessage::DataFeedUpdate;
};

template<> struct DataFeedMessageTraits<solarxr_protocol::data_feed::DataFeedConfig> {
  static const DataFeedMessage enum_value = DataFeedMessage::DataFeedConfig;
};

bool VerifyDataFeedMessage(flatbuffers::Verifier &verifier, const void *obj, DataFeedMessage type);
bool VerifyDataFeedMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<DataFeedMessage> *types);

}  // namespace data_feed

namespace rpc {

enum class RpcMessage : uint8_t {
  NONE = 0,
  HeartbeatRequest = 1,
  HeartbeatResponse = 2,
  ResetRequest = 3,
  AssignTrackerRequest = 4,
  SettingsRequest = 5,
  SettingsResponse = 6,
  ChangeSettingsRequest = 7,
  RecordBVHRequest = 8,
  RecordBVHStatus = 9,
  SkeletonConfigRequest = 10,
  ChangeSkeletonConfigRequest = 11,
  SkeletonResetAllRequest = 12,
  SkeletonConfigResponse = 13,
  OpenSerialRequest = 14,
  CloseSerialRequest = 15,
  SetWifiRequest = 16,
  SerialUpdateResponse = 17,
  AutoBoneProcessRequest = 18,
  AutoBoneProcessStatusResponse = 19,
  AutoBoneEpochResponse = 20,
  OverlayDisplayModeRequest = 21,
  OverlayDisplayModeChangeRequest = 22,
  OverlayDisplayModeResponse = 23,
  MIN = NONE,
  MAX = OverlayDisplayModeResponse
};

inline const RpcMessage (&EnumValuesRpcMessage())[24] {
  static const RpcMessage values[] = {
    RpcMessage::NONE,
    RpcMessage::HeartbeatRequest,
    RpcMessage::HeartbeatResponse,
    RpcMessage::ResetRequest,
    RpcMessage::AssignTrackerRequest,
    RpcMessage::SettingsRequest,
    RpcMessage::SettingsResponse,
    RpcMessage::ChangeSettingsRequest,
    RpcMessage::RecordBVHRequest,
    RpcMessage::RecordBVHStatus,
    RpcMessage::SkeletonConfigRequest,
    RpcMessage::ChangeSkeletonConfigRequest,
    RpcMessage::SkeletonResetAllRequest,
    RpcMessage::SkeletonConfigResponse,
    RpcMessage::OpenSerialRequest,
    RpcMessage::CloseSerialRequest,
    RpcMessage::SetWifiRequest,
    RpcMessage::SerialUpdateResponse,
    RpcMessage::AutoBoneProcessRequest,
    RpcMessage::AutoBoneProcessStatusResponse,
    RpcMessage::AutoBoneEpochResponse,
    RpcMessage::OverlayDisplayModeRequest,
    RpcMessage::OverlayDisplayModeChangeRequest,
    RpcMessage::OverlayDisplayModeResponse
  };
  return values;
}

inline const char * const *EnumNamesRpcMessage() {
  static const char * const names[25] = {
    "NONE",
    "HeartbeatRequest",
    "HeartbeatResponse",
    "ResetRequest",
    "AssignTrackerRequest",
    "SettingsRequest",
    "SettingsResponse",
    "ChangeSettingsRequest",
    "RecordBVHRequest",
    "RecordBVHStatus",
    "SkeletonConfigRequest",
    "ChangeSkeletonConfigRequest",
    "SkeletonResetAllRequest",
    "SkeletonConfigResponse",
    "OpenSerialRequest",
    "CloseSerialRequest",
    "SetWifiRequest",
    "SerialUpdateResponse",
    "AutoBoneProcessRequest",
    "AutoBoneProcessStatusResponse",
    "AutoBoneEpochResponse",
    "OverlayDisplayModeRequest",
    "OverlayDisplayModeChangeRequest",
    "OverlayDisplayModeResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameRpcMessage(RpcMessage e) {
  if (flatbuffers::IsOutRange(e, RpcMessage::NONE, RpcMessage::OverlayDisplayModeResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRpcMessage()[index];
}

template<typename T> struct RpcMessageTraits {
  static const RpcMessage enum_value = RpcMessage::NONE;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::HeartbeatRequest> {
  static const RpcMessage enum_value = RpcMessage::HeartbeatRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::HeartbeatResponse> {
  static const RpcMessage enum_value = RpcMessage::HeartbeatResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::ResetRequest> {
  static const RpcMessage enum_value = RpcMessage::ResetRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::AssignTrackerRequest> {
  static const RpcMessage enum_value = RpcMessage::AssignTrackerRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SettingsRequest> {
  static const RpcMessage enum_value = RpcMessage::SettingsRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SettingsResponse> {
  static const RpcMessage enum_value = RpcMessage::SettingsResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::ChangeSettingsRequest> {
  static const RpcMessage enum_value = RpcMessage::ChangeSettingsRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::RecordBVHRequest> {
  static const RpcMessage enum_value = RpcMessage::RecordBVHRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::RecordBVHStatus> {
  static const RpcMessage enum_value = RpcMessage::RecordBVHStatus;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SkeletonConfigRequest> {
  static const RpcMessage enum_value = RpcMessage::SkeletonConfigRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::ChangeSkeletonConfigRequest> {
  static const RpcMessage enum_value = RpcMessage::ChangeSkeletonConfigRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SkeletonResetAllRequest> {
  static const RpcMessage enum_value = RpcMessage::SkeletonResetAllRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SkeletonConfigResponse> {
  static const RpcMessage enum_value = RpcMessage::SkeletonConfigResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::OpenSerialRequest> {
  static const RpcMessage enum_value = RpcMessage::OpenSerialRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::CloseSerialRequest> {
  static const RpcMessage enum_value = RpcMessage::CloseSerialRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SetWifiRequest> {
  static const RpcMessage enum_value = RpcMessage::SetWifiRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SerialUpdateResponse> {
  static const RpcMessage enum_value = RpcMessage::SerialUpdateResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::AutoBoneProcessRequest> {
  static const RpcMessage enum_value = RpcMessage::AutoBoneProcessRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::AutoBoneProcessStatusResponse> {
  static const RpcMessage enum_value = RpcMessage::AutoBoneProcessStatusResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::AutoBoneEpochResponse> {
  static const RpcMessage enum_value = RpcMessage::AutoBoneEpochResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::OverlayDisplayModeRequest> {
  static const RpcMessage enum_value = RpcMessage::OverlayDisplayModeRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::OverlayDisplayModeChangeRequest> {
  static const RpcMessage enum_value = RpcMessage::OverlayDisplayModeChangeRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::OverlayDisplayModeResponse> {
  static const RpcMessage enum_value = RpcMessage::OverlayDisplayModeResponse;
};

bool VerifyRpcMessage(flatbuffers::Verifier &verifier, const void *obj, RpcMessage type);
bool VerifyRpcMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<RpcMessage> *types);

enum class ResetType : uint8_t {
  Quick = 0,
  Full = 1,
  Recalibrate = 2,
  MIN = Quick,
  MAX = Recalibrate
};

inline const ResetType (&EnumValuesResetType())[3] {
  static const ResetType values[] = {
    ResetType::Quick,
    ResetType::Full,
    ResetType::Recalibrate
  };
  return values;
}

inline const char * const *EnumNamesResetType() {
  static const char * const names[4] = {
    "Quick",
    "Full",
    "Recalibrate",
    nullptr
  };
  return names;
}

inline const char *EnumNameResetType(ResetType e) {
  if (flatbuffers::IsOutRange(e, ResetType::Quick, ResetType::Recalibrate)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResetType()[index];
}

enum class SkeletonBone : uint8_t {
  NONE = 0,
  HEAD = 1,
  NECK = 2,
  TORSO = 3,
  CHEST = 4,
  WAIST = 5,
  HIP_OFFSET = 6,
  HIPS_WIDTH = 7,
  LEGS_LENGTH = 8,
  KNEE_HEIGHT = 9,
  FOOT_LENGTH = 10,
  FOOT_SHIFT = 11,
  SKELETON_OFFSET = 12,
  CONTROLLER_DISTANCE_Z = 13,
  CONTROLLER_DISTANCE_Y = 14,
  FOREARM_LENGTH = 15,
  SHOULDERS_DISTANCE = 16,
  SHOULDERS_WIDTH = 17,
  UPPER_ARM_LENGTH = 18,
  ELBOW_OFFSET = 19,
  MIN = NONE,
  MAX = ELBOW_OFFSET
};

inline const SkeletonBone (&EnumValuesSkeletonBone())[20] {
  static const SkeletonBone values[] = {
    SkeletonBone::NONE,
    SkeletonBone::HEAD,
    SkeletonBone::NECK,
    SkeletonBone::TORSO,
    SkeletonBone::CHEST,
    SkeletonBone::WAIST,
    SkeletonBone::HIP_OFFSET,
    SkeletonBone::HIPS_WIDTH,
    SkeletonBone::LEGS_LENGTH,
    SkeletonBone::KNEE_HEIGHT,
    SkeletonBone::FOOT_LENGTH,
    SkeletonBone::FOOT_SHIFT,
    SkeletonBone::SKELETON_OFFSET,
    SkeletonBone::CONTROLLER_DISTANCE_Z,
    SkeletonBone::CONTROLLER_DISTANCE_Y,
    SkeletonBone::FOREARM_LENGTH,
    SkeletonBone::SHOULDERS_DISTANCE,
    SkeletonBone::SHOULDERS_WIDTH,
    SkeletonBone::UPPER_ARM_LENGTH,
    SkeletonBone::ELBOW_OFFSET
  };
  return values;
}

inline const char * const *EnumNamesSkeletonBone() {
  static const char * const names[21] = {
    "NONE",
    "HEAD",
    "NECK",
    "TORSO",
    "CHEST",
    "WAIST",
    "HIP_OFFSET",
    "HIPS_WIDTH",
    "LEGS_LENGTH",
    "KNEE_HEIGHT",
    "FOOT_LENGTH",
    "FOOT_SHIFT",
    "SKELETON_OFFSET",
    "CONTROLLER_DISTANCE_Z",
    "CONTROLLER_DISTANCE_Y",
    "FOREARM_LENGTH",
    "SHOULDERS_DISTANCE",
    "SHOULDERS_WIDTH",
    "UPPER_ARM_LENGTH",
    "ELBOW_OFFSET",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkeletonBone(SkeletonBone e) {
  if (flatbuffers::IsOutRange(e, SkeletonBone::NONE, SkeletonBone::ELBOW_OFFSET)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSkeletonBone()[index];
}

enum class AutoBoneProcessType : uint8_t {
  NONE = 0,
  RECORD = 1,
  SAVE = 2,
  PROCESS = 3,
  APPLY = 4,
  MIN = NONE,
  MAX = APPLY
};

inline const AutoBoneProcessType (&EnumValuesAutoBoneProcessType())[5] {
  static const AutoBoneProcessType values[] = {
    AutoBoneProcessType::NONE,
    AutoBoneProcessType::RECORD,
    AutoBoneProcessType::SAVE,
    AutoBoneProcessType::PROCESS,
    AutoBoneProcessType::APPLY
  };
  return values;
}

inline const char * const *EnumNamesAutoBoneProcessType() {
  static const char * const names[6] = {
    "NONE",
    "RECORD",
    "SAVE",
    "PROCESS",
    "APPLY",
    nullptr
  };
  return names;
}

inline const char *EnumNameAutoBoneProcessType(AutoBoneProcessType e) {
  if (flatbuffers::IsOutRange(e, AutoBoneProcessType::NONE, AutoBoneProcessType::APPLY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAutoBoneProcessType()[index];
}

}  // namespace rpc

namespace datatypes {

/// Frequency as 32 bit float
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) HzF32 FLATBUFFERS_FINAL_CLASS {
 private:
  float f_;

 public:
  HzF32()
      : f_(0) {
  }
  HzF32(float _f)
      : f_(flatbuffers::EndianScalar(_f)) {
  }
  float f() const {
    return flatbuffers::EndianScalar(f_);
  }
};
FLATBUFFERS_STRUCT_END(HzF32, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TransactionId FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;

 public:
  TransactionId()
      : id_(0) {
  }
  TransactionId(uint32_t _id)
      : id_(flatbuffers::EndianScalar(_id)) {
  }
  /// This is expected to overflow, networking logic should handle this case.
  uint32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
};
FLATBUFFERS_STRUCT_END(TransactionId, 4);

/// A unique ID for the device. IDs are not guaranteed to be the same after
/// the connection is terminated.
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) DeviceId FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t id_;

 public:
  DeviceId()
      : id_(0) {
  }
  DeviceId(uint8_t _id)
      : id_(flatbuffers::EndianScalar(_id)) {
  }
  uint8_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
};
FLATBUFFERS_STRUCT_END(DeviceId, 1);

/// Temperature in degrees celsius
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Temperature FLATBUFFERS_FINAL_CLASS {
 private:
  float temp_;

 public:
  Temperature()
      : temp_(0) {
  }
  Temperature(float _temp)
      : temp_(flatbuffers::EndianScalar(_temp)) {
  }
  float temp() const {
    return flatbuffers::EndianScalar(temp_);
  }
};
FLATBUFFERS_STRUCT_END(Temperature, 4);

namespace hardware_info {

/// A MAC address or a bluetooth address, or some other uniquely identifying address
/// associated with the endpoint that we are communicating with. If it doesn't take
/// up the full set of bytes, it is aligned towards the least significant bits.
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) HardwareAddress FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t addr_;

 public:
  HardwareAddress()
      : addr_(0) {
  }
  HardwareAddress(uint64_t _addr)
      : addr_(flatbuffers::EndianScalar(_addr)) {
  }
  uint64_t addr() const {
    return flatbuffers::EndianScalar(addr_);
  }
};
FLATBUFFERS_STRUCT_END(HardwareAddress, 8);

}  // namespace hardware_info

namespace math {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Quat FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Quat()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Quat(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Quat, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3f()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3f(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3f, 12);

}  // namespace math

struct TrackerId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackerIdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICE_ID = 4,
    VT_TRACKER_NUM = 6
  };
  /// The device the tracker is associated with. If there is no hardware device it is
  /// associated with, this should be `null`.
  const solarxr_protocol::datatypes::DeviceId *device_id() const {
    return GetStruct<const solarxr_protocol::datatypes::DeviceId *>(VT_DEVICE_ID);
  }
  /// There are possibly multiple trackers per device. This identifies which one.
  uint8_t tracker_num() const {
    return GetField<uint8_t>(VT_TRACKER_NUM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<solarxr_protocol::datatypes::DeviceId>(verifier, VT_DEVICE_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_TRACKER_NUM, 1) &&
           verifier.EndTable();
  }
};

struct TrackerIdBuilder {
  typedef TrackerId Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_device_id(const solarxr_protocol::datatypes::DeviceId *device_id) {
    fbb_.AddStruct(TrackerId::VT_DEVICE_ID, device_id);
  }
  void add_tracker_num(uint8_t tracker_num) {
    fbb_.AddElement<uint8_t>(TrackerId::VT_TRACKER_NUM, tracker_num, 0);
  }
  explicit TrackerIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrackerId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackerId>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackerId> CreateTrackerId(
    flatbuffers::FlatBufferBuilder &_fbb,
    const solarxr_protocol::datatypes::DeviceId *device_id = nullptr,
    uint8_t tracker_num = 0) {
  TrackerIdBuilder builder_(_fbb);
  builder_.add_device_id(device_id);
  builder_.add_tracker_num(tracker_num);
  return builder_.Finish();
}

/// General purpose logging datatype
struct LogData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct LogDataBuilder {
  typedef LogData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(LogData::VT_MESSAGE, message);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(LogData::VT_DATA, data);
  }
  explicit LogDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogData> CreateLogData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  LogDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogData> CreateLogDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return solarxr_protocol::datatypes::CreateLogData(
      _fbb,
      message__,
      data__);
}

namespace hardware_info {

/// Mostly static info about the device's hardware/firmware.
struct HardwareInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HardwareInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MCU_ID = 4,
    VT_DISPLAY_NAME = 6,
    VT_MODEL = 8,
    VT_MANUFACTURER = 10,
    VT_HARDWARE_REVISION = 12,
    VT_FIRMWARE_VERSION = 14,
    VT_HARDWARE_ADDRESS = 16
  };
  solarxr_protocol::datatypes::hardware_info::McuType mcu_id() const {
    return static_cast<solarxr_protocol::datatypes::hardware_info::McuType>(GetField<uint16_t>(VT_MCU_ID, 0));
  }
  /// A human-friendly name to display as the name of the device.
  const flatbuffers::String *display_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  /// A human-friendly string for the device model.
  const flatbuffers::String *model() const {
    return GetPointer<const flatbuffers::String *>(VT_MODEL);
  }
  /// A human-friendly string for the manufacturer of the device.
  const flatbuffers::String *manufacturer() const {
    return GetPointer<const flatbuffers::String *>(VT_MANUFACTURER);
  }
  /// The hardware version of the device. For example, pcb version.
  const flatbuffers::String *hardware_revision() const {
    return GetPointer<const flatbuffers::String *>(VT_HARDWARE_REVISION);
  }
  /// The version of the slimevr firmware that the device is running.
  const flatbuffers::String *firmware_version() const {
    return GetPointer<const flatbuffers::String *>(VT_FIRMWARE_VERSION);
  }
  const solarxr_protocol::datatypes::hardware_info::HardwareAddress *hardware_address() const {
    return GetStruct<const solarxr_protocol::datatypes::hardware_info::HardwareAddress *>(VT_HARDWARE_ADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MCU_ID, 2) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyOffset(verifier, VT_MODEL) &&
           verifier.VerifyString(model()) &&
           VerifyOffset(verifier, VT_MANUFACTURER) &&
           verifier.VerifyString(manufacturer()) &&
           VerifyOffset(verifier, VT_HARDWARE_REVISION) &&
           verifier.VerifyString(hardware_revision()) &&
           VerifyOffset(verifier, VT_FIRMWARE_VERSION) &&
           verifier.VerifyString(firmware_version()) &&
           VerifyField<solarxr_protocol::datatypes::hardware_info::HardwareAddress>(verifier, VT_HARDWARE_ADDRESS, 8) &&
           verifier.EndTable();
  }
};

struct HardwareInfoBuilder {
  typedef HardwareInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mcu_id(solarxr_protocol::datatypes::hardware_info::McuType mcu_id) {
    fbb_.AddElement<uint16_t>(HardwareInfo::VT_MCU_ID, static_cast<uint16_t>(mcu_id), 0);
  }
  void add_display_name(flatbuffers::Offset<flatbuffers::String> display_name) {
    fbb_.AddOffset(HardwareInfo::VT_DISPLAY_NAME, display_name);
  }
  void add_model(flatbuffers::Offset<flatbuffers::String> model) {
    fbb_.AddOffset(HardwareInfo::VT_MODEL, model);
  }
  void add_manufacturer(flatbuffers::Offset<flatbuffers::String> manufacturer) {
    fbb_.AddOffset(HardwareInfo::VT_MANUFACTURER, manufacturer);
  }
  void add_hardware_revision(flatbuffers::Offset<flatbuffers::String> hardware_revision) {
    fbb_.AddOffset(HardwareInfo::VT_HARDWARE_REVISION, hardware_revision);
  }
  void add_firmware_version(flatbuffers::Offset<flatbuffers::String> firmware_version) {
    fbb_.AddOffset(HardwareInfo::VT_FIRMWARE_VERSION, firmware_version);
  }
  void add_hardware_address(const solarxr_protocol::datatypes::hardware_info::HardwareAddress *hardware_address) {
    fbb_.AddStruct(HardwareInfo::VT_HARDWARE_ADDRESS, hardware_address);
  }
  explicit HardwareInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HardwareInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardwareInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardwareInfo> CreateHardwareInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::hardware_info::McuType mcu_id = solarxr_protocol::datatypes::hardware_info::McuType::Other,
    flatbuffers::Offset<flatbuffers::String> display_name = 0,
    flatbuffers::Offset<flatbuffers::String> model = 0,
    flatbuffers::Offset<flatbuffers::String> manufacturer = 0,
    flatbuffers::Offset<flatbuffers::String> hardware_revision = 0,
    flatbuffers::Offset<flatbuffers::String> firmware_version = 0,
    const solarxr_protocol::datatypes::hardware_info::HardwareAddress *hardware_address = nullptr) {
  HardwareInfoBuilder builder_(_fbb);
  builder_.add_hardware_address(hardware_address);
  builder_.add_firmware_version(firmware_version);
  builder_.add_hardware_revision(hardware_revision);
  builder_.add_manufacturer(manufacturer);
  builder_.add_model(model);
  builder_.add_display_name(display_name);
  builder_.add_mcu_id(mcu_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<HardwareInfo> CreateHardwareInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::hardware_info::McuType mcu_id = solarxr_protocol::datatypes::hardware_info::McuType::Other,
    const char *display_name = nullptr,
    const char *model = nullptr,
    const char *manufacturer = nullptr,
    const char *hardware_revision = nullptr,
    const char *firmware_version = nullptr,
    const solarxr_protocol::datatypes::hardware_info::HardwareAddress *hardware_address = nullptr) {
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  auto model__ = model ? _fbb.CreateString(model) : 0;
  auto manufacturer__ = manufacturer ? _fbb.CreateString(manufacturer) : 0;
  auto hardware_revision__ = hardware_revision ? _fbb.CreateString(hardware_revision) : 0;
  auto firmware_version__ = firmware_version ? _fbb.CreateString(firmware_version) : 0;
  return solarxr_protocol::datatypes::hardware_info::CreateHardwareInfo(
      _fbb,
      mcu_id,
      display_name__,
      model__,
      manufacturer__,
      hardware_revision__,
      firmware_version__,
      hardware_address);
}

/// Mostly-dynamic status info about a tracked device's firmware
struct HardwareStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HardwareStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_STATUS = 4,
    VT_TPS = 6,
    VT_PING = 8,
    VT_RSSI = 10,
    VT_MCU_TEMP = 12,
    VT_BATTERY_VOLTAGE = 14,
    VT_BATTERY_PCT_ESTIMATE = 16,
    VT_LOG_DATA = 18
  };
  flatbuffers::Optional<solarxr_protocol::datatypes::FirmwareErrorCode> error_status() const {
    return GetOptional<uint8_t, solarxr_protocol::datatypes::FirmwareErrorCode>(VT_ERROR_STATUS);
  }
  flatbuffers::Optional<uint8_t> tps() const {
    return GetOptional<uint8_t, uint8_t>(VT_TPS);
  }
  flatbuffers::Optional<uint16_t> ping() const {
    return GetOptional<uint16_t, uint16_t>(VT_PING);
  }
  /// â€œReceived Signal Strength Indicator" between device and wifi adapter in dBm
  flatbuffers::Optional<int16_t> rssi() const {
    return GetOptional<int16_t, int16_t>(VT_RSSI);
  }
  /// Temperature in degrees celsius
  flatbuffers::Optional<float> mcu_temp() const {
    return GetOptional<float, float>(VT_MCU_TEMP);
  }
  flatbuffers::Optional<float> battery_voltage() const {
    return GetOptional<float, float>(VT_BATTERY_VOLTAGE);
  }
  flatbuffers::Optional<uint8_t> battery_pct_estimate() const {
    return GetOptional<uint8_t, uint8_t>(VT_BATTERY_PCT_ESTIMATE);
  }
  const solarxr_protocol::datatypes::LogData *log_data() const {
    return GetPointer<const solarxr_protocol::datatypes::LogData *>(VT_LOG_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ERROR_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_TPS, 1) &&
           VerifyField<uint16_t>(verifier, VT_PING, 2) &&
           VerifyField<int16_t>(verifier, VT_RSSI, 2) &&
           VerifyField<float>(verifier, VT_MCU_TEMP, 4) &&
           VerifyField<float>(verifier, VT_BATTERY_VOLTAGE, 4) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_PCT_ESTIMATE, 1) &&
           VerifyOffset(verifier, VT_LOG_DATA) &&
           verifier.VerifyTable(log_data()) &&
           verifier.EndTable();
  }
};

struct HardwareStatusBuilder {
  typedef HardwareStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_status(solarxr_protocol::datatypes::FirmwareErrorCode error_status) {
    fbb_.AddElement<uint8_t>(HardwareStatus::VT_ERROR_STATUS, static_cast<uint8_t>(error_status));
  }
  void add_tps(uint8_t tps) {
    fbb_.AddElement<uint8_t>(HardwareStatus::VT_TPS, tps);
  }
  void add_ping(uint16_t ping) {
    fbb_.AddElement<uint16_t>(HardwareStatus::VT_PING, ping);
  }
  void add_rssi(int16_t rssi) {
    fbb_.AddElement<int16_t>(HardwareStatus::VT_RSSI, rssi);
  }
  void add_mcu_temp(float mcu_temp) {
    fbb_.AddElement<float>(HardwareStatus::VT_MCU_TEMP, mcu_temp);
  }
  void add_battery_voltage(float battery_voltage) {
    fbb_.AddElement<float>(HardwareStatus::VT_BATTERY_VOLTAGE, battery_voltage);
  }
  void add_battery_pct_estimate(uint8_t battery_pct_estimate) {
    fbb_.AddElement<uint8_t>(HardwareStatus::VT_BATTERY_PCT_ESTIMATE, battery_pct_estimate);
  }
  void add_log_data(flatbuffers::Offset<solarxr_protocol::datatypes::LogData> log_data) {
    fbb_.AddOffset(HardwareStatus::VT_LOG_DATA, log_data);
  }
  explicit HardwareStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HardwareStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardwareStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardwareStatus> CreateHardwareStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<solarxr_protocol::datatypes::FirmwareErrorCode> error_status = flatbuffers::nullopt,
    flatbuffers::Optional<uint8_t> tps = flatbuffers::nullopt,
    flatbuffers::Optional<uint16_t> ping = flatbuffers::nullopt,
    flatbuffers::Optional<int16_t> rssi = flatbuffers::nullopt,
    flatbuffers::Optional<float> mcu_temp = flatbuffers::nullopt,
    flatbuffers::Optional<float> battery_voltage = flatbuffers::nullopt,
    flatbuffers::Optional<uint8_t> battery_pct_estimate = flatbuffers::nullopt,
    flatbuffers::Offset<solarxr_protocol::datatypes::LogData> log_data = 0) {
  HardwareStatusBuilder builder_(_fbb);
  builder_.add_log_data(log_data);
  if(battery_voltage) { builder_.add_battery_voltage(*battery_voltage); }
  if(mcu_temp) { builder_.add_mcu_temp(*mcu_temp); }
  if(rssi) { builder_.add_rssi(*rssi); }
  if(ping) { builder_.add_ping(*ping); }
  if(battery_pct_estimate) { builder_.add_battery_pct_estimate(*battery_pct_estimate); }
  if(tps) { builder_.add_tps(*tps); }
  if(error_status) { builder_.add_error_status(*error_status); }
  return builder_.Finish();
}

/// A mask of the data in `FirmwareStatus`
struct FirmwareStatusMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FirmwareStatusMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_STATUS = 4,
    VT_TPS = 6,
    VT_PING = 8,
    VT_RSSI = 10,
    VT_MCU_TEMP = 12,
    VT_BATTERY_VOLTAGE = 14,
    VT_BATTERY_PCT_ESTIMATE = 16
  };
  bool error_status() const {
    return GetField<uint8_t>(VT_ERROR_STATUS, 0) != 0;
  }
  bool tps() const {
    return GetField<uint8_t>(VT_TPS, 0) != 0;
  }
  bool ping() const {
    return GetField<uint8_t>(VT_PING, 0) != 0;
  }
  bool rssi() const {
    return GetField<uint8_t>(VT_RSSI, 0) != 0;
  }
  bool mcu_temp() const {
    return GetField<uint8_t>(VT_MCU_TEMP, 0) != 0;
  }
  bool battery_voltage() const {
    return GetField<uint8_t>(VT_BATTERY_VOLTAGE, 0) != 0;
  }
  bool battery_pct_estimate() const {
    return GetField<uint8_t>(VT_BATTERY_PCT_ESTIMATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ERROR_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_TPS, 1) &&
           VerifyField<uint8_t>(verifier, VT_PING, 1) &&
           VerifyField<uint8_t>(verifier, VT_RSSI, 1) &&
           VerifyField<uint8_t>(verifier, VT_MCU_TEMP, 1) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_VOLTAGE, 1) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_PCT_ESTIMATE, 1) &&
           verifier.EndTable();
  }
};

struct FirmwareStatusMaskBuilder {
  typedef FirmwareStatusMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_status(bool error_status) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_ERROR_STATUS, static_cast<uint8_t>(error_status), 0);
  }
  void add_tps(bool tps) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_TPS, static_cast<uint8_t>(tps), 0);
  }
  void add_ping(bool ping) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_PING, static_cast<uint8_t>(ping), 0);
  }
  void add_rssi(bool rssi) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_RSSI, static_cast<uint8_t>(rssi), 0);
  }
  void add_mcu_temp(bool mcu_temp) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_MCU_TEMP, static_cast<uint8_t>(mcu_temp), 0);
  }
  void add_battery_voltage(bool battery_voltage) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_BATTERY_VOLTAGE, static_cast<uint8_t>(battery_voltage), 0);
  }
  void add_battery_pct_estimate(bool battery_pct_estimate) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_BATTERY_PCT_ESTIMATE, static_cast<uint8_t>(battery_pct_estimate), 0);
  }
  explicit FirmwareStatusMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FirmwareStatusMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FirmwareStatusMask>(end);
    return o;
  }
};

inline flatbuffers::Offset<FirmwareStatusMask> CreateFirmwareStatusMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool error_status = false,
    bool tps = false,
    bool ping = false,
    bool rssi = false,
    bool mcu_temp = false,
    bool battery_voltage = false,
    bool battery_pct_estimate = false) {
  FirmwareStatusMaskBuilder builder_(_fbb);
  builder_.add_battery_pct_estimate(battery_pct_estimate);
  builder_.add_battery_voltage(battery_voltage);
  builder_.add_mcu_temp(mcu_temp);
  builder_.add_rssi(rssi);
  builder_.add_ping(ping);
  builder_.add_tps(tps);
  builder_.add_error_status(error_status);
  return builder_.Finish();
}

}  // namespace hardware_info
}  // namespace datatypes

namespace data_feed {
namespace tracker {

/// Describes all possible information about a tracker. A tracker is anything that
/// provides kinematic data about a particular body part.
///
/// Trackers may be synthetic/computed or instead part of an actual hardware device.
/// There can be multiple trackers per hardware device.
struct TrackerData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackerDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACKER_ID = 4,
    VT_INFO = 6,
    VT_STATUS = 8,
    VT_ROTATION = 10,
    VT_POSITION = 12,
    VT_RAW_ROT_VEL = 14,
    VT_RAW_TRANS_ACCEL = 16,
    VT_TEMP = 18
  };
  const solarxr_protocol::datatypes::TrackerId *tracker_id() const {
    return GetPointer<const solarxr_protocol::datatypes::TrackerId *>(VT_TRACKER_ID);
  }
  const solarxr_protocol::data_feed::tracker::TrackerInfo *info() const {
    return GetPointer<const solarxr_protocol::data_feed::tracker::TrackerInfo *>(VT_INFO);
  }
  solarxr_protocol::datatypes::TrackerStatus status() const {
    return static_cast<solarxr_protocol::datatypes::TrackerStatus>(GetField<uint8_t>(VT_STATUS, 0));
  }
  const solarxr_protocol::datatypes::math::Quat *rotation() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_ROTATION);
  }
  /// Position, in meters
  const solarxr_protocol::datatypes::math::Vec3f *position() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Vec3f *>(VT_POSITION);
  }
  /// Raw rotational velocity, in euler angles
  const solarxr_protocol::datatypes::math::Vec3f *raw_rot_vel() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Vec3f *>(VT_RAW_ROT_VEL);
  }
  /// Raw translational acceleration, in m/s^2
  const solarxr_protocol::datatypes::math::Vec3f *raw_trans_accel() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Vec3f *>(VT_RAW_TRANS_ACCEL);
  }
  /// Temperature in degrees celsius
  const solarxr_protocol::datatypes::Temperature *temp() const {
    return GetStruct<const solarxr_protocol::datatypes::Temperature *>(VT_TEMP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACKER_ID) &&
           verifier.VerifyTable(tracker_id()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_ROTATION, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Vec3f>(verifier, VT_POSITION, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Vec3f>(verifier, VT_RAW_ROT_VEL, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Vec3f>(verifier, VT_RAW_TRANS_ACCEL, 4) &&
           VerifyField<solarxr_protocol::datatypes::Temperature>(verifier, VT_TEMP, 4) &&
           verifier.EndTable();
  }
};

struct TrackerDataBuilder {
  typedef TrackerData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tracker_id(flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id) {
    fbb_.AddOffset(TrackerData::VT_TRACKER_ID, tracker_id);
  }
  void add_info(flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerInfo> info) {
    fbb_.AddOffset(TrackerData::VT_INFO, info);
  }
  void add_status(solarxr_protocol::datatypes::TrackerStatus status) {
    fbb_.AddElement<uint8_t>(TrackerData::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_rotation(const solarxr_protocol::datatypes::math::Quat *rotation) {
    fbb_.AddStruct(TrackerData::VT_ROTATION, rotation);
  }
  void add_position(const solarxr_protocol::datatypes::math::Vec3f *position) {
    fbb_.AddStruct(TrackerData::VT_POSITION, position);
  }
  void add_raw_rot_vel(const solarxr_protocol::datatypes::math::Vec3f *raw_rot_vel) {
    fbb_.AddStruct(TrackerData::VT_RAW_ROT_VEL, raw_rot_vel);
  }
  void add_raw_trans_accel(const solarxr_protocol::datatypes::math::Vec3f *raw_trans_accel) {
    fbb_.AddStruct(TrackerData::VT_RAW_TRANS_ACCEL, raw_trans_accel);
  }
  void add_temp(const solarxr_protocol::datatypes::Temperature *temp) {
    fbb_.AddStruct(TrackerData::VT_TEMP, temp);
  }
  explicit TrackerDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrackerData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackerData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackerData> CreateTrackerData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id = 0,
    flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerInfo> info = 0,
    solarxr_protocol::datatypes::TrackerStatus status = solarxr_protocol::datatypes::TrackerStatus::NONE,
    const solarxr_protocol::datatypes::math::Quat *rotation = nullptr,
    const solarxr_protocol::datatypes::math::Vec3f *position = nullptr,
    const solarxr_protocol::datatypes::math::Vec3f *raw_rot_vel = nullptr,
    const solarxr_protocol::datatypes::math::Vec3f *raw_trans_accel = nullptr,
    const solarxr_protocol::datatypes::Temperature *temp = nullptr) {
  TrackerDataBuilder builder_(_fbb);
  builder_.add_temp(temp);
  builder_.add_raw_trans_accel(raw_trans_accel);
  builder_.add_raw_rot_vel(raw_rot_vel);
  builder_.add_position(position);
  builder_.add_rotation(rotation);
  builder_.add_info(info);
  builder_.add_tracker_id(tracker_id);
  builder_.add_status(status);
  return builder_.Finish();
}

/// A mask of the different components in `TrackerComponent`
struct TrackerDataMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackerDataMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_STATUS = 6,
    VT_ROTATION = 8,
    VT_POSITION = 10,
    VT_RAW_ROT_VEL = 12,
    VT_RAW_TRANS_ACCEL = 14,
    VT_TEMP = 16
  };
  bool info() const {
    return GetField<uint8_t>(VT_INFO, 0) != 0;
  }
  bool status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  bool rotation() const {
    return GetField<uint8_t>(VT_ROTATION, 0) != 0;
  }
  bool position() const {
    return GetField<uint8_t>(VT_POSITION, 0) != 0;
  }
  bool raw_rot_vel() const {
    return GetField<uint8_t>(VT_RAW_ROT_VEL, 0) != 0;
  }
  bool raw_trans_accel() const {
    return GetField<uint8_t>(VT_RAW_TRANS_ACCEL, 0) != 0;
  }
  bool temp() const {
    return GetField<uint8_t>(VT_TEMP, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INFO, 1) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_ROTATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_POSITION, 1) &&
           VerifyField<uint8_t>(verifier, VT_RAW_ROT_VEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_RAW_TRANS_ACCEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_TEMP, 1) &&
           verifier.EndTable();
  }
};

struct TrackerDataMaskBuilder {
  typedef TrackerDataMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(bool info) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_INFO, static_cast<uint8_t>(info), 0);
  }
  void add_status(bool status) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_rotation(bool rotation) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_ROTATION, static_cast<uint8_t>(rotation), 0);
  }
  void add_position(bool position) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_POSITION, static_cast<uint8_t>(position), 0);
  }
  void add_raw_rot_vel(bool raw_rot_vel) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_RAW_ROT_VEL, static_cast<uint8_t>(raw_rot_vel), 0);
  }
  void add_raw_trans_accel(bool raw_trans_accel) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_RAW_TRANS_ACCEL, static_cast<uint8_t>(raw_trans_accel), 0);
  }
  void add_temp(bool temp) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_TEMP, static_cast<uint8_t>(temp), 0);
  }
  explicit TrackerDataMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrackerDataMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackerDataMask>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackerDataMask> CreateTrackerDataMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool info = false,
    bool status = false,
    bool rotation = false,
    bool position = false,
    bool raw_rot_vel = false,
    bool raw_trans_accel = false,
    bool temp = false) {
  TrackerDataMaskBuilder builder_(_fbb);
  builder_.add_temp(temp);
  builder_.add_raw_trans_accel(raw_trans_accel);
  builder_.add_raw_rot_vel(raw_rot_vel);
  builder_.add_position(position);
  builder_.add_rotation(rotation);
  builder_.add_status(status);
  builder_.add_info(info);
  return builder_.Finish();
}

/// Static description of a tracker
struct TrackerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMU_TYPE = 4,
    VT_BODY_PART = 6,
    VT_POLL_RATE = 8,
    VT_MOUNTING_ORIENTATION = 10,
    VT_EDITABLE = 12,
    VT_COMPUTED = 14,
    VT_DISPLAY_NAME = 16,
    VT_CUSTOM_NAME = 18
  };
  solarxr_protocol::datatypes::hardware_info::ImuType imu_type() const {
    return static_cast<solarxr_protocol::datatypes::hardware_info::ImuType>(GetField<uint16_t>(VT_IMU_TYPE, 0));
  }
  /// The user-assigned role of the tracker.
  solarxr_protocol::datatypes::BodyPart body_part() const {
    return static_cast<solarxr_protocol::datatypes::BodyPart>(GetField<uint8_t>(VT_BODY_PART, 0));
  }
  /// average samples per second
  const solarxr_protocol::datatypes::HzF32 *poll_rate() const {
    return GetStruct<const solarxr_protocol::datatypes::HzF32 *>(VT_POLL_RATE);
  }
  /// The orientation of the tracker when mounted on the body
  const solarxr_protocol::datatypes::math::Quat *mounting_orientation() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_MOUNTING_ORIENTATION);
  }
  bool editable() const {
    return GetField<uint8_t>(VT_EDITABLE, 0) != 0;
  }
  bool computed() const {
    return GetField<uint8_t>(VT_COMPUTED, 0) != 0;
  }
  /// A human-friendly name to display as the name of the tracker.
  const flatbuffers::String *display_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  /// name to display as the name of the tracker set by the user
  const flatbuffers::String *custom_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CUSTOM_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_IMU_TYPE, 2) &&
           VerifyField<uint8_t>(verifier, VT_BODY_PART, 1) &&
           VerifyField<solarxr_protocol::datatypes::HzF32>(verifier, VT_POLL_RATE, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_MOUNTING_ORIENTATION, 4) &&
           VerifyField<uint8_t>(verifier, VT_EDITABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_COMPUTED, 1) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyOffset(verifier, VT_CUSTOM_NAME) &&
           verifier.VerifyString(custom_name()) &&
           verifier.EndTable();
  }
};

struct TrackerInfoBuilder {
  typedef TrackerInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_imu_type(solarxr_protocol::datatypes::hardware_info::ImuType imu_type) {
    fbb_.AddElement<uint16_t>(TrackerInfo::VT_IMU_TYPE, static_cast<uint16_t>(imu_type), 0);
  }
  void add_body_part(solarxr_protocol::datatypes::BodyPart body_part) {
    fbb_.AddElement<uint8_t>(TrackerInfo::VT_BODY_PART, static_cast<uint8_t>(body_part), 0);
  }
  void add_poll_rate(const solarxr_protocol::datatypes::HzF32 *poll_rate) {
    fbb_.AddStruct(TrackerInfo::VT_POLL_RATE, poll_rate);
  }
  void add_mounting_orientation(const solarxr_protocol::datatypes::math::Quat *mounting_orientation) {
    fbb_.AddStruct(TrackerInfo::VT_MOUNTING_ORIENTATION, mounting_orientation);
  }
  void add_editable(bool editable) {
    fbb_.AddElement<uint8_t>(TrackerInfo::VT_EDITABLE, static_cast<uint8_t>(editable), 0);
  }
  void add_computed(bool computed) {
    fbb_.AddElement<uint8_t>(TrackerInfo::VT_COMPUTED, static_cast<uint8_t>(computed), 0);
  }
  void add_display_name(flatbuffers::Offset<flatbuffers::String> display_name) {
    fbb_.AddOffset(TrackerInfo::VT_DISPLAY_NAME, display_name);
  }
  void add_custom_name(flatbuffers::Offset<flatbuffers::String> custom_name) {
    fbb_.AddOffset(TrackerInfo::VT_CUSTOM_NAME, custom_name);
  }
  explicit TrackerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrackerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackerInfo> CreateTrackerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::hardware_info::ImuType imu_type = solarxr_protocol::datatypes::hardware_info::ImuType::Other,
    solarxr_protocol::datatypes::BodyPart body_part = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::HzF32 *poll_rate = nullptr,
    const solarxr_protocol::datatypes::math::Quat *mounting_orientation = nullptr,
    bool editable = false,
    bool computed = false,
    flatbuffers::Offset<flatbuffers::String> display_name = 0,
    flatbuffers::Offset<flatbuffers::String> custom_name = 0) {
  TrackerInfoBuilder builder_(_fbb);
  builder_.add_custom_name(custom_name);
  builder_.add_display_name(display_name);
  builder_.add_mounting_orientation(mounting_orientation);
  builder_.add_poll_rate(poll_rate);
  builder_.add_imu_type(imu_type);
  builder_.add_computed(computed);
  builder_.add_editable(editable);
  builder_.add_body_part(body_part);
  return builder_.Finish();
}

inline flatbuffers::Offset<TrackerInfo> CreateTrackerInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::hardware_info::ImuType imu_type = solarxr_protocol::datatypes::hardware_info::ImuType::Other,
    solarxr_protocol::datatypes::BodyPart body_part = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::HzF32 *poll_rate = nullptr,
    const solarxr_protocol::datatypes::math::Quat *mounting_orientation = nullptr,
    bool editable = false,
    bool computed = false,
    const char *display_name = nullptr,
    const char *custom_name = nullptr) {
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  auto custom_name__ = custom_name ? _fbb.CreateString(custom_name) : 0;
  return solarxr_protocol::data_feed::tracker::CreateTrackerInfo(
      _fbb,
      imu_type,
      body_part,
      poll_rate,
      mounting_orientation,
      editable,
      computed,
      display_name__,
      custom_name__);
}

}  // namespace tracker

namespace device_data {

/// A mask of values to be reported in subsequent DeviceStatus. Values set to `false`
/// or `null` will not reported. By default, all fields are false/null.
///
/// If you set a value to `true`, it is not guaranteed that the sender actually has
/// such a value to send. In this case, they will probably send `null`, and the receiver
/// has the choice to disconnect due to missing data.
struct DeviceDataMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceDataMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACKER_DATA = 4,
    VT_DEVICE_DATA = 6
  };
  /// Which tracker data should be sent in this data feed
  const solarxr_protocol::data_feed::tracker::TrackerDataMask *tracker_data() const {
    return GetPointer<const solarxr_protocol::data_feed::tracker::TrackerDataMask *>(VT_TRACKER_DATA);
  }
  /// true if device data should be sent in this data feed
  bool device_data() const {
    return GetField<uint8_t>(VT_DEVICE_DATA, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACKER_DATA) &&
           verifier.VerifyTable(tracker_data()) &&
           VerifyField<uint8_t>(verifier, VT_DEVICE_DATA, 1) &&
           verifier.EndTable();
  }
};

struct DeviceDataMaskBuilder {
  typedef DeviceDataMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tracker_data(flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerDataMask> tracker_data) {
    fbb_.AddOffset(DeviceDataMask::VT_TRACKER_DATA, tracker_data);
  }
  void add_device_data(bool device_data) {
    fbb_.AddElement<uint8_t>(DeviceDataMask::VT_DEVICE_DATA, static_cast<uint8_t>(device_data), 0);
  }
  explicit DeviceDataMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceDataMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceDataMask>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceDataMask> CreateDeviceDataMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerDataMask> tracker_data = 0,
    bool device_data = false) {
  DeviceDataMaskBuilder builder_(_fbb);
  builder_.add_tracker_data(tracker_data);
  builder_.add_device_data(device_data);
  return builder_.Finish();
}

/// Describes all possible information about a hardware device. For example, a
/// vive tracker is a  single hardware device, and a slime tracker with two
/// extensions is a single hardware device but two trackers.
struct DeviceData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CUSTOM_NAME = 6,
    VT_HARDWARE_INFO = 8,
    VT_HARDWARE_STATUS = 10,
    VT_TRACKERS = 12
  };
  const solarxr_protocol::datatypes::DeviceId *id() const {
    return GetStruct<const solarxr_protocol::datatypes::DeviceId *>(VT_ID);
  }
  /// The dynamically changeable name of the device. This might be set by the
  /// user to help them remember which tracker is which.
  const flatbuffers::String *custom_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CUSTOM_NAME);
  }
  /// Mostly-static info about the device hardware
  const solarxr_protocol::datatypes::hardware_info::HardwareInfo *hardware_info() const {
    return GetPointer<const solarxr_protocol::datatypes::hardware_info::HardwareInfo *>(VT_HARDWARE_INFO);
  }
  /// General info about the status of the device
  const solarxr_protocol::datatypes::hardware_info::HardwareStatus *hardware_status() const {
    return GetPointer<const solarxr_protocol::datatypes::hardware_info::HardwareStatus *>(VT_HARDWARE_STATUS);
  }
  /// Info about all trackers attached to this device
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>> *trackers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>> *>(VT_TRACKERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<solarxr_protocol::datatypes::DeviceId>(verifier, VT_ID, 1) &&
           VerifyOffset(verifier, VT_CUSTOM_NAME) &&
           verifier.VerifyString(custom_name()) &&
           VerifyOffset(verifier, VT_HARDWARE_INFO) &&
           verifier.VerifyTable(hardware_info()) &&
           VerifyOffset(verifier, VT_HARDWARE_STATUS) &&
           verifier.VerifyTable(hardware_status()) &&
           VerifyOffset(verifier, VT_TRACKERS) &&
           verifier.VerifyVector(trackers()) &&
           verifier.VerifyVectorOfTables(trackers()) &&
           verifier.EndTable();
  }
};

struct DeviceDataBuilder {
  typedef DeviceData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(const solarxr_protocol::datatypes::DeviceId *id) {
    fbb_.AddStruct(DeviceData::VT_ID, id);
  }
  void add_custom_name(flatbuffers::Offset<flatbuffers::String> custom_name) {
    fbb_.AddOffset(DeviceData::VT_CUSTOM_NAME, custom_name);
  }
  void add_hardware_info(flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareInfo> hardware_info) {
    fbb_.AddOffset(DeviceData::VT_HARDWARE_INFO, hardware_info);
  }
  void add_hardware_status(flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareStatus> hardware_status) {
    fbb_.AddOffset(DeviceData::VT_HARDWARE_STATUS, hardware_status);
  }
  void add_trackers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>>> trackers) {
    fbb_.AddOffset(DeviceData::VT_TRACKERS, trackers);
  }
  explicit DeviceDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceData> CreateDeviceData(
    flatbuffers::FlatBufferBuilder &_fbb,
    const solarxr_protocol::datatypes::DeviceId *id = nullptr,
    flatbuffers::Offset<flatbuffers::String> custom_name = 0,
    flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareInfo> hardware_info = 0,
    flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareStatus> hardware_status = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>>> trackers = 0) {
  DeviceDataBuilder builder_(_fbb);
  builder_.add_trackers(trackers);
  builder_.add_hardware_status(hardware_status);
  builder_.add_hardware_info(hardware_info);
  builder_.add_custom_name(custom_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceData> CreateDeviceDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const solarxr_protocol::datatypes::DeviceId *id = nullptr,
    const char *custom_name = nullptr,
    flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareInfo> hardware_info = 0,
    flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareStatus> hardware_status = 0,
    const std::vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>> *trackers = nullptr) {
  auto custom_name__ = custom_name ? _fbb.CreateString(custom_name) : 0;
  auto trackers__ = trackers ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>>(*trackers) : 0;
  return solarxr_protocol::data_feed::device_data::CreateDeviceData(
      _fbb,
      id,
      custom_name__,
      hardware_info,
      hardware_status,
      trackers__);
}

}  // namespace device_data

struct Bone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoneBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BODY_PART = 4,
    VT_ROTATION_G = 6,
    VT_BONE_LENGTH = 8,
    VT_HEAD_POSITION_G = 10
  };
  solarxr_protocol::datatypes::BodyPart body_part() const {
    return static_cast<solarxr_protocol::datatypes::BodyPart>(GetField<uint8_t>(VT_BODY_PART, 0));
  }
  /// The global rotation of the bone.
  ///
  /// Note that the identity rotation is where a bone's tail is towards -y (assuming
  /// the head of the bone is the origin)
  const solarxr_protocol::datatypes::math::Quat *rotation_g() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_ROTATION_G);
  }
  float bone_length() const {
    return GetField<float>(VT_BONE_LENGTH, 0.0f);
  }
  /// The global position of the head of this bone.
  ///
  /// The head of a bone is joint/node of the bone touching the parent bone. The
  /// parent is defined as the bone closer to the HMD.
  const solarxr_protocol::datatypes::math::Vec3f *head_position_g() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Vec3f *>(VT_HEAD_POSITION_G);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BODY_PART, 1) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_ROTATION_G, 4) &&
           VerifyField<float>(verifier, VT_BONE_LENGTH, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Vec3f>(verifier, VT_HEAD_POSITION_G, 4) &&
           verifier.EndTable();
  }
};

struct BoneBuilder {
  typedef Bone Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_body_part(solarxr_protocol::datatypes::BodyPart body_part) {
    fbb_.AddElement<uint8_t>(Bone::VT_BODY_PART, static_cast<uint8_t>(body_part), 0);
  }
  void add_rotation_g(const solarxr_protocol::datatypes::math::Quat *rotation_g) {
    fbb_.AddStruct(Bone::VT_ROTATION_G, rotation_g);
  }
  void add_bone_length(float bone_length) {
    fbb_.AddElement<float>(Bone::VT_BONE_LENGTH, bone_length, 0.0f);
  }
  void add_head_position_g(const solarxr_protocol::datatypes::math::Vec3f *head_position_g) {
    fbb_.AddStruct(Bone::VT_HEAD_POSITION_G, head_position_g);
  }
  explicit BoneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Bone> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bone>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bone> CreateBone(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::BodyPart body_part = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::math::Quat *rotation_g = nullptr,
    float bone_length = 0.0f,
    const solarxr_protocol::datatypes::math::Vec3f *head_position_g = nullptr) {
  BoneBuilder builder_(_fbb);
  builder_.add_head_position_g(head_position_g);
  builder_.add_bone_length(bone_length);
  builder_.add_rotation_g(rotation_g);
  builder_.add_body_part(body_part);
  return builder_.Finish();
}

struct DataFeedMessageHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataFeedMessageHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  solarxr_protocol::data_feed::DataFeedMessage message_type() const {
    return static_cast<solarxr_protocol::data_feed::DataFeedMessage>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const solarxr_protocol::data_feed::PollDataFeed *message_as_PollDataFeed() const {
    return message_type() == solarxr_protocol::data_feed::DataFeedMessage::PollDataFeed ? static_cast<const solarxr_protocol::data_feed::PollDataFeed *>(message()) : nullptr;
  }
  const solarxr_protocol::data_feed::StartDataFeed *message_as_StartDataFeed() const {
    return message_type() == solarxr_protocol::data_feed::DataFeedMessage::StartDataFeed ? static_cast<const solarxr_protocol::data_feed::StartDataFeed *>(message()) : nullptr;
  }
  const solarxr_protocol::data_feed::DataFeedUpdate *message_as_DataFeedUpdate() const {
    return message_type() == solarxr_protocol::data_feed::DataFeedMessage::DataFeedUpdate ? static_cast<const solarxr_protocol::data_feed::DataFeedUpdate *>(message()) : nullptr;
  }
  const solarxr_protocol::data_feed::DataFeedConfig *message_as_DataFeedConfig() const {
    return message_type() == solarxr_protocol::data_feed::DataFeedMessage::DataFeedConfig ? static_cast<const solarxr_protocol::data_feed::DataFeedConfig *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyDataFeedMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::data_feed::PollDataFeed *DataFeedMessageHeader::message_as<solarxr_protocol::data_feed::PollDataFeed>() const {
  return message_as_PollDataFeed();
}

template<> inline const solarxr_protocol::data_feed::StartDataFeed *DataFeedMessageHeader::message_as<solarxr_protocol::data_feed::StartDataFeed>() const {
  return message_as_StartDataFeed();
}

template<> inline const solarxr_protocol::data_feed::DataFeedUpdate *DataFeedMessageHeader::message_as<solarxr_protocol::data_feed::DataFeedUpdate>() const {
  return message_as_DataFeedUpdate();
}

template<> inline const solarxr_protocol::data_feed::DataFeedConfig *DataFeedMessageHeader::message_as<solarxr_protocol::data_feed::DataFeedConfig>() const {
  return message_as_DataFeedConfig();
}

struct DataFeedMessageHeaderBuilder {
  typedef DataFeedMessageHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(solarxr_protocol::data_feed::DataFeedMessage message_type) {
    fbb_.AddElement<uint8_t>(DataFeedMessageHeader::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(DataFeedMessageHeader::VT_MESSAGE, message);
  }
  explicit DataFeedMessageHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataFeedMessageHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFeedMessageHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFeedMessageHeader> CreateDataFeedMessageHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::data_feed::DataFeedMessage message_type = solarxr_protocol::data_feed::DataFeedMessage::NONE,
    flatbuffers::Offset<void> message = 0) {
  DataFeedMessageHeaderBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

/// Requests for a single `Update` to be sent. This is helpful when getting
/// initial info about the device.
struct PollDataFeed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PollDataFeedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIG = 4
  };
  const solarxr_protocol::data_feed::DataFeedConfig *config() const {
    return GetPointer<const solarxr_protocol::data_feed::DataFeedConfig *>(VT_CONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           verifier.EndTable();
  }
};

struct PollDataFeedBuilder {
  typedef PollDataFeed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_config(flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig> config) {
    fbb_.AddOffset(PollDataFeed::VT_CONFIG, config);
  }
  explicit PollDataFeedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PollDataFeed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PollDataFeed>(end);
    return o;
  }
};

inline flatbuffers::Offset<PollDataFeed> CreatePollDataFeed(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig> config = 0) {
  PollDataFeedBuilder builder_(_fbb);
  builder_.add_config(config);
  return builder_.Finish();
}

/// Requests for the other party to send `data_feeds`.
/// For example, GUI requests for position data to be sent from server.
///
/// When sending a new `StartFeed`, the old data feeds should stop being sent.
/// We still support multiple data feeds at the same time, because `data_feeds`
/// is a list.
///
/// Multiple data feeds are useful to get data at different frequencies.
struct StartDataFeed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StartDataFeedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_FEEDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig>> *data_feeds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig>> *>(VT_DATA_FEEDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA_FEEDS) &&
           verifier.VerifyVector(data_feeds()) &&
           verifier.VerifyVectorOfTables(data_feeds()) &&
           verifier.EndTable();
  }
};

struct StartDataFeedBuilder {
  typedef StartDataFeed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_feeds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig>>> data_feeds) {
    fbb_.AddOffset(StartDataFeed::VT_DATA_FEEDS, data_feeds);
  }
  explicit StartDataFeedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StartDataFeed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartDataFeed>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartDataFeed> CreateStartDataFeed(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig>>> data_feeds = 0) {
  StartDataFeedBuilder builder_(_fbb);
  builder_.add_data_feeds(data_feeds);
  return builder_.Finish();
}

inline flatbuffers::Offset<StartDataFeed> CreateStartDataFeedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig>> *data_feeds = nullptr) {
  auto data_feeds__ = data_feeds ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig>>(*data_feeds) : 0;
  return solarxr_protocol::data_feed::CreateStartDataFeed(
      _fbb,
      data_feeds__);
}

/// All of the data components related to a single data feed. A data feed is comprised
/// of device data, and tracker data.
///
/// A data feed might send data only when it changes/updates, and we should make no
/// assumptions that the data is actually delivered. If you want to guarantee
/// delivery and avoid dropped observations of data (such as a user-initiated
/// button press), it is better to use the RPC system.
struct DataFeedUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataFeedUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICES = 4,
    VT_SYNTHETIC_TRACKERS = 6,
    VT_BONES = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceData>> *devices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceData>> *>(VT_DEVICES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>> *synthetic_trackers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>> *>(VT_SYNTHETIC_TRACKERS);
  }
  /// This must represent a set, where there is no more than one bone for a `BodyPart`.
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::Bone>> *bones() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::Bone>> *>(VT_BONES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICES) &&
           verifier.VerifyVector(devices()) &&
           verifier.VerifyVectorOfTables(devices()) &&
           VerifyOffset(verifier, VT_SYNTHETIC_TRACKERS) &&
           verifier.VerifyVector(synthetic_trackers()) &&
           verifier.VerifyVectorOfTables(synthetic_trackers()) &&
           VerifyOffset(verifier, VT_BONES) &&
           verifier.VerifyVector(bones()) &&
           verifier.VerifyVectorOfTables(bones()) &&
           verifier.EndTable();
  }
};

struct DataFeedUpdateBuilder {
  typedef DataFeedUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_devices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceData>>> devices) {
    fbb_.AddOffset(DataFeedUpdate::VT_DEVICES, devices);
  }
  void add_synthetic_trackers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>>> synthetic_trackers) {
    fbb_.AddOffset(DataFeedUpdate::VT_SYNTHETIC_TRACKERS, synthetic_trackers);
  }
  void add_bones(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::Bone>>> bones) {
    fbb_.AddOffset(DataFeedUpdate::VT_BONES, bones);
  }
  explicit DataFeedUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataFeedUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFeedUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFeedUpdate> CreateDataFeedUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceData>>> devices = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>>> synthetic_trackers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::Bone>>> bones = 0) {
  DataFeedUpdateBuilder builder_(_fbb);
  builder_.add_bones(bones);
  builder_.add_synthetic_trackers(synthetic_trackers);
  builder_.add_devices(devices);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataFeedUpdate> CreateDataFeedUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceData>> *devices = nullptr,
    const std::vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>> *synthetic_trackers = nullptr,
    const std::vector<flatbuffers::Offset<solarxr_protocol::data_feed::Bone>> *bones = nullptr) {
  auto devices__ = devices ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceData>>(*devices) : 0;
  auto synthetic_trackers__ = synthetic_trackers ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>>(*synthetic_trackers) : 0;
  auto bones__ = bones ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::data_feed::Bone>>(*bones) : 0;
  return solarxr_protocol::data_feed::CreateDataFeedUpdate(
      _fbb,
      devices__,
      synthetic_trackers__,
      bones__);
}

/// All information related to the configuration of a data feed. This may be sent
/// as part of a `StartFeed`.
struct DataFeedConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataFeedConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINIMUM_TIME_SINCE_LAST = 4,
    VT_DATA_MASK = 6,
    VT_SYNTHETIC_TRACKERS_MASK = 8,
    VT_BONE_MASK = 10
  };
  /// Minimum delay in milliseconds between new data updates. This value will be
  /// ignored when used for a `PollDataFeed`.
  uint16_t minimum_time_since_last() const {
    return GetField<uint16_t>(VT_MINIMUM_TIME_SINCE_LAST, 0);
  }
  const solarxr_protocol::data_feed::device_data::DeviceDataMask *data_mask() const {
    return GetPointer<const solarxr_protocol::data_feed::device_data::DeviceDataMask *>(VT_DATA_MASK);
  }
  const solarxr_protocol::data_feed::tracker::TrackerDataMask *synthetic_trackers_mask() const {
    return GetPointer<const solarxr_protocol::data_feed::tracker::TrackerDataMask *>(VT_SYNTHETIC_TRACKERS_MASK);
  }
  bool bone_mask() const {
    return GetField<uint8_t>(VT_BONE_MASK, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MINIMUM_TIME_SINCE_LAST, 2) &&
           VerifyOffset(verifier, VT_DATA_MASK) &&
           verifier.VerifyTable(data_mask()) &&
           VerifyOffset(verifier, VT_SYNTHETIC_TRACKERS_MASK) &&
           verifier.VerifyTable(synthetic_trackers_mask()) &&
           VerifyField<uint8_t>(verifier, VT_BONE_MASK, 1) &&
           verifier.EndTable();
  }
};

struct DataFeedConfigBuilder {
  typedef DataFeedConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minimum_time_since_last(uint16_t minimum_time_since_last) {
    fbb_.AddElement<uint16_t>(DataFeedConfig::VT_MINIMUM_TIME_SINCE_LAST, minimum_time_since_last, 0);
  }
  void add_data_mask(flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceDataMask> data_mask) {
    fbb_.AddOffset(DataFeedConfig::VT_DATA_MASK, data_mask);
  }
  void add_synthetic_trackers_mask(flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerDataMask> synthetic_trackers_mask) {
    fbb_.AddOffset(DataFeedConfig::VT_SYNTHETIC_TRACKERS_MASK, synthetic_trackers_mask);
  }
  void add_bone_mask(bool bone_mask) {
    fbb_.AddElement<uint8_t>(DataFeedConfig::VT_BONE_MASK, static_cast<uint8_t>(bone_mask), 0);
  }
  explicit DataFeedConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataFeedConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFeedConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFeedConfig> CreateDataFeedConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t minimum_time_since_last = 0,
    flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceDataMask> data_mask = 0,
    flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerDataMask> synthetic_trackers_mask = 0,
    bool bone_mask = false) {
  DataFeedConfigBuilder builder_(_fbb);
  builder_.add_synthetic_trackers_mask(synthetic_trackers_mask);
  builder_.add_data_mask(data_mask);
  builder_.add_minimum_time_since_last(minimum_time_since_last);
  builder_.add_bone_mask(bone_mask);
  return builder_.Finish();
}

}  // namespace data_feed

namespace rpc {
namespace settings {

/// Settings for the skeletal model that are toggles.
struct ModelToggles FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelTogglesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXTENDED_SPINE = 4,
    VT_EXTENDED_PELVIS = 6,
    VT_EXTENDED_KNEE = 8,
    VT_FORCE_ARMS_FROM_HMD = 10,
    VT_FLOOR_CLIP = 12,
    VT_SKATING_CORRECTION = 14
  };
  flatbuffers::Optional<bool> extended_spine() const {
    return GetOptional<uint8_t, bool>(VT_EXTENDED_SPINE);
  }
  flatbuffers::Optional<bool> extended_pelvis() const {
    return GetOptional<uint8_t, bool>(VT_EXTENDED_PELVIS);
  }
  flatbuffers::Optional<bool> extended_knee() const {
    return GetOptional<uint8_t, bool>(VT_EXTENDED_KNEE);
  }
  flatbuffers::Optional<bool> force_arms_from_hmd() const {
    return GetOptional<uint8_t, bool>(VT_FORCE_ARMS_FROM_HMD);
  }
  flatbuffers::Optional<bool> floor_clip() const {
    return GetOptional<uint8_t, bool>(VT_FLOOR_CLIP);
  }
  flatbuffers::Optional<bool> skating_correction() const {
    return GetOptional<uint8_t, bool>(VT_SKATING_CORRECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXTENDED_SPINE, 1) &&
           VerifyField<uint8_t>(verifier, VT_EXTENDED_PELVIS, 1) &&
           VerifyField<uint8_t>(verifier, VT_EXTENDED_KNEE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FORCE_ARMS_FROM_HMD, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLOOR_CLIP, 1) &&
           VerifyField<uint8_t>(verifier, VT_SKATING_CORRECTION, 1) &&
           verifier.EndTable();
  }
};

struct ModelTogglesBuilder {
  typedef ModelToggles Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_extended_spine(bool extended_spine) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_EXTENDED_SPINE, static_cast<uint8_t>(extended_spine));
  }
  void add_extended_pelvis(bool extended_pelvis) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_EXTENDED_PELVIS, static_cast<uint8_t>(extended_pelvis));
  }
  void add_extended_knee(bool extended_knee) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_EXTENDED_KNEE, static_cast<uint8_t>(extended_knee));
  }
  void add_force_arms_from_hmd(bool force_arms_from_hmd) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_FORCE_ARMS_FROM_HMD, static_cast<uint8_t>(force_arms_from_hmd));
  }
  void add_floor_clip(bool floor_clip) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_FLOOR_CLIP, static_cast<uint8_t>(floor_clip));
  }
  void add_skating_correction(bool skating_correction) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_SKATING_CORRECTION, static_cast<uint8_t>(skating_correction));
  }
  explicit ModelTogglesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ModelToggles> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelToggles>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelToggles> CreateModelToggles(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<bool> extended_spine = flatbuffers::nullopt,
    flatbuffers::Optional<bool> extended_pelvis = flatbuffers::nullopt,
    flatbuffers::Optional<bool> extended_knee = flatbuffers::nullopt,
    flatbuffers::Optional<bool> force_arms_from_hmd = flatbuffers::nullopt,
    flatbuffers::Optional<bool> floor_clip = flatbuffers::nullopt,
    flatbuffers::Optional<bool> skating_correction = flatbuffers::nullopt) {
  ModelTogglesBuilder builder_(_fbb);
  if(skating_correction) { builder_.add_skating_correction(*skating_correction); }
  if(floor_clip) { builder_.add_floor_clip(*floor_clip); }
  if(force_arms_from_hmd) { builder_.add_force_arms_from_hmd(*force_arms_from_hmd); }
  if(extended_knee) { builder_.add_extended_knee(*extended_knee); }
  if(extended_pelvis) { builder_.add_extended_pelvis(*extended_pelvis); }
  if(extended_spine) { builder_.add_extended_spine(*extended_spine); }
  return builder_.Finish();
}

/// Settings for the skeletal model that are ratios.
/// These values range from 0 to 1.
struct ModelRatios FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelRatiosBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMPUTE_WAIST_FROM_CHEST_HIP = 4,
    VT_IMPUTE_WAIST_FROM_CHEST_LEGS = 6,
    VT_IMPUTE_HIP_FROM_CHEST_LEGS = 8,
    VT_IMPUTE_HIP_FROM_WAIST_LEGS = 10,
    VT_INTERP_HIP_LEGS = 12,
    VT_INTERP_KNEE_TRACKER_ANKLE = 14
  };
  flatbuffers::Optional<float> impute_waist_from_chest_hip() const {
    return GetOptional<float, float>(VT_IMPUTE_WAIST_FROM_CHEST_HIP);
  }
  flatbuffers::Optional<float> impute_waist_from_chest_legs() const {
    return GetOptional<float, float>(VT_IMPUTE_WAIST_FROM_CHEST_LEGS);
  }
  flatbuffers::Optional<float> impute_hip_from_chest_legs() const {
    return GetOptional<float, float>(VT_IMPUTE_HIP_FROM_CHEST_LEGS);
  }
  flatbuffers::Optional<float> impute_hip_from_waist_legs() const {
    return GetOptional<float, float>(VT_IMPUTE_HIP_FROM_WAIST_LEGS);
  }
  /// Hip's yaw and roll is set to the average of legs when 1.0
  flatbuffers::Optional<float> interp_hip_legs() const {
    return GetOptional<float, float>(VT_INTERP_HIP_LEGS);
  }
  /// Knee trackers' yaw and roll is set to the ankle's when 1.0
  flatbuffers::Optional<float> interp_knee_tracker_ankle() const {
    return GetOptional<float, float>(VT_INTERP_KNEE_TRACKER_ANKLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_IMPUTE_WAIST_FROM_CHEST_HIP, 4) &&
           VerifyField<float>(verifier, VT_IMPUTE_WAIST_FROM_CHEST_LEGS, 4) &&
           VerifyField<float>(verifier, VT_IMPUTE_HIP_FROM_CHEST_LEGS, 4) &&
           VerifyField<float>(verifier, VT_IMPUTE_HIP_FROM_WAIST_LEGS, 4) &&
           VerifyField<float>(verifier, VT_INTERP_HIP_LEGS, 4) &&
           VerifyField<float>(verifier, VT_INTERP_KNEE_TRACKER_ANKLE, 4) &&
           verifier.EndTable();
  }
};

struct ModelRatiosBuilder {
  typedef ModelRatios Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_impute_waist_from_chest_hip(float impute_waist_from_chest_hip) {
    fbb_.AddElement<float>(ModelRatios::VT_IMPUTE_WAIST_FROM_CHEST_HIP, impute_waist_from_chest_hip);
  }
  void add_impute_waist_from_chest_legs(float impute_waist_from_chest_legs) {
    fbb_.AddElement<float>(ModelRatios::VT_IMPUTE_WAIST_FROM_CHEST_LEGS, impute_waist_from_chest_legs);
  }
  void add_impute_hip_from_chest_legs(float impute_hip_from_chest_legs) {
    fbb_.AddElement<float>(ModelRatios::VT_IMPUTE_HIP_FROM_CHEST_LEGS, impute_hip_from_chest_legs);
  }
  void add_impute_hip_from_waist_legs(float impute_hip_from_waist_legs) {
    fbb_.AddElement<float>(ModelRatios::VT_IMPUTE_HIP_FROM_WAIST_LEGS, impute_hip_from_waist_legs);
  }
  void add_interp_hip_legs(float interp_hip_legs) {
    fbb_.AddElement<float>(ModelRatios::VT_INTERP_HIP_LEGS, interp_hip_legs);
  }
  void add_interp_knee_tracker_ankle(float interp_knee_tracker_ankle) {
    fbb_.AddElement<float>(ModelRatios::VT_INTERP_KNEE_TRACKER_ANKLE, interp_knee_tracker_ankle);
  }
  explicit ModelRatiosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ModelRatios> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelRatios>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelRatios> CreateModelRatios(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<float> impute_waist_from_chest_hip = flatbuffers::nullopt,
    flatbuffers::Optional<float> impute_waist_from_chest_legs = flatbuffers::nullopt,
    flatbuffers::Optional<float> impute_hip_from_chest_legs = flatbuffers::nullopt,
    flatbuffers::Optional<float> impute_hip_from_waist_legs = flatbuffers::nullopt,
    flatbuffers::Optional<float> interp_hip_legs = flatbuffers::nullopt,
    flatbuffers::Optional<float> interp_knee_tracker_ankle = flatbuffers::nullopt) {
  ModelRatiosBuilder builder_(_fbb);
  if(interp_knee_tracker_ankle) { builder_.add_interp_knee_tracker_ankle(*interp_knee_tracker_ankle); }
  if(interp_hip_legs) { builder_.add_interp_hip_legs(*interp_hip_legs); }
  if(impute_hip_from_waist_legs) { builder_.add_impute_hip_from_waist_legs(*impute_hip_from_waist_legs); }
  if(impute_hip_from_chest_legs) { builder_.add_impute_hip_from_chest_legs(*impute_hip_from_chest_legs); }
  if(impute_waist_from_chest_legs) { builder_.add_impute_waist_from_chest_legs(*impute_waist_from_chest_legs); }
  if(impute_waist_from_chest_hip) { builder_.add_impute_waist_from_chest_hip(*impute_waist_from_chest_hip); }
  return builder_.Finish();
}

/// Settings for the skeletal model.
struct ModelSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOGGLES = 4,
    VT_RATIOS = 6
  };
  const solarxr_protocol::rpc::settings::ModelToggles *toggles() const {
    return GetPointer<const solarxr_protocol::rpc::settings::ModelToggles *>(VT_TOGGLES);
  }
  const solarxr_protocol::rpc::settings::ModelRatios *ratios() const {
    return GetPointer<const solarxr_protocol::rpc::settings::ModelRatios *>(VT_RATIOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOGGLES) &&
           verifier.VerifyTable(toggles()) &&
           VerifyOffset(verifier, VT_RATIOS) &&
           verifier.VerifyTable(ratios()) &&
           verifier.EndTable();
  }
};

struct ModelSettingsBuilder {
  typedef ModelSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_toggles(flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelToggles> toggles) {
    fbb_.AddOffset(ModelSettings::VT_TOGGLES, toggles);
  }
  void add_ratios(flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelRatios> ratios) {
    fbb_.AddOffset(ModelSettings::VT_RATIOS, ratios);
  }
  explicit ModelSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ModelSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelSettings> CreateModelSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelToggles> toggles = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelRatios> ratios = 0) {
  ModelSettingsBuilder builder_(_fbb);
  builder_.add_ratios(ratios);
  builder_.add_toggles(toggles);
  return builder_.Finish();
}

}  // namespace settings

struct RpcMessageHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RpcMessageHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TX_ID = 4,
    VT_MESSAGE_TYPE = 6,
    VT_MESSAGE = 8
  };
  /// For a request, this identifies the request. For a response, this corresponds
  /// to the request that it is responding to.
  const solarxr_protocol::datatypes::TransactionId *tx_id() const {
    return GetStruct<const solarxr_protocol::datatypes::TransactionId *>(VT_TX_ID);
  }
  solarxr_protocol::rpc::RpcMessage message_type() const {
    return static_cast<solarxr_protocol::rpc::RpcMessage>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const solarxr_protocol::rpc::HeartbeatRequest *message_as_HeartbeatRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::HeartbeatRequest ? static_cast<const solarxr_protocol::rpc::HeartbeatRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::HeartbeatResponse *message_as_HeartbeatResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::HeartbeatResponse ? static_cast<const solarxr_protocol::rpc::HeartbeatResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::ResetRequest *message_as_ResetRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::ResetRequest ? static_cast<const solarxr_protocol::rpc::ResetRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::AssignTrackerRequest *message_as_AssignTrackerRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::AssignTrackerRequest ? static_cast<const solarxr_protocol::rpc::AssignTrackerRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SettingsRequest *message_as_SettingsRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SettingsRequest ? static_cast<const solarxr_protocol::rpc::SettingsRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SettingsResponse *message_as_SettingsResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SettingsResponse ? static_cast<const solarxr_protocol::rpc::SettingsResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::ChangeSettingsRequest *message_as_ChangeSettingsRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::ChangeSettingsRequest ? static_cast<const solarxr_protocol::rpc::ChangeSettingsRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::RecordBVHRequest *message_as_RecordBVHRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::RecordBVHRequest ? static_cast<const solarxr_protocol::rpc::RecordBVHRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::RecordBVHStatus *message_as_RecordBVHStatus() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::RecordBVHStatus ? static_cast<const solarxr_protocol::rpc::RecordBVHStatus *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SkeletonConfigRequest *message_as_SkeletonConfigRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SkeletonConfigRequest ? static_cast<const solarxr_protocol::rpc::SkeletonConfigRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::ChangeSkeletonConfigRequest *message_as_ChangeSkeletonConfigRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::ChangeSkeletonConfigRequest ? static_cast<const solarxr_protocol::rpc::ChangeSkeletonConfigRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SkeletonResetAllRequest *message_as_SkeletonResetAllRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SkeletonResetAllRequest ? static_cast<const solarxr_protocol::rpc::SkeletonResetAllRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SkeletonConfigResponse *message_as_SkeletonConfigResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SkeletonConfigResponse ? static_cast<const solarxr_protocol::rpc::SkeletonConfigResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::OpenSerialRequest *message_as_OpenSerialRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::OpenSerialRequest ? static_cast<const solarxr_protocol::rpc::OpenSerialRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::CloseSerialRequest *message_as_CloseSerialRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::CloseSerialRequest ? static_cast<const solarxr_protocol::rpc::CloseSerialRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SetWifiRequest *message_as_SetWifiRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SetWifiRequest ? static_cast<const solarxr_protocol::rpc::SetWifiRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SerialUpdateResponse *message_as_SerialUpdateResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SerialUpdateResponse ? static_cast<const solarxr_protocol::rpc::SerialUpdateResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::AutoBoneProcessRequest *message_as_AutoBoneProcessRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::AutoBoneProcessRequest ? static_cast<const solarxr_protocol::rpc::AutoBoneProcessRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::AutoBoneProcessStatusResponse *message_as_AutoBoneProcessStatusResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::AutoBoneProcessStatusResponse ? static_cast<const solarxr_protocol::rpc::AutoBoneProcessStatusResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::AutoBoneEpochResponse *message_as_AutoBoneEpochResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::AutoBoneEpochResponse ? static_cast<const solarxr_protocol::rpc::AutoBoneEpochResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::OverlayDisplayModeRequest *message_as_OverlayDisplayModeRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::OverlayDisplayModeRequest ? static_cast<const solarxr_protocol::rpc::OverlayDisplayModeRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::OverlayDisplayModeChangeRequest *message_as_OverlayDisplayModeChangeRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::OverlayDisplayModeChangeRequest ? static_cast<const solarxr_protocol::rpc::OverlayDisplayModeChangeRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::OverlayDisplayModeResponse *message_as_OverlayDisplayModeResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::OverlayDisplayModeResponse ? static_cast<const solarxr_protocol::rpc::OverlayDisplayModeResponse *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<solarxr_protocol::datatypes::TransactionId>(verifier, VT_TX_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyRpcMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::rpc::HeartbeatRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::HeartbeatRequest>() const {
  return message_as_HeartbeatRequest();
}

template<> inline const solarxr_protocol::rpc::HeartbeatResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::HeartbeatResponse>() const {
  return message_as_HeartbeatResponse();
}

template<> inline const solarxr_protocol::rpc::ResetRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::ResetRequest>() const {
  return message_as_ResetRequest();
}

template<> inline const solarxr_protocol::rpc::AssignTrackerRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::AssignTrackerRequest>() const {
  return message_as_AssignTrackerRequest();
}

template<> inline const solarxr_protocol::rpc::SettingsRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::SettingsRequest>() const {
  return message_as_SettingsRequest();
}

template<> inline const solarxr_protocol::rpc::SettingsResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::SettingsResponse>() const {
  return message_as_SettingsResponse();
}

template<> inline const solarxr_protocol::rpc::ChangeSettingsRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::ChangeSettingsRequest>() const {
  return message_as_ChangeSettingsRequest();
}

template<> inline const solarxr_protocol::rpc::RecordBVHRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::RecordBVHRequest>() const {
  return message_as_RecordBVHRequest();
}

template<> inline const solarxr_protocol::rpc::RecordBVHStatus *RpcMessageHeader::message_as<solarxr_protocol::rpc::RecordBVHStatus>() const {
  return message_as_RecordBVHStatus();
}

template<> inline const solarxr_protocol::rpc::SkeletonConfigRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::SkeletonConfigRequest>() const {
  return message_as_SkeletonConfigRequest();
}

template<> inline const solarxr_protocol::rpc::ChangeSkeletonConfigRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::ChangeSkeletonConfigRequest>() const {
  return message_as_ChangeSkeletonConfigRequest();
}

template<> inline const solarxr_protocol::rpc::SkeletonResetAllRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::SkeletonResetAllRequest>() const {
  return message_as_SkeletonResetAllRequest();
}

template<> inline const solarxr_protocol::rpc::SkeletonConfigResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::SkeletonConfigResponse>() const {
  return message_as_SkeletonConfigResponse();
}

template<> inline const solarxr_protocol::rpc::OpenSerialRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::OpenSerialRequest>() const {
  return message_as_OpenSerialRequest();
}

template<> inline const solarxr_protocol::rpc::CloseSerialRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::CloseSerialRequest>() const {
  return message_as_CloseSerialRequest();
}

template<> inline const solarxr_protocol::rpc::SetWifiRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::SetWifiRequest>() const {
  return message_as_SetWifiRequest();
}

template<> inline const solarxr_protocol::rpc::SerialUpdateResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::SerialUpdateResponse>() const {
  return message_as_SerialUpdateResponse();
}

template<> inline const solarxr_protocol::rpc::AutoBoneProcessRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::AutoBoneProcessRequest>() const {
  return message_as_AutoBoneProcessRequest();
}

template<> inline const solarxr_protocol::rpc::AutoBoneProcessStatusResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::AutoBoneProcessStatusResponse>() const {
  return message_as_AutoBoneProcessStatusResponse();
}

template<> inline const solarxr_protocol::rpc::AutoBoneEpochResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::AutoBoneEpochResponse>() const {
  return message_as_AutoBoneEpochResponse();
}

template<> inline const solarxr_protocol::rpc::OverlayDisplayModeRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::OverlayDisplayModeRequest>() const {
  return message_as_OverlayDisplayModeRequest();
}

template<> inline const solarxr_protocol::rpc::OverlayDisplayModeChangeRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::OverlayDisplayModeChangeRequest>() const {
  return message_as_OverlayDisplayModeChangeRequest();
}

template<> inline const solarxr_protocol::rpc::OverlayDisplayModeResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::OverlayDisplayModeResponse>() const {
  return message_as_OverlayDisplayModeResponse();
}

struct RpcMessageHeaderBuilder {
  typedef RpcMessageHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tx_id(const solarxr_protocol::datatypes::TransactionId *tx_id) {
    fbb_.AddStruct(RpcMessageHeader::VT_TX_ID, tx_id);
  }
  void add_message_type(solarxr_protocol::rpc::RpcMessage message_type) {
    fbb_.AddElement<uint8_t>(RpcMessageHeader::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(RpcMessageHeader::VT_MESSAGE, message);
  }
  explicit RpcMessageHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RpcMessageHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RpcMessageHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<RpcMessageHeader> CreateRpcMessageHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    const solarxr_protocol::datatypes::TransactionId *tx_id = nullptr,
    solarxr_protocol::rpc::RpcMessage message_type = solarxr_protocol::rpc::RpcMessage::NONE,
    flatbuffers::Offset<void> message = 0) {
  RpcMessageHeaderBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_tx_id(tx_id);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct HeartbeatRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeartbeatRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HeartbeatRequestBuilder {
  typedef HeartbeatRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HeartbeatRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HeartbeatRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeartbeatRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeartbeatRequest> CreateHeartbeatRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HeartbeatRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HeartbeatResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeartbeatResponseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HeartbeatResponseBuilder {
  typedef HeartbeatResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HeartbeatResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HeartbeatResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeartbeatResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeartbeatResponse> CreateHeartbeatResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HeartbeatResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ResetRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResetRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESET_TYPE = 4
  };
  solarxr_protocol::rpc::ResetType reset_type() const {
    return static_cast<solarxr_protocol::rpc::ResetType>(GetField<uint8_t>(VT_RESET_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESET_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct ResetRequestBuilder {
  typedef ResetRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reset_type(solarxr_protocol::rpc::ResetType reset_type) {
    fbb_.AddElement<uint8_t>(ResetRequest::VT_RESET_TYPE, static_cast<uint8_t>(reset_type), 0);
  }
  explicit ResetRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResetRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResetRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResetRequest> CreateResetRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::rpc::ResetType reset_type = solarxr_protocol::rpc::ResetType::Quick) {
  ResetRequestBuilder builder_(_fbb);
  builder_.add_reset_type(reset_type);
  return builder_.Finish();
}

struct ResetResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResetResponseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ResetResponseBuilder {
  typedef ResetResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ResetResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResetResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResetResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResetResponse> CreateResetResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ResetResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AssignTrackerRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssignTrackerRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACKER_ID = 4,
    VT_BODY_POSITION = 6,
    VT_MOUNTING_ROTATION = 8,
    VT_DISPLAY_NAME = 10
  };
  const solarxr_protocol::datatypes::TrackerId *tracker_id() const {
    return GetPointer<const solarxr_protocol::datatypes::TrackerId *>(VT_TRACKER_ID);
  }
  solarxr_protocol::datatypes::BodyPart body_position() const {
    return static_cast<solarxr_protocol::datatypes::BodyPart>(GetField<uint8_t>(VT_BODY_POSITION, 0));
  }
  const solarxr_protocol::datatypes::math::Quat *mounting_rotation() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_MOUNTING_ROTATION);
  }
  const flatbuffers::String *display_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACKER_ID) &&
           verifier.VerifyTable(tracker_id()) &&
           VerifyField<uint8_t>(verifier, VT_BODY_POSITION, 1) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_MOUNTING_ROTATION, 4) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           verifier.EndTable();
  }
};

struct AssignTrackerRequestBuilder {
  typedef AssignTrackerRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tracker_id(flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id) {
    fbb_.AddOffset(AssignTrackerRequest::VT_TRACKER_ID, tracker_id);
  }
  void add_body_position(solarxr_protocol::datatypes::BodyPart body_position) {
    fbb_.AddElement<uint8_t>(AssignTrackerRequest::VT_BODY_POSITION, static_cast<uint8_t>(body_position), 0);
  }
  void add_mounting_rotation(const solarxr_protocol::datatypes::math::Quat *mounting_rotation) {
    fbb_.AddStruct(AssignTrackerRequest::VT_MOUNTING_ROTATION, mounting_rotation);
  }
  void add_display_name(flatbuffers::Offset<flatbuffers::String> display_name) {
    fbb_.AddOffset(AssignTrackerRequest::VT_DISPLAY_NAME, display_name);
  }
  explicit AssignTrackerRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AssignTrackerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignTrackerRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignTrackerRequest> CreateAssignTrackerRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id = 0,
    solarxr_protocol::datatypes::BodyPart body_position = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::math::Quat *mounting_rotation = nullptr,
    flatbuffers::Offset<flatbuffers::String> display_name = 0) {
  AssignTrackerRequestBuilder builder_(_fbb);
  builder_.add_display_name(display_name);
  builder_.add_mounting_rotation(mounting_rotation);
  builder_.add_tracker_id(tracker_id);
  builder_.add_body_position(body_position);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssignTrackerRequest> CreateAssignTrackerRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id = 0,
    solarxr_protocol::datatypes::BodyPart body_position = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::math::Quat *mounting_rotation = nullptr,
    const char *display_name = nullptr) {
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  return solarxr_protocol::rpc::CreateAssignTrackerRequest(
      _fbb,
      tracker_id,
      body_position,
      mounting_rotation,
      display_name__);
}

struct SettingsRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SettingsRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SettingsRequestBuilder {
  typedef SettingsRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SettingsRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SettingsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SettingsRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SettingsRequest> CreateSettingsRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SettingsRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SettingsResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SettingsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEAM_VR_TRACKERS = 4,
    VT_FILTERING = 6,
    VT_MODEL_SETTINGS = 8
  };
  const solarxr_protocol::rpc::SteamVRTrackersSetting *steam_vr_trackers() const {
    return GetPointer<const solarxr_protocol::rpc::SteamVRTrackersSetting *>(VT_STEAM_VR_TRACKERS);
  }
  const solarxr_protocol::rpc::FilteringSettings *filtering() const {
    return GetPointer<const solarxr_protocol::rpc::FilteringSettings *>(VT_FILTERING);
  }
  const solarxr_protocol::rpc::settings::ModelSettings *model_settings() const {
    return GetPointer<const solarxr_protocol::rpc::settings::ModelSettings *>(VT_MODEL_SETTINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STEAM_VR_TRACKERS) &&
           verifier.VerifyTable(steam_vr_trackers()) &&
           VerifyOffset(verifier, VT_FILTERING) &&
           verifier.VerifyTable(filtering()) &&
           VerifyOffset(verifier, VT_MODEL_SETTINGS) &&
           verifier.VerifyTable(model_settings()) &&
           verifier.EndTable();
  }
};

struct SettingsResponseBuilder {
  typedef SettingsResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_steam_vr_trackers(flatbuffers::Offset<solarxr_protocol::rpc::SteamVRTrackersSetting> steam_vr_trackers) {
    fbb_.AddOffset(SettingsResponse::VT_STEAM_VR_TRACKERS, steam_vr_trackers);
  }
  void add_filtering(flatbuffers::Offset<solarxr_protocol::rpc::FilteringSettings> filtering) {
    fbb_.AddOffset(SettingsResponse::VT_FILTERING, filtering);
  }
  void add_model_settings(flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelSettings> model_settings) {
    fbb_.AddOffset(SettingsResponse::VT_MODEL_SETTINGS, model_settings);
  }
  explicit SettingsResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SettingsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SettingsResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SettingsResponse> CreateSettingsResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::rpc::SteamVRTrackersSetting> steam_vr_trackers = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::FilteringSettings> filtering = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelSettings> model_settings = 0) {
  SettingsResponseBuilder builder_(_fbb);
  builder_.add_model_settings(model_settings);
  builder_.add_filtering(filtering);
  builder_.add_steam_vr_trackers(steam_vr_trackers);
  return builder_.Finish();
}

struct ChangeSettingsRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChangeSettingsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEAM_VR_TRACKERS = 4,
    VT_FILTERING = 6,
    VT_MODEL_SETTINGS = 8
  };
  const solarxr_protocol::rpc::SteamVRTrackersSetting *steam_vr_trackers() const {
    return GetPointer<const solarxr_protocol::rpc::SteamVRTrackersSetting *>(VT_STEAM_VR_TRACKERS);
  }
  const solarxr_protocol::rpc::FilteringSettings *filtering() const {
    return GetPointer<const solarxr_protocol::rpc::FilteringSettings *>(VT_FILTERING);
  }
  const solarxr_protocol::rpc::settings::ModelSettings *model_settings() const {
    return GetPointer<const solarxr_protocol::rpc::settings::ModelSettings *>(VT_MODEL_SETTINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STEAM_VR_TRACKERS) &&
           verifier.VerifyTable(steam_vr_trackers()) &&
           VerifyOffset(verifier, VT_FILTERING) &&
           verifier.VerifyTable(filtering()) &&
           VerifyOffset(verifier, VT_MODEL_SETTINGS) &&
           verifier.VerifyTable(model_settings()) &&
           verifier.EndTable();
  }
};

struct ChangeSettingsRequestBuilder {
  typedef ChangeSettingsRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_steam_vr_trackers(flatbuffers::Offset<solarxr_protocol::rpc::SteamVRTrackersSetting> steam_vr_trackers) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_STEAM_VR_TRACKERS, steam_vr_trackers);
  }
  void add_filtering(flatbuffers::Offset<solarxr_protocol::rpc::FilteringSettings> filtering) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_FILTERING, filtering);
  }
  void add_model_settings(flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelSettings> model_settings) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_MODEL_SETTINGS, model_settings);
  }
  explicit ChangeSettingsRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ChangeSettingsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangeSettingsRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangeSettingsRequest> CreateChangeSettingsRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::rpc::SteamVRTrackersSetting> steam_vr_trackers = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::FilteringSettings> filtering = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelSettings> model_settings = 0) {
  ChangeSettingsRequestBuilder builder_(_fbb);
  builder_.add_model_settings(model_settings);
  builder_.add_filtering(filtering);
  builder_.add_steam_vr_trackers(steam_vr_trackers);
  return builder_.Finish();
}

struct SteamVRTrackersSetting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SteamVRTrackersSettingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WAIST = 4,
    VT_CHEST = 6,
    VT_LEGS = 8,
    VT_KNEES = 10,
    VT_ELBOWS = 12
  };
  bool waist() const {
    return GetField<uint8_t>(VT_WAIST, 0) != 0;
  }
  bool chest() const {
    return GetField<uint8_t>(VT_CHEST, 0) != 0;
  }
  bool legs() const {
    return GetField<uint8_t>(VT_LEGS, 0) != 0;
  }
  bool knees() const {
    return GetField<uint8_t>(VT_KNEES, 0) != 0;
  }
  bool elbows() const {
    return GetField<uint8_t>(VT_ELBOWS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_WAIST, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHEST, 1) &&
           VerifyField<uint8_t>(verifier, VT_LEGS, 1) &&
           VerifyField<uint8_t>(verifier, VT_KNEES, 1) &&
           VerifyField<uint8_t>(verifier, VT_ELBOWS, 1) &&
           verifier.EndTable();
  }
};

struct SteamVRTrackersSettingBuilder {
  typedef SteamVRTrackersSetting Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_waist(bool waist) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_WAIST, static_cast<uint8_t>(waist), 0);
  }
  void add_chest(bool chest) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_CHEST, static_cast<uint8_t>(chest), 0);
  }
  void add_legs(bool legs) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_LEGS, static_cast<uint8_t>(legs), 0);
  }
  void add_knees(bool knees) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_KNEES, static_cast<uint8_t>(knees), 0);
  }
  void add_elbows(bool elbows) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_ELBOWS, static_cast<uint8_t>(elbows), 0);
  }
  explicit SteamVRTrackersSettingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SteamVRTrackersSetting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SteamVRTrackersSetting>(end);
    return o;
  }
};

inline flatbuffers::Offset<SteamVRTrackersSetting> CreateSteamVRTrackersSetting(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool waist = false,
    bool chest = false,
    bool legs = false,
    bool knees = false,
    bool elbows = false) {
  SteamVRTrackersSettingBuilder builder_(_fbb);
  builder_.add_elbows(elbows);
  builder_.add_knees(knees);
  builder_.add_legs(legs);
  builder_.add_chest(chest);
  builder_.add_waist(waist);
  return builder_.Finish();
}

struct FilteringSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FilteringSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_AMOUNT = 6,
    VT_BUFFER = 8
  };
  solarxr_protocol::datatypes::FilteringType type() const {
    return static_cast<solarxr_protocol::datatypes::FilteringType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  float amount() const {
    return GetField<float>(VT_AMOUNT, 0.0f);
  }
  uint8_t buffer() const {
    return GetField<uint8_t>(VT_BUFFER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<float>(verifier, VT_AMOUNT, 4) &&
           VerifyField<uint8_t>(verifier, VT_BUFFER, 1) &&
           verifier.EndTable();
  }
};

struct FilteringSettingsBuilder {
  typedef FilteringSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(solarxr_protocol::datatypes::FilteringType type) {
    fbb_.AddElement<uint8_t>(FilteringSettings::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_amount(float amount) {
    fbb_.AddElement<float>(FilteringSettings::VT_AMOUNT, amount, 0.0f);
  }
  void add_buffer(uint8_t buffer) {
    fbb_.AddElement<uint8_t>(FilteringSettings::VT_BUFFER, buffer, 0);
  }
  explicit FilteringSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FilteringSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FilteringSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<FilteringSettings> CreateFilteringSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::FilteringType type = solarxr_protocol::datatypes::FilteringType::NONE,
    float amount = 0.0f,
    uint8_t buffer = 0) {
  FilteringSettingsBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_buffer(buffer);
  builder_.add_type(type);
  return builder_.Finish();
}

struct RecordBVHRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordBVHRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STOP = 4
  };
  bool stop() const {
    return GetField<uint8_t>(VT_STOP, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STOP, 1) &&
           verifier.EndTable();
  }
};

struct RecordBVHRequestBuilder {
  typedef RecordBVHRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stop(bool stop) {
    fbb_.AddElement<uint8_t>(RecordBVHRequest::VT_STOP, static_cast<uint8_t>(stop), 0);
  }
  explicit RecordBVHRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RecordBVHRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecordBVHRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecordBVHRequest> CreateRecordBVHRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool stop = false) {
  RecordBVHRequestBuilder builder_(_fbb);
  builder_.add_stop(stop);
  return builder_.Finish();
}

struct RecordBVHStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordBVHStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDING = 4
  };
  bool recording() const {
    return GetField<uint8_t>(VT_RECORDING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RECORDING, 1) &&
           verifier.EndTable();
  }
};

struct RecordBVHStatusBuilder {
  typedef RecordBVHStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_recording(bool recording) {
    fbb_.AddElement<uint8_t>(RecordBVHStatus::VT_RECORDING, static_cast<uint8_t>(recording), 0);
  }
  explicit RecordBVHStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RecordBVHStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecordBVHStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecordBVHStatus> CreateRecordBVHStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool recording = false) {
  RecordBVHStatusBuilder builder_(_fbb);
  builder_.add_recording(recording);
  return builder_.Finish();
}

struct SkeletonPart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkeletonPartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BONE = 4,
    VT_VALUE = 6
  };
  solarxr_protocol::rpc::SkeletonBone bone() const {
    return static_cast<solarxr_protocol::rpc::SkeletonBone>(GetField<uint8_t>(VT_BONE, 0));
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BONE, 1) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct SkeletonPartBuilder {
  typedef SkeletonPart Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bone(solarxr_protocol::rpc::SkeletonBone bone) {
    fbb_.AddElement<uint8_t>(SkeletonPart::VT_BONE, static_cast<uint8_t>(bone), 0);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(SkeletonPart::VT_VALUE, value, 0.0f);
  }
  explicit SkeletonPartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkeletonPart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkeletonPart>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkeletonPart> CreateSkeletonPart(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::rpc::SkeletonBone bone = solarxr_protocol::rpc::SkeletonBone::NONE,
    float value = 0.0f) {
  SkeletonPartBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_bone(bone);
  return builder_.Finish();
}

struct SkeletonConfigRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkeletonConfigRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SkeletonConfigRequestBuilder {
  typedef SkeletonConfigRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SkeletonConfigRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkeletonConfigRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkeletonConfigRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkeletonConfigRequest> CreateSkeletonConfigRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SkeletonConfigRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SkeletonConfigResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkeletonConfigResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKELETON_PARTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>> *skeleton_parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>> *>(VT_SKELETON_PARTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SKELETON_PARTS) &&
           verifier.VerifyVector(skeleton_parts()) &&
           verifier.VerifyVectorOfTables(skeleton_parts()) &&
           verifier.EndTable();
  }
};

struct SkeletonConfigResponseBuilder {
  typedef SkeletonConfigResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skeleton_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>>> skeleton_parts) {
    fbb_.AddOffset(SkeletonConfigResponse::VT_SKELETON_PARTS, skeleton_parts);
  }
  explicit SkeletonConfigResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkeletonConfigResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkeletonConfigResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkeletonConfigResponse> CreateSkeletonConfigResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>>> skeleton_parts = 0) {
  SkeletonConfigResponseBuilder builder_(_fbb);
  builder_.add_skeleton_parts(skeleton_parts);
  return builder_.Finish();
}

inline flatbuffers::Offset<SkeletonConfigResponse> CreateSkeletonConfigResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>> *skeleton_parts = nullptr) {
  auto skeleton_parts__ = skeleton_parts ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>>(*skeleton_parts) : 0;
  return solarxr_protocol::rpc::CreateSkeletonConfigResponse(
      _fbb,
      skeleton_parts__);
}

struct SkeletonResetAllRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkeletonResetAllRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SkeletonResetAllRequestBuilder {
  typedef SkeletonResetAllRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SkeletonResetAllRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkeletonResetAllRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkeletonResetAllRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkeletonResetAllRequest> CreateSkeletonResetAllRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SkeletonResetAllRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ChangeSkeletonConfigRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChangeSkeletonConfigRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BONE = 4,
    VT_VALUE = 6
  };
  solarxr_protocol::rpc::SkeletonBone bone() const {
    return static_cast<solarxr_protocol::rpc::SkeletonBone>(GetField<uint8_t>(VT_BONE, 0));
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BONE, 1) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct ChangeSkeletonConfigRequestBuilder {
  typedef ChangeSkeletonConfigRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bone(solarxr_protocol::rpc::SkeletonBone bone) {
    fbb_.AddElement<uint8_t>(ChangeSkeletonConfigRequest::VT_BONE, static_cast<uint8_t>(bone), 0);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(ChangeSkeletonConfigRequest::VT_VALUE, value, 0.0f);
  }
  explicit ChangeSkeletonConfigRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ChangeSkeletonConfigRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangeSkeletonConfigRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangeSkeletonConfigRequest> CreateChangeSkeletonConfigRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::rpc::SkeletonBone bone = solarxr_protocol::rpc::SkeletonBone::NONE,
    float value = 0.0f) {
  ChangeSkeletonConfigRequestBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_bone(bone);
  return builder_.Finish();
}

struct OpenSerialRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpenSerialRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OpenSerialRequestBuilder {
  typedef OpenSerialRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OpenSerialRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OpenSerialRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpenSerialRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpenSerialRequest> CreateOpenSerialRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OpenSerialRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CloseSerialRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CloseSerialRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CloseSerialRequestBuilder {
  typedef CloseSerialRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CloseSerialRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CloseSerialRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CloseSerialRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CloseSerialRequest> CreateCloseSerialRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CloseSerialRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SetWifiRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetWifiRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSID = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *ssid() const {
    return GetPointer<const flatbuffers::String *>(VT_SSID);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SSID) &&
           verifier.VerifyString(ssid()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           verifier.EndTable();
  }
};

struct SetWifiRequestBuilder {
  typedef SetWifiRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ssid(flatbuffers::Offset<flatbuffers::String> ssid) {
    fbb_.AddOffset(SetWifiRequest::VT_SSID, ssid);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(SetWifiRequest::VT_PASSWORD, password);
  }
  explicit SetWifiRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SetWifiRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetWifiRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetWifiRequest> CreateSetWifiRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ssid = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  SetWifiRequestBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_ssid(ssid);
  return builder_.Finish();
}

inline flatbuffers::Offset<SetWifiRequest> CreateSetWifiRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ssid = nullptr,
    const char *password = nullptr) {
  auto ssid__ = ssid ? _fbb.CreateString(ssid) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return solarxr_protocol::rpc::CreateSetWifiRequest(
      _fbb,
      ssid__,
      password__);
}

struct SerialUpdateResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerialUpdateResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOG = 4,
    VT_CLOSED = 6
  };
  const flatbuffers::String *log() const {
    return GetPointer<const flatbuffers::String *>(VT_LOG);
  }
  bool closed() const {
    return GetField<uint8_t>(VT_CLOSED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOG) &&
           verifier.VerifyString(log()) &&
           VerifyField<uint8_t>(verifier, VT_CLOSED, 1) &&
           verifier.EndTable();
  }
};

struct SerialUpdateResponseBuilder {
  typedef SerialUpdateResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_log(flatbuffers::Offset<flatbuffers::String> log) {
    fbb_.AddOffset(SerialUpdateResponse::VT_LOG, log);
  }
  void add_closed(bool closed) {
    fbb_.AddElement<uint8_t>(SerialUpdateResponse::VT_CLOSED, static_cast<uint8_t>(closed), 0);
  }
  explicit SerialUpdateResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SerialUpdateResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerialUpdateResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerialUpdateResponse> CreateSerialUpdateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> log = 0,
    bool closed = false) {
  SerialUpdateResponseBuilder builder_(_fbb);
  builder_.add_log(log);
  builder_.add_closed(closed);
  return builder_.Finish();
}

inline flatbuffers::Offset<SerialUpdateResponse> CreateSerialUpdateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *log = nullptr,
    bool closed = false) {
  auto log__ = log ? _fbb.CreateString(log) : 0;
  return solarxr_protocol::rpc::CreateSerialUpdateResponse(
      _fbb,
      log__,
      closed);
}

struct AutoBoneProcessRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoBoneProcessRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROCESS_TYPE = 4
  };
  solarxr_protocol::rpc::AutoBoneProcessType process_type() const {
    return static_cast<solarxr_protocol::rpc::AutoBoneProcessType>(GetField<uint8_t>(VT_PROCESS_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PROCESS_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct AutoBoneProcessRequestBuilder {
  typedef AutoBoneProcessRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_process_type(solarxr_protocol::rpc::AutoBoneProcessType process_type) {
    fbb_.AddElement<uint8_t>(AutoBoneProcessRequest::VT_PROCESS_TYPE, static_cast<uint8_t>(process_type), 0);
  }
  explicit AutoBoneProcessRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AutoBoneProcessRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoBoneProcessRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoBoneProcessRequest> CreateAutoBoneProcessRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::rpc::AutoBoneProcessType process_type = solarxr_protocol::rpc::AutoBoneProcessType::NONE) {
  AutoBoneProcessRequestBuilder builder_(_fbb);
  builder_.add_process_type(process_type);
  return builder_.Finish();
}

struct AutoBoneProcessStatusResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoBoneProcessStatusResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROCESS_TYPE = 4,
    VT_MESSAGE = 6,
    VT_CURRENT = 8,
    VT_TOTAL = 10,
    VT_COMPLETED = 12,
    VT_SUCCESS = 14
  };
  solarxr_protocol::rpc::AutoBoneProcessType process_type() const {
    return static_cast<solarxr_protocol::rpc::AutoBoneProcessType>(GetField<uint8_t>(VT_PROCESS_TYPE, 0));
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  uint32_t current() const {
    return GetField<uint32_t>(VT_CURRENT, 0);
  }
  uint32_t total() const {
    return GetField<uint32_t>(VT_TOTAL, 0);
  }
  bool completed() const {
    return GetField<uint8_t>(VT_COMPLETED, 0) != 0;
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PROCESS_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyField<uint32_t>(verifier, VT_CURRENT, 4) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL, 4) &&
           VerifyField<uint8_t>(verifier, VT_COMPLETED, 1) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
};

struct AutoBoneProcessStatusResponseBuilder {
  typedef AutoBoneProcessStatusResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_process_type(solarxr_protocol::rpc::AutoBoneProcessType process_type) {
    fbb_.AddElement<uint8_t>(AutoBoneProcessStatusResponse::VT_PROCESS_TYPE, static_cast<uint8_t>(process_type), 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(AutoBoneProcessStatusResponse::VT_MESSAGE, message);
  }
  void add_current(uint32_t current) {
    fbb_.AddElement<uint32_t>(AutoBoneProcessStatusResponse::VT_CURRENT, current, 0);
  }
  void add_total(uint32_t total) {
    fbb_.AddElement<uint32_t>(AutoBoneProcessStatusResponse::VT_TOTAL, total, 0);
  }
  void add_completed(bool completed) {
    fbb_.AddElement<uint8_t>(AutoBoneProcessStatusResponse::VT_COMPLETED, static_cast<uint8_t>(completed), 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(AutoBoneProcessStatusResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit AutoBoneProcessStatusResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AutoBoneProcessStatusResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoBoneProcessStatusResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoBoneProcessStatusResponse> CreateAutoBoneProcessStatusResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::rpc::AutoBoneProcessType process_type = solarxr_protocol::rpc::AutoBoneProcessType::NONE,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    uint32_t current = 0,
    uint32_t total = 0,
    bool completed = false,
    bool success = false) {
  AutoBoneProcessStatusResponseBuilder builder_(_fbb);
  builder_.add_total(total);
  builder_.add_current(current);
  builder_.add_message(message);
  builder_.add_success(success);
  builder_.add_completed(completed);
  builder_.add_process_type(process_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AutoBoneProcessStatusResponse> CreateAutoBoneProcessStatusResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::rpc::AutoBoneProcessType process_type = solarxr_protocol::rpc::AutoBoneProcessType::NONE,
    const char *message = nullptr,
    uint32_t current = 0,
    uint32_t total = 0,
    bool completed = false,
    bool success = false) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return solarxr_protocol::rpc::CreateAutoBoneProcessStatusResponse(
      _fbb,
      process_type,
      message__,
      current,
      total,
      completed,
      success);
}

struct AutoBoneEpochResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoBoneEpochResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURRENT_EPOCH = 4,
    VT_TOTAL_EPOCHS = 6,
    VT_EPOCH_ERROR = 8,
    VT_ADJUSTED_SKELETON_PARTS = 10
  };
  uint32_t current_epoch() const {
    return GetField<uint32_t>(VT_CURRENT_EPOCH, 0);
  }
  uint32_t total_epochs() const {
    return GetField<uint32_t>(VT_TOTAL_EPOCHS, 0);
  }
  float epoch_error() const {
    return GetField<float>(VT_EPOCH_ERROR, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>> *adjusted_skeleton_parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>> *>(VT_ADJUSTED_SKELETON_PARTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CURRENT_EPOCH, 4) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_EPOCHS, 4) &&
           VerifyField<float>(verifier, VT_EPOCH_ERROR, 4) &&
           VerifyOffset(verifier, VT_ADJUSTED_SKELETON_PARTS) &&
           verifier.VerifyVector(adjusted_skeleton_parts()) &&
           verifier.VerifyVectorOfTables(adjusted_skeleton_parts()) &&
           verifier.EndTable();
  }
};

struct AutoBoneEpochResponseBuilder {
  typedef AutoBoneEpochResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_current_epoch(uint32_t current_epoch) {
    fbb_.AddElement<uint32_t>(AutoBoneEpochResponse::VT_CURRENT_EPOCH, current_epoch, 0);
  }
  void add_total_epochs(uint32_t total_epochs) {
    fbb_.AddElement<uint32_t>(AutoBoneEpochResponse::VT_TOTAL_EPOCHS, total_epochs, 0);
  }
  void add_epoch_error(float epoch_error) {
    fbb_.AddElement<float>(AutoBoneEpochResponse::VT_EPOCH_ERROR, epoch_error, 0.0f);
  }
  void add_adjusted_skeleton_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>>> adjusted_skeleton_parts) {
    fbb_.AddOffset(AutoBoneEpochResponse::VT_ADJUSTED_SKELETON_PARTS, adjusted_skeleton_parts);
  }
  explicit AutoBoneEpochResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AutoBoneEpochResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoBoneEpochResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoBoneEpochResponse> CreateAutoBoneEpochResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t current_epoch = 0,
    uint32_t total_epochs = 0,
    float epoch_error = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>>> adjusted_skeleton_parts = 0) {
  AutoBoneEpochResponseBuilder builder_(_fbb);
  builder_.add_adjusted_skeleton_parts(adjusted_skeleton_parts);
  builder_.add_epoch_error(epoch_error);
  builder_.add_total_epochs(total_epochs);
  builder_.add_current_epoch(current_epoch);
  return builder_.Finish();
}

inline flatbuffers::Offset<AutoBoneEpochResponse> CreateAutoBoneEpochResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t current_epoch = 0,
    uint32_t total_epochs = 0,
    float epoch_error = 0.0f,
    const std::vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>> *adjusted_skeleton_parts = nullptr) {
  auto adjusted_skeleton_parts__ = adjusted_skeleton_parts ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>>(*adjusted_skeleton_parts) : 0;
  return solarxr_protocol::rpc::CreateAutoBoneEpochResponse(
      _fbb,
      current_epoch,
      total_epochs,
      epoch_error,
      adjusted_skeleton_parts__);
}

/// Requests the current state of `OverlayDisplayModeResponse`.
struct OverlayDisplayModeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OverlayDisplayModeRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OverlayDisplayModeRequestBuilder {
  typedef OverlayDisplayModeRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OverlayDisplayModeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OverlayDisplayModeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OverlayDisplayModeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OverlayDisplayModeRequest> CreateOverlayDisplayModeRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OverlayDisplayModeRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Changes the state of the overlay's display mode.
struct OverlayDisplayModeChangeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OverlayDisplayModeChangeRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_VISIBLE = 4,
    VT_IS_MIRRORED = 6
  };
  flatbuffers::Optional<bool> is_visible() const {
    return GetOptional<uint8_t, bool>(VT_IS_VISIBLE);
  }
  flatbuffers::Optional<bool> is_mirrored() const {
    return GetOptional<uint8_t, bool>(VT_IS_MIRRORED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_VISIBLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_MIRRORED, 1) &&
           verifier.EndTable();
  }
};

struct OverlayDisplayModeChangeRequestBuilder {
  typedef OverlayDisplayModeChangeRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_visible(bool is_visible) {
    fbb_.AddElement<uint8_t>(OverlayDisplayModeChangeRequest::VT_IS_VISIBLE, static_cast<uint8_t>(is_visible));
  }
  void add_is_mirrored(bool is_mirrored) {
    fbb_.AddElement<uint8_t>(OverlayDisplayModeChangeRequest::VT_IS_MIRRORED, static_cast<uint8_t>(is_mirrored));
  }
  explicit OverlayDisplayModeChangeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OverlayDisplayModeChangeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OverlayDisplayModeChangeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OverlayDisplayModeChangeRequest> CreateOverlayDisplayModeChangeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<bool> is_visible = flatbuffers::nullopt,
    flatbuffers::Optional<bool> is_mirrored = flatbuffers::nullopt) {
  OverlayDisplayModeChangeRequestBuilder builder_(_fbb);
  if(is_mirrored) { builder_.add_is_mirrored(*is_mirrored); }
  if(is_visible) { builder_.add_is_visible(*is_visible); }
  return builder_.Finish();
}

/// The current state of the overlay's display mode.
struct OverlayDisplayModeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OverlayDisplayModeResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_VISIBLE = 4,
    VT_IS_MIRRORED = 6
  };
  bool is_visible() const {
    return GetField<uint8_t>(VT_IS_VISIBLE, 0) != 0;
  }
  bool is_mirrored() const {
    return GetField<uint8_t>(VT_IS_MIRRORED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_VISIBLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_MIRRORED, 1) &&
           verifier.EndTable();
  }
};

struct OverlayDisplayModeResponseBuilder {
  typedef OverlayDisplayModeResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_visible(bool is_visible) {
    fbb_.AddElement<uint8_t>(OverlayDisplayModeResponse::VT_IS_VISIBLE, static_cast<uint8_t>(is_visible), 0);
  }
  void add_is_mirrored(bool is_mirrored) {
    fbb_.AddElement<uint8_t>(OverlayDisplayModeResponse::VT_IS_MIRRORED, static_cast<uint8_t>(is_mirrored), 0);
  }
  explicit OverlayDisplayModeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OverlayDisplayModeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OverlayDisplayModeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<OverlayDisplayModeResponse> CreateOverlayDisplayModeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_visible = false,
    bool is_mirrored = false) {
  OverlayDisplayModeResponseBuilder builder_(_fbb);
  builder_.add_is_mirrored(is_mirrored);
  builder_.add_is_visible(is_visible);
  return builder_.Finish();
}

}  // namespace rpc

/// MessageBundle contains all of the messages for the data feed system and the
/// rpc system that will be sent in one buffer.
struct MessageBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_FEED_MSGS = 4,
    VT_RPC_MSGS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>> *data_feed_msgs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>> *>(VT_DATA_FEED_MSGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>> *rpc_msgs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>> *>(VT_RPC_MSGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA_FEED_MSGS) &&
           verifier.VerifyVector(data_feed_msgs()) &&
           verifier.VerifyVectorOfTables(data_feed_msgs()) &&
           VerifyOffset(verifier, VT_RPC_MSGS) &&
           verifier.VerifyVector(rpc_msgs()) &&
           verifier.VerifyVectorOfTables(rpc_msgs()) &&
           verifier.EndTable();
  }
};

struct MessageBundleBuilder {
  typedef MessageBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_feed_msgs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>>> data_feed_msgs) {
    fbb_.AddOffset(MessageBundle::VT_DATA_FEED_MSGS, data_feed_msgs);
  }
  void add_rpc_msgs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>>> rpc_msgs) {
    fbb_.AddOffset(MessageBundle::VT_RPC_MSGS, rpc_msgs);
  }
  explicit MessageBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MessageBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageBundle> CreateMessageBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>>> data_feed_msgs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>>> rpc_msgs = 0) {
  MessageBundleBuilder builder_(_fbb);
  builder_.add_rpc_msgs(rpc_msgs);
  builder_.add_data_feed_msgs(data_feed_msgs);
  return builder_.Finish();
}

inline flatbuffers::Offset<MessageBundle> CreateMessageBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>> *data_feed_msgs = nullptr,
    const std::vector<flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>> *rpc_msgs = nullptr) {
  auto data_feed_msgs__ = data_feed_msgs ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>>(*data_feed_msgs) : 0;
  auto rpc_msgs__ = rpc_msgs ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>>(*rpc_msgs) : 0;
  return solarxr_protocol::CreateMessageBundle(
      _fbb,
      data_feed_msgs__,
      rpc_msgs__);
}

namespace datatypes {

namespace hardware_info {

}  // namespace hardware_info
}  // namespace datatypes

namespace data_feed {
namespace tracker {

}  // namespace tracker

namespace device_data {

}  // namespace device_data

}  // namespace data_feed

namespace rpc {
namespace settings {

}  // namespace settings

}  // namespace rpc

namespace data_feed {

inline bool VerifyDataFeedMessage(flatbuffers::Verifier &verifier, const void *obj, DataFeedMessage type) {
  switch (type) {
    case DataFeedMessage::NONE: {
      return true;
    }
    case DataFeedMessage::PollDataFeed: {
      auto ptr = reinterpret_cast<const solarxr_protocol::data_feed::PollDataFeed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataFeedMessage::StartDataFeed: {
      auto ptr = reinterpret_cast<const solarxr_protocol::data_feed::StartDataFeed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataFeedMessage::DataFeedUpdate: {
      auto ptr = reinterpret_cast<const solarxr_protocol::data_feed::DataFeedUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataFeedMessage::DataFeedConfig: {
      auto ptr = reinterpret_cast<const solarxr_protocol::data_feed::DataFeedConfig *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDataFeedMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<DataFeedMessage> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDataFeedMessage(
        verifier,  values->Get(i), types->GetEnum<DataFeedMessage>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace data_feed

namespace rpc {

inline bool VerifyRpcMessage(flatbuffers::Verifier &verifier, const void *obj, RpcMessage type) {
  switch (type) {
    case RpcMessage::NONE: {
      return true;
    }
    case RpcMessage::HeartbeatRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::HeartbeatRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::HeartbeatResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::HeartbeatResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::ResetRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::ResetRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AssignTrackerRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::AssignTrackerRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SettingsRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SettingsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SettingsResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SettingsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::ChangeSettingsRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::ChangeSettingsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::RecordBVHRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::RecordBVHRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::RecordBVHStatus: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::RecordBVHStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SkeletonConfigRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SkeletonConfigRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::ChangeSkeletonConfigRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::ChangeSkeletonConfigRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SkeletonResetAllRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SkeletonResetAllRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SkeletonConfigResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SkeletonConfigResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::OpenSerialRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::OpenSerialRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::CloseSerialRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::CloseSerialRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SetWifiRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SetWifiRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SerialUpdateResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SerialUpdateResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AutoBoneProcessRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::AutoBoneProcessRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AutoBoneProcessStatusResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::AutoBoneProcessStatusResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AutoBoneEpochResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::AutoBoneEpochResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::OverlayDisplayModeRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::OverlayDisplayModeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::OverlayDisplayModeChangeRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::OverlayDisplayModeChangeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::OverlayDisplayModeResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::OverlayDisplayModeResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRpcMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<RpcMessage> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRpcMessage(
        verifier,  values->Get(i), types->GetEnum<RpcMessage>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace rpc
}  // namespace solarxr_protocol

#endif  // FLATBUFFERS_GENERATED_ALL_SOLARXR_PROTOCOL_H_
