// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ALL_SOLARXR_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_ALL_SOLARXR_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 10 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace solarxr_protocol {
namespace datatypes {

struct HzF32;

struct TransactionId;

struct DeviceId;

struct TrackerId;
struct TrackerIdBuilder;

struct LogData;
struct LogDataBuilder;

struct Temperature;

struct Ipv4Address;

struct Bytes;
struct BytesBuilder;

struct StringTable;
struct StringTableBuilder;

namespace hardware_info {

struct HardwareAddress;

struct HardwareInfo;
struct HardwareInfoBuilder;

struct HardwareStatus;
struct HardwareStatusBuilder;

struct FirmwareStatusMask;
struct FirmwareStatusMaskBuilder;

}  // namespace hardware_info

namespace math {

struct Quat;

struct Vec3f;

}  // namespace math
}  // namespace datatypes

namespace data_feed {
namespace tracker {

struct TrackerData;
struct TrackerDataBuilder;

struct TrackerDataMask;
struct TrackerDataMaskBuilder;

struct TrackerInfo;
struct TrackerInfoBuilder;

}  // namespace tracker

namespace device_data {

struct DeviceDataMask;
struct DeviceDataMaskBuilder;

struct DeviceData;
struct DeviceDataBuilder;

}  // namespace device_data

struct Bone;
struct BoneBuilder;

struct DataFeedMessageHeader;
struct DataFeedMessageHeaderBuilder;

struct PollDataFeed;
struct PollDataFeedBuilder;

struct StartDataFeed;
struct StartDataFeedBuilder;

struct DataFeedUpdate;
struct DataFeedUpdateBuilder;

struct DataFeedConfig;
struct DataFeedConfigBuilder;

}  // namespace data_feed

namespace rpc {
namespace settings {

struct ModelToggles;
struct ModelTogglesBuilder;

struct ModelRatios;
struct ModelRatiosBuilder;

struct LegTweaksSettings;
struct LegTweaksSettingsBuilder;

struct ModelSettings;
struct ModelSettingsBuilder;

}  // namespace settings

struct RpcMessageHeader;
struct RpcMessageHeaderBuilder;

struct HeartbeatRequest;
struct HeartbeatRequestBuilder;

struct HeartbeatResponse;
struct HeartbeatResponseBuilder;

struct ResetRequest;
struct ResetRequestBuilder;

struct ResetResponse;
struct ResetResponseBuilder;

struct AssignTrackerRequest;
struct AssignTrackerRequestBuilder;

struct ClearDriftCompensationRequest;
struct ClearDriftCompensationRequestBuilder;

struct SettingsRequest;
struct SettingsRequestBuilder;

struct SettingsResponse;
struct SettingsResponseBuilder;

struct ChangeSettingsRequest;
struct ChangeSettingsRequestBuilder;

struct SteamVRTrackersSetting;
struct SteamVRTrackersSettingBuilder;

struct FilteringSettings;
struct FilteringSettingsBuilder;

struct DriftCompensationSettings;
struct DriftCompensationSettingsBuilder;

struct OSCRouterSettings;
struct OSCRouterSettingsBuilder;

struct VRCOSCSettings;
struct VRCOSCSettingsBuilder;

struct VMCOSCSettings;
struct VMCOSCSettingsBuilder;

struct OSCSettings;
struct OSCSettingsBuilder;

struct OSCTrackersSetting;
struct OSCTrackersSettingBuilder;

struct TapDetectionSettings;
struct TapDetectionSettingsBuilder;

struct TapDetectionSetupNotification;
struct TapDetectionSetupNotificationBuilder;

struct RecordBVHRequest;
struct RecordBVHRequestBuilder;

struct RecordBVHStatus;
struct RecordBVHStatusBuilder;

struct SkeletonPart;
struct SkeletonPartBuilder;

struct SkeletonConfigRequest;
struct SkeletonConfigRequestBuilder;

struct SkeletonConfigResponse;
struct SkeletonConfigResponseBuilder;

struct SkeletonResetAllRequest;
struct SkeletonResetAllRequestBuilder;

struct ChangeSkeletonConfigRequest;
struct ChangeSkeletonConfigRequestBuilder;

struct SerialDevice;
struct SerialDeviceBuilder;

struct OpenSerialRequest;
struct OpenSerialRequestBuilder;

struct CloseSerialRequest;
struct CloseSerialRequestBuilder;

struct SetWifiRequest;
struct SetWifiRequestBuilder;

struct SerialUpdateResponse;
struct SerialUpdateResponseBuilder;

struct SerialTrackerRebootRequest;
struct SerialTrackerRebootRequestBuilder;

struct SerialTrackerGetInfoRequest;
struct SerialTrackerGetInfoRequestBuilder;

struct SerialTrackerFactoryResetRequest;
struct SerialTrackerFactoryResetRequestBuilder;

struct SerialDevicesRequest;
struct SerialDevicesRequestBuilder;

struct SerialDevicesResponse;
struct SerialDevicesResponseBuilder;

struct NewSerialDeviceResponse;
struct NewSerialDeviceResponseBuilder;

struct StartWifiProvisioningRequest;
struct StartWifiProvisioningRequestBuilder;

struct StopWifiProvisioningRequest;
struct StopWifiProvisioningRequestBuilder;

struct WifiProvisioningStatusResponse;
struct WifiProvisioningStatusResponseBuilder;

struct AutoBoneProcessRequest;
struct AutoBoneProcessRequestBuilder;

struct AutoBoneProcessStatusResponse;
struct AutoBoneProcessStatusResponseBuilder;

struct AutoBoneEpochResponse;
struct AutoBoneEpochResponseBuilder;

struct AutoBoneSettings;
struct AutoBoneSettingsBuilder;

struct HeightRequest;
struct HeightRequestBuilder;

struct HeightResponse;
struct HeightResponseBuilder;

struct AutoBoneApplyRequest;
struct AutoBoneApplyRequestBuilder;

struct AutoBoneStopRecordingRequest;
struct AutoBoneStopRecordingRequestBuilder;

struct AutoBoneCancelRecordingRequest;
struct AutoBoneCancelRecordingRequestBuilder;

struct OverlayDisplayModeRequest;
struct OverlayDisplayModeRequestBuilder;

struct OverlayDisplayModeChangeRequest;
struct OverlayDisplayModeChangeRequestBuilder;

struct OverlayDisplayModeResponse;
struct OverlayDisplayModeResponseBuilder;

struct ServerInfosRequest;
struct ServerInfosRequestBuilder;

struct ServerInfosResponse;
struct ServerInfosResponseBuilder;

struct LegTweaksTmpChange;
struct LegTweaksTmpChangeBuilder;

struct LegTweaksTmpClear;
struct LegTweaksTmpClearBuilder;

struct StatusTrackerReset;
struct StatusTrackerResetBuilder;

struct StatusTrackerError;
struct StatusTrackerErrorBuilder;

struct StatusSteamVRDisconnected;
struct StatusSteamVRDisconnectedBuilder;

struct StatusSystemRequest;
struct StatusSystemRequestBuilder;

struct StatusSystemResponse;
struct StatusSystemResponseBuilder;

struct StatusSystemUpdate;
struct StatusSystemUpdateBuilder;

struct StatusSystemFixed;
struct StatusSystemFixedBuilder;

struct StatusMessage;
struct StatusMessageBuilder;

struct SetPauseTrackingRequest;
struct SetPauseTrackingRequestBuilder;

struct ClearMountingResetRequest;
struct ClearMountingResetRequestBuilder;

}  // namespace rpc

namespace pub_sub {

struct TopicId;
struct TopicIdBuilder;

struct TopicHandle;
struct TopicHandleBuilder;

struct TopicMapping;
struct TopicMappingBuilder;

struct TopicHandleRequest;
struct TopicHandleRequestBuilder;

struct SubscriptionRequest;
struct SubscriptionRequestBuilder;

struct PubSubHeader;
struct PubSubHeaderBuilder;

struct Message;
struct MessageBuilder;

struct KeyValues;
struct KeyValuesBuilder;

}  // namespace pub_sub

struct MessageBundle;
struct MessageBundleBuilder;

namespace datatypes {

/// A list of error codes for error conditions on the device
enum class FirmwareErrorCode : uint8_t {
  Other = 0,
  Disconnected = 1,
  Occluded = 2,
  ImuError = 3,
  MIN = Other,
  MAX = ImuError
};

inline const FirmwareErrorCode (&EnumValuesFirmwareErrorCode())[4] {
  static const FirmwareErrorCode values[] = {
    FirmwareErrorCode::Other,
    FirmwareErrorCode::Disconnected,
    FirmwareErrorCode::Occluded,
    FirmwareErrorCode::ImuError
  };
  return values;
}

inline const char * const *EnumNamesFirmwareErrorCode() {
  static const char * const names[5] = {
    "Other",
    "Disconnected",
    "Occluded",
    "ImuError",
    nullptr
  };
  return names;
}

inline const char *EnumNameFirmwareErrorCode(FirmwareErrorCode e) {
  if (flatbuffers::IsOutRange(e, FirmwareErrorCode::Other, FirmwareErrorCode::ImuError)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFirmwareErrorCode()[index];
}

/// Used for filtering tracker rotations in software
enum class FilteringType : uint8_t {
  NONE = 0,
  SMOOTHING = 1,
  PREDICTION = 2,
  MIN = NONE,
  MAX = PREDICTION
};

inline const FilteringType (&EnumValuesFilteringType())[3] {
  static const FilteringType values[] = {
    FilteringType::NONE,
    FilteringType::SMOOTHING,
    FilteringType::PREDICTION
  };
  return values;
}

inline const char * const *EnumNamesFilteringType() {
  static const char * const names[4] = {
    "NONE",
    "SMOOTHING",
    "PREDICTION",
    nullptr
  };
  return names;
}

inline const char *EnumNameFilteringType(FilteringType e) {
  if (flatbuffers::IsOutRange(e, FilteringType::NONE, FilteringType::PREDICTION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFilteringType()[index];
}

/// Possible tracker roles
/// They're not perfect match for SteamVR tracker roles,
/// because we support more possible roles. Host can
/// chose how to map it to their supported role.
enum class TrackerRole : uint8_t {
  NONE = 0,
  WAIST = 1,
  LEFT_FOOT = 2,
  RIGHT_FOOT = 3,
  CHEST = 4,
  LEFT_KNEE = 5,
  RIGHT_KNEE = 6,
  LEFT_ELBOW = 7,
  RIGHT_ELBOW = 8,
  LEFT_SHOULDER = 9,
  RIGHT_SHOULDER = 10,
  LEFT_HAND = 11,
  RIGHT_HAND = 12,
  LEFT_CONTROLLER = 13,
  RIGHT_CONTROLLER = 14,
  HEAD = 15,
  NECK = 16,
  CAMERA = 17,
  KEYBOARD = 18,
  HMD = 19,
  BEACON = 20,
  GENERIC_CONTROLLER = 21,
  MIN = NONE,
  MAX = GENERIC_CONTROLLER
};

inline const TrackerRole (&EnumValuesTrackerRole())[22] {
  static const TrackerRole values[] = {
    TrackerRole::NONE,
    TrackerRole::WAIST,
    TrackerRole::LEFT_FOOT,
    TrackerRole::RIGHT_FOOT,
    TrackerRole::CHEST,
    TrackerRole::LEFT_KNEE,
    TrackerRole::RIGHT_KNEE,
    TrackerRole::LEFT_ELBOW,
    TrackerRole::RIGHT_ELBOW,
    TrackerRole::LEFT_SHOULDER,
    TrackerRole::RIGHT_SHOULDER,
    TrackerRole::LEFT_HAND,
    TrackerRole::RIGHT_HAND,
    TrackerRole::LEFT_CONTROLLER,
    TrackerRole::RIGHT_CONTROLLER,
    TrackerRole::HEAD,
    TrackerRole::NECK,
    TrackerRole::CAMERA,
    TrackerRole::KEYBOARD,
    TrackerRole::HMD,
    TrackerRole::BEACON,
    TrackerRole::GENERIC_CONTROLLER
  };
  return values;
}

inline const char * const *EnumNamesTrackerRole() {
  static const char * const names[23] = {
    "NONE",
    "WAIST",
    "LEFT_FOOT",
    "RIGHT_FOOT",
    "CHEST",
    "LEFT_KNEE",
    "RIGHT_KNEE",
    "LEFT_ELBOW",
    "RIGHT_ELBOW",
    "LEFT_SHOULDER",
    "RIGHT_SHOULDER",
    "LEFT_HAND",
    "RIGHT_HAND",
    "LEFT_CONTROLLER",
    "RIGHT_CONTROLLER",
    "HEAD",
    "NECK",
    "CAMERA",
    "KEYBOARD",
    "HMD",
    "BEACON",
    "GENERIC_CONTROLLER",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrackerRole(TrackerRole e) {
  if (flatbuffers::IsOutRange(e, TrackerRole::NONE, TrackerRole::GENERIC_CONTROLLER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrackerRole()[index];
}

/// Different parts of the body. Roughly maps to each possible bone in the skeleton.
/// These are *NOT* the trackers.
enum class BodyPart : uint8_t {
  NONE = 0,
  HEAD = 1,
  NECK = 2,
  CHEST = 3,
  WAIST = 4,
  HIP = 5,
  LEFT_UPPER_LEG = 6,
  RIGHT_UPPER_LEG = 7,
  LEFT_LOWER_LEG = 8,
  RIGHT_LOWER_LEG = 9,
  LEFT_FOOT = 10,
  RIGHT_FOOT = 11,
  LEFT_LOWER_ARM = 14,
  RIGHT_LOWER_ARM = 15,
  LEFT_UPPER_ARM = 16,
  RIGHT_UPPER_ARM = 17,
  LEFT_HAND = 18,
  RIGHT_HAND = 19,
  LEFT_SHOULDER = 20,
  RIGHT_SHOULDER = 21,
  UPPER_CHEST = 22,
  MIN = NONE,
  MAX = UPPER_CHEST
};

inline const BodyPart (&EnumValuesBodyPart())[21] {
  static const BodyPart values[] = {
    BodyPart::NONE,
    BodyPart::HEAD,
    BodyPart::NECK,
    BodyPart::CHEST,
    BodyPart::WAIST,
    BodyPart::HIP,
    BodyPart::LEFT_UPPER_LEG,
    BodyPart::RIGHT_UPPER_LEG,
    BodyPart::LEFT_LOWER_LEG,
    BodyPart::RIGHT_LOWER_LEG,
    BodyPart::LEFT_FOOT,
    BodyPart::RIGHT_FOOT,
    BodyPart::LEFT_LOWER_ARM,
    BodyPart::RIGHT_LOWER_ARM,
    BodyPart::LEFT_UPPER_ARM,
    BodyPart::RIGHT_UPPER_ARM,
    BodyPart::LEFT_HAND,
    BodyPart::RIGHT_HAND,
    BodyPart::LEFT_SHOULDER,
    BodyPart::RIGHT_SHOULDER,
    BodyPart::UPPER_CHEST
  };
  return values;
}

inline const char * const *EnumNamesBodyPart() {
  static const char * const names[24] = {
    "NONE",
    "HEAD",
    "NECK",
    "CHEST",
    "WAIST",
    "HIP",
    "LEFT_UPPER_LEG",
    "RIGHT_UPPER_LEG",
    "LEFT_LOWER_LEG",
    "RIGHT_LOWER_LEG",
    "LEFT_FOOT",
    "RIGHT_FOOT",
    "",
    "",
    "LEFT_LOWER_ARM",
    "RIGHT_LOWER_ARM",
    "LEFT_UPPER_ARM",
    "RIGHT_UPPER_ARM",
    "LEFT_HAND",
    "RIGHT_HAND",
    "LEFT_SHOULDER",
    "RIGHT_SHOULDER",
    "UPPER_CHEST",
    nullptr
  };
  return names;
}

inline const char *EnumNameBodyPart(BodyPart e) {
  if (flatbuffers::IsOutRange(e, BodyPart::NONE, BodyPart::UPPER_CHEST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBodyPart()[index];
}

enum class TrackerStatus : uint8_t {
  NONE = 0,
  DISCONNECTED = 1,
  OK = 2,
  BUSY = 3,
  ERROR = 4,
  OCCLUDED = 5,
  MIN = NONE,
  MAX = OCCLUDED
};

inline const TrackerStatus (&EnumValuesTrackerStatus())[6] {
  static const TrackerStatus values[] = {
    TrackerStatus::NONE,
    TrackerStatus::DISCONNECTED,
    TrackerStatus::OK,
    TrackerStatus::BUSY,
    TrackerStatus::ERROR,
    TrackerStatus::OCCLUDED
  };
  return values;
}

inline const char * const *EnumNamesTrackerStatus() {
  static const char * const names[7] = {
    "NONE",
    "DISCONNECTED",
    "OK",
    "BUSY",
    "ERROR",
    "OCCLUDED",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrackerStatus(TrackerStatus e) {
  if (flatbuffers::IsOutRange(e, TrackerStatus::NONE, TrackerStatus::OCCLUDED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrackerStatus()[index];
}

namespace hardware_info {

enum class McuType : uint16_t {
  Other = 0,
  ESP8266 = 1,
  ESP32 = 2,
  MIN = Other,
  MAX = ESP32
};

inline const McuType (&EnumValuesMcuType())[3] {
  static const McuType values[] = {
    McuType::Other,
    McuType::ESP8266,
    McuType::ESP32
  };
  return values;
}

inline const char * const *EnumNamesMcuType() {
  static const char * const names[4] = {
    "Other",
    "ESP8266",
    "ESP32",
    nullptr
  };
  return names;
}

inline const char *EnumNameMcuType(McuType e) {
  if (flatbuffers::IsOutRange(e, McuType::Other, McuType::ESP32)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMcuType()[index];
}

enum class ImuType : uint16_t {
  Other = 0,
  MPU9250 = 1,
  MPU6500 = 2,
  BNO080 = 3,
  BNO085 = 4,
  BNO055 = 5,
  MPU6050 = 6,
  BNO086 = 7,
  BMI160 = 8,
  ICM20948 = 9,
  MIN = Other,
  MAX = ICM20948
};

inline const ImuType (&EnumValuesImuType())[10] {
  static const ImuType values[] = {
    ImuType::Other,
    ImuType::MPU9250,
    ImuType::MPU6500,
    ImuType::BNO080,
    ImuType::BNO085,
    ImuType::BNO055,
    ImuType::MPU6050,
    ImuType::BNO086,
    ImuType::BMI160,
    ImuType::ICM20948
  };
  return values;
}

inline const char * const *EnumNamesImuType() {
  static const char * const names[11] = {
    "Other",
    "MPU9250",
    "MPU6500",
    "BNO080",
    "BNO085",
    "BNO055",
    "MPU6050",
    "BNO086",
    "BMI160",
    "ICM20948",
    nullptr
  };
  return names;
}

inline const char *EnumNameImuType(ImuType e) {
  if (flatbuffers::IsOutRange(e, ImuType::Other, ImuType::ICM20948)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesImuType()[index];
}

}  // namespace hardware_info
}  // namespace datatypes

namespace data_feed {

enum class DataFeedMessage : uint8_t {
  NONE = 0,
  PollDataFeed = 1,
  StartDataFeed = 2,
  DataFeedUpdate = 3,
  DataFeedConfig = 4,
  MIN = NONE,
  MAX = DataFeedConfig
};

inline const DataFeedMessage (&EnumValuesDataFeedMessage())[5] {
  static const DataFeedMessage values[] = {
    DataFeedMessage::NONE,
    DataFeedMessage::PollDataFeed,
    DataFeedMessage::StartDataFeed,
    DataFeedMessage::DataFeedUpdate,
    DataFeedMessage::DataFeedConfig
  };
  return values;
}

inline const char * const *EnumNamesDataFeedMessage() {
  static const char * const names[6] = {
    "NONE",
    "PollDataFeed",
    "StartDataFeed",
    "DataFeedUpdate",
    "DataFeedConfig",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataFeedMessage(DataFeedMessage e) {
  if (flatbuffers::IsOutRange(e, DataFeedMessage::NONE, DataFeedMessage::DataFeedConfig)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataFeedMessage()[index];
}

template<typename T> struct DataFeedMessageTraits {
  static const DataFeedMessage enum_value = DataFeedMessage::NONE;
};

template<> struct DataFeedMessageTraits<solarxr_protocol::data_feed::PollDataFeed> {
  static const DataFeedMessage enum_value = DataFeedMessage::PollDataFeed;
};

template<> struct DataFeedMessageTraits<solarxr_protocol::data_feed::StartDataFeed> {
  static const DataFeedMessage enum_value = DataFeedMessage::StartDataFeed;
};

template<> struct DataFeedMessageTraits<solarxr_protocol::data_feed::DataFeedUpdate> {
  static const DataFeedMessage enum_value = DataFeedMessage::DataFeedUpdate;
};

template<> struct DataFeedMessageTraits<solarxr_protocol::data_feed::DataFeedConfig> {
  static const DataFeedMessage enum_value = DataFeedMessage::DataFeedConfig;
};

bool VerifyDataFeedMessage(flatbuffers::Verifier &verifier, const void *obj, DataFeedMessage type);
bool VerifyDataFeedMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<DataFeedMessage> *types);

}  // namespace data_feed

namespace rpc {

enum class RpcMessage : uint8_t {
  NONE = 0,
  HeartbeatRequest = 1,
  HeartbeatResponse = 2,
  ResetRequest = 3,
  ResetResponse = 4,
  AssignTrackerRequest = 5,
  SettingsRequest = 6,
  SettingsResponse = 7,
  ChangeSettingsRequest = 8,
  ClearDriftCompensationRequest = 9,
  RecordBVHRequest = 10,
  RecordBVHStatus = 11,
  SkeletonConfigRequest = 12,
  ChangeSkeletonConfigRequest = 13,
  SkeletonResetAllRequest = 14,
  SkeletonConfigResponse = 15,
  OpenSerialRequest = 16,
  CloseSerialRequest = 17,
  SetWifiRequest = 18,
  SerialUpdateResponse = 19,
  AutoBoneProcessRequest = 20,
  AutoBoneProcessStatusResponse = 21,
  AutoBoneEpochResponse = 22,
  OverlayDisplayModeRequest = 23,
  OverlayDisplayModeChangeRequest = 24,
  OverlayDisplayModeResponse = 25,
  SerialTrackerRebootRequest = 26,
  SerialTrackerGetInfoRequest = 27,
  SerialTrackerFactoryResetRequest = 28,
  SerialDevicesRequest = 29,
  SerialDevicesResponse = 30,
  NewSerialDeviceResponse = 31,
  StartWifiProvisioningRequest = 32,
  StopWifiProvisioningRequest = 33,
  WifiProvisioningStatusResponse = 34,
  ServerInfosRequest = 35,
  ServerInfosResponse = 36,
  LegTweaksTmpChange = 37,
  LegTweaksTmpClear = 38,
  TapDetectionSetupNotification = 39,
  SetPauseTrackingRequest = 40,
  StatusSystemRequest = 41,
  StatusSystemResponse = 42,
  StatusSystemUpdate = 43,
  StatusSystemFixed = 44,
  ClearMountingResetRequest = 45,
  HeightRequest = 46,
  HeightResponse = 47,
  AutoBoneApplyRequest = 48,
  AutoBoneStopRecordingRequest = 49,
  AutoBoneCancelRecordingRequest = 50,
  MIN = NONE,
  MAX = AutoBoneCancelRecordingRequest
};

inline const RpcMessage (&EnumValuesRpcMessage())[51] {
  static const RpcMessage values[] = {
    RpcMessage::NONE,
    RpcMessage::HeartbeatRequest,
    RpcMessage::HeartbeatResponse,
    RpcMessage::ResetRequest,
    RpcMessage::ResetResponse,
    RpcMessage::AssignTrackerRequest,
    RpcMessage::SettingsRequest,
    RpcMessage::SettingsResponse,
    RpcMessage::ChangeSettingsRequest,
    RpcMessage::ClearDriftCompensationRequest,
    RpcMessage::RecordBVHRequest,
    RpcMessage::RecordBVHStatus,
    RpcMessage::SkeletonConfigRequest,
    RpcMessage::ChangeSkeletonConfigRequest,
    RpcMessage::SkeletonResetAllRequest,
    RpcMessage::SkeletonConfigResponse,
    RpcMessage::OpenSerialRequest,
    RpcMessage::CloseSerialRequest,
    RpcMessage::SetWifiRequest,
    RpcMessage::SerialUpdateResponse,
    RpcMessage::AutoBoneProcessRequest,
    RpcMessage::AutoBoneProcessStatusResponse,
    RpcMessage::AutoBoneEpochResponse,
    RpcMessage::OverlayDisplayModeRequest,
    RpcMessage::OverlayDisplayModeChangeRequest,
    RpcMessage::OverlayDisplayModeResponse,
    RpcMessage::SerialTrackerRebootRequest,
    RpcMessage::SerialTrackerGetInfoRequest,
    RpcMessage::SerialTrackerFactoryResetRequest,
    RpcMessage::SerialDevicesRequest,
    RpcMessage::SerialDevicesResponse,
    RpcMessage::NewSerialDeviceResponse,
    RpcMessage::StartWifiProvisioningRequest,
    RpcMessage::StopWifiProvisioningRequest,
    RpcMessage::WifiProvisioningStatusResponse,
    RpcMessage::ServerInfosRequest,
    RpcMessage::ServerInfosResponse,
    RpcMessage::LegTweaksTmpChange,
    RpcMessage::LegTweaksTmpClear,
    RpcMessage::TapDetectionSetupNotification,
    RpcMessage::SetPauseTrackingRequest,
    RpcMessage::StatusSystemRequest,
    RpcMessage::StatusSystemResponse,
    RpcMessage::StatusSystemUpdate,
    RpcMessage::StatusSystemFixed,
    RpcMessage::ClearMountingResetRequest,
    RpcMessage::HeightRequest,
    RpcMessage::HeightResponse,
    RpcMessage::AutoBoneApplyRequest,
    RpcMessage::AutoBoneStopRecordingRequest,
    RpcMessage::AutoBoneCancelRecordingRequest
  };
  return values;
}

inline const char * const *EnumNamesRpcMessage() {
  static const char * const names[52] = {
    "NONE",
    "HeartbeatRequest",
    "HeartbeatResponse",
    "ResetRequest",
    "ResetResponse",
    "AssignTrackerRequest",
    "SettingsRequest",
    "SettingsResponse",
    "ChangeSettingsRequest",
    "ClearDriftCompensationRequest",
    "RecordBVHRequest",
    "RecordBVHStatus",
    "SkeletonConfigRequest",
    "ChangeSkeletonConfigRequest",
    "SkeletonResetAllRequest",
    "SkeletonConfigResponse",
    "OpenSerialRequest",
    "CloseSerialRequest",
    "SetWifiRequest",
    "SerialUpdateResponse",
    "AutoBoneProcessRequest",
    "AutoBoneProcessStatusResponse",
    "AutoBoneEpochResponse",
    "OverlayDisplayModeRequest",
    "OverlayDisplayModeChangeRequest",
    "OverlayDisplayModeResponse",
    "SerialTrackerRebootRequest",
    "SerialTrackerGetInfoRequest",
    "SerialTrackerFactoryResetRequest",
    "SerialDevicesRequest",
    "SerialDevicesResponse",
    "NewSerialDeviceResponse",
    "StartWifiProvisioningRequest",
    "StopWifiProvisioningRequest",
    "WifiProvisioningStatusResponse",
    "ServerInfosRequest",
    "ServerInfosResponse",
    "LegTweaksTmpChange",
    "LegTweaksTmpClear",
    "TapDetectionSetupNotification",
    "SetPauseTrackingRequest",
    "StatusSystemRequest",
    "StatusSystemResponse",
    "StatusSystemUpdate",
    "StatusSystemFixed",
    "ClearMountingResetRequest",
    "HeightRequest",
    "HeightResponse",
    "AutoBoneApplyRequest",
    "AutoBoneStopRecordingRequest",
    "AutoBoneCancelRecordingRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameRpcMessage(RpcMessage e) {
  if (flatbuffers::IsOutRange(e, RpcMessage::NONE, RpcMessage::AutoBoneCancelRecordingRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRpcMessage()[index];
}

template<typename T> struct RpcMessageTraits {
  static const RpcMessage enum_value = RpcMessage::NONE;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::HeartbeatRequest> {
  static const RpcMessage enum_value = RpcMessage::HeartbeatRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::HeartbeatResponse> {
  static const RpcMessage enum_value = RpcMessage::HeartbeatResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::ResetRequest> {
  static const RpcMessage enum_value = RpcMessage::ResetRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::ResetResponse> {
  static const RpcMessage enum_value = RpcMessage::ResetResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::AssignTrackerRequest> {
  static const RpcMessage enum_value = RpcMessage::AssignTrackerRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SettingsRequest> {
  static const RpcMessage enum_value = RpcMessage::SettingsRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SettingsResponse> {
  static const RpcMessage enum_value = RpcMessage::SettingsResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::ChangeSettingsRequest> {
  static const RpcMessage enum_value = RpcMessage::ChangeSettingsRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::ClearDriftCompensationRequest> {
  static const RpcMessage enum_value = RpcMessage::ClearDriftCompensationRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::RecordBVHRequest> {
  static const RpcMessage enum_value = RpcMessage::RecordBVHRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::RecordBVHStatus> {
  static const RpcMessage enum_value = RpcMessage::RecordBVHStatus;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SkeletonConfigRequest> {
  static const RpcMessage enum_value = RpcMessage::SkeletonConfigRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::ChangeSkeletonConfigRequest> {
  static const RpcMessage enum_value = RpcMessage::ChangeSkeletonConfigRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SkeletonResetAllRequest> {
  static const RpcMessage enum_value = RpcMessage::SkeletonResetAllRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SkeletonConfigResponse> {
  static const RpcMessage enum_value = RpcMessage::SkeletonConfigResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::OpenSerialRequest> {
  static const RpcMessage enum_value = RpcMessage::OpenSerialRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::CloseSerialRequest> {
  static const RpcMessage enum_value = RpcMessage::CloseSerialRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SetWifiRequest> {
  static const RpcMessage enum_value = RpcMessage::SetWifiRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SerialUpdateResponse> {
  static const RpcMessage enum_value = RpcMessage::SerialUpdateResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::AutoBoneProcessRequest> {
  static const RpcMessage enum_value = RpcMessage::AutoBoneProcessRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::AutoBoneProcessStatusResponse> {
  static const RpcMessage enum_value = RpcMessage::AutoBoneProcessStatusResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::AutoBoneEpochResponse> {
  static const RpcMessage enum_value = RpcMessage::AutoBoneEpochResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::OverlayDisplayModeRequest> {
  static const RpcMessage enum_value = RpcMessage::OverlayDisplayModeRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::OverlayDisplayModeChangeRequest> {
  static const RpcMessage enum_value = RpcMessage::OverlayDisplayModeChangeRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::OverlayDisplayModeResponse> {
  static const RpcMessage enum_value = RpcMessage::OverlayDisplayModeResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SerialTrackerRebootRequest> {
  static const RpcMessage enum_value = RpcMessage::SerialTrackerRebootRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SerialTrackerGetInfoRequest> {
  static const RpcMessage enum_value = RpcMessage::SerialTrackerGetInfoRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SerialTrackerFactoryResetRequest> {
  static const RpcMessage enum_value = RpcMessage::SerialTrackerFactoryResetRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SerialDevicesRequest> {
  static const RpcMessage enum_value = RpcMessage::SerialDevicesRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SerialDevicesResponse> {
  static const RpcMessage enum_value = RpcMessage::SerialDevicesResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::NewSerialDeviceResponse> {
  static const RpcMessage enum_value = RpcMessage::NewSerialDeviceResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::StartWifiProvisioningRequest> {
  static const RpcMessage enum_value = RpcMessage::StartWifiProvisioningRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::StopWifiProvisioningRequest> {
  static const RpcMessage enum_value = RpcMessage::StopWifiProvisioningRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::WifiProvisioningStatusResponse> {
  static const RpcMessage enum_value = RpcMessage::WifiProvisioningStatusResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::ServerInfosRequest> {
  static const RpcMessage enum_value = RpcMessage::ServerInfosRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::ServerInfosResponse> {
  static const RpcMessage enum_value = RpcMessage::ServerInfosResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::LegTweaksTmpChange> {
  static const RpcMessage enum_value = RpcMessage::LegTweaksTmpChange;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::LegTweaksTmpClear> {
  static const RpcMessage enum_value = RpcMessage::LegTweaksTmpClear;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::TapDetectionSetupNotification> {
  static const RpcMessage enum_value = RpcMessage::TapDetectionSetupNotification;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::SetPauseTrackingRequest> {
  static const RpcMessage enum_value = RpcMessage::SetPauseTrackingRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::StatusSystemRequest> {
  static const RpcMessage enum_value = RpcMessage::StatusSystemRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::StatusSystemResponse> {
  static const RpcMessage enum_value = RpcMessage::StatusSystemResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::StatusSystemUpdate> {
  static const RpcMessage enum_value = RpcMessage::StatusSystemUpdate;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::StatusSystemFixed> {
  static const RpcMessage enum_value = RpcMessage::StatusSystemFixed;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::ClearMountingResetRequest> {
  static const RpcMessage enum_value = RpcMessage::ClearMountingResetRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::HeightRequest> {
  static const RpcMessage enum_value = RpcMessage::HeightRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::HeightResponse> {
  static const RpcMessage enum_value = RpcMessage::HeightResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::AutoBoneApplyRequest> {
  static const RpcMessage enum_value = RpcMessage::AutoBoneApplyRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::AutoBoneStopRecordingRequest> {
  static const RpcMessage enum_value = RpcMessage::AutoBoneStopRecordingRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::rpc::AutoBoneCancelRecordingRequest> {
  static const RpcMessage enum_value = RpcMessage::AutoBoneCancelRecordingRequest;
};

bool VerifyRpcMessage(flatbuffers::Verifier &verifier, const void *obj, RpcMessage type);
bool VerifyRpcMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<RpcMessage> *types);

enum class ResetType : uint8_t {
  Yaw = 0,
  Full = 1,
  /// Second pose for calibrating mounting rotation
  Mounting = 2,
  MIN = Yaw,
  MAX = Mounting
};

inline const ResetType (&EnumValuesResetType())[3] {
  static const ResetType values[] = {
    ResetType::Yaw,
    ResetType::Full,
    ResetType::Mounting
  };
  return values;
}

inline const char * const *EnumNamesResetType() {
  static const char * const names[4] = {
    "Yaw",
    "Full",
    "Mounting",
    nullptr
  };
  return names;
}

inline const char *EnumNameResetType(ResetType e) {
  if (flatbuffers::IsOutRange(e, ResetType::Yaw, ResetType::Mounting)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResetType()[index];
}

enum class ResetStatus : uint8_t {
  STARTED = 0,
  FINISHED = 1,
  MIN = STARTED,
  MAX = FINISHED
};

inline const ResetStatus (&EnumValuesResetStatus())[2] {
  static const ResetStatus values[] = {
    ResetStatus::STARTED,
    ResetStatus::FINISHED
  };
  return values;
}

inline const char * const *EnumNamesResetStatus() {
  static const char * const names[3] = {
    "STARTED",
    "FINISHED",
    nullptr
  };
  return names;
}

inline const char *EnumNameResetStatus(ResetStatus e) {
  if (flatbuffers::IsOutRange(e, ResetStatus::STARTED, ResetStatus::FINISHED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResetStatus()[index];
}

enum class SkeletonBone : uint8_t {
  NONE = 0,
  HEAD = 1,
  NECK = 2,
  CHEST = 3,
  CHEST_OFFSET = 4,
  WAIST = 5,
  HIP = 6,
  HIP_OFFSET = 7,
  HIPS_WIDTH = 8,
  UPPER_LEG = 9,
  LOWER_LEG = 10,
  FOOT_LENGTH = 11,
  FOOT_SHIFT = 12,
  SKELETON_OFFSET = 13,
  SHOULDERS_DISTANCE = 14,
  SHOULDERS_WIDTH = 15,
  UPPER_ARM = 16,
  LOWER_ARM = 17,
  HAND_Y = 18,
  HAND_Z = 19,
  ELBOW_OFFSET = 20,
  UPPER_CHEST = 21,
  MIN = NONE,
  MAX = UPPER_CHEST
};

inline const SkeletonBone (&EnumValuesSkeletonBone())[22] {
  static const SkeletonBone values[] = {
    SkeletonBone::NONE,
    SkeletonBone::HEAD,
    SkeletonBone::NECK,
    SkeletonBone::CHEST,
    SkeletonBone::CHEST_OFFSET,
    SkeletonBone::WAIST,
    SkeletonBone::HIP,
    SkeletonBone::HIP_OFFSET,
    SkeletonBone::HIPS_WIDTH,
    SkeletonBone::UPPER_LEG,
    SkeletonBone::LOWER_LEG,
    SkeletonBone::FOOT_LENGTH,
    SkeletonBone::FOOT_SHIFT,
    SkeletonBone::SKELETON_OFFSET,
    SkeletonBone::SHOULDERS_DISTANCE,
    SkeletonBone::SHOULDERS_WIDTH,
    SkeletonBone::UPPER_ARM,
    SkeletonBone::LOWER_ARM,
    SkeletonBone::HAND_Y,
    SkeletonBone::HAND_Z,
    SkeletonBone::ELBOW_OFFSET,
    SkeletonBone::UPPER_CHEST
  };
  return values;
}

inline const char * const *EnumNamesSkeletonBone() {
  static const char * const names[23] = {
    "NONE",
    "HEAD",
    "NECK",
    "CHEST",
    "CHEST_OFFSET",
    "WAIST",
    "HIP",
    "HIP_OFFSET",
    "HIPS_WIDTH",
    "UPPER_LEG",
    "LOWER_LEG",
    "FOOT_LENGTH",
    "FOOT_SHIFT",
    "SKELETON_OFFSET",
    "SHOULDERS_DISTANCE",
    "SHOULDERS_WIDTH",
    "UPPER_ARM",
    "LOWER_ARM",
    "HAND_Y",
    "HAND_Z",
    "ELBOW_OFFSET",
    "UPPER_CHEST",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkeletonBone(SkeletonBone e) {
  if (flatbuffers::IsOutRange(e, SkeletonBone::NONE, SkeletonBone::UPPER_CHEST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSkeletonBone()[index];
}

enum class WifiProvisioningStatus : uint8_t {
  NONE = 0,
  SERIAL_INIT = 1,
  PROVISIONING = 2,
  CONNECTING = 3,
  CONNECTION_ERROR = 4,
  LOOKING_FOR_SERVER = 5,
  COULD_NOT_FIND_SERVER = 6,
  DONE = 7,
  MIN = NONE,
  MAX = DONE
};

inline const WifiProvisioningStatus (&EnumValuesWifiProvisioningStatus())[8] {
  static const WifiProvisioningStatus values[] = {
    WifiProvisioningStatus::NONE,
    WifiProvisioningStatus::SERIAL_INIT,
    WifiProvisioningStatus::PROVISIONING,
    WifiProvisioningStatus::CONNECTING,
    WifiProvisioningStatus::CONNECTION_ERROR,
    WifiProvisioningStatus::LOOKING_FOR_SERVER,
    WifiProvisioningStatus::COULD_NOT_FIND_SERVER,
    WifiProvisioningStatus::DONE
  };
  return values;
}

inline const char * const *EnumNamesWifiProvisioningStatus() {
  static const char * const names[9] = {
    "NONE",
    "SERIAL_INIT",
    "PROVISIONING",
    "CONNECTING",
    "CONNECTION_ERROR",
    "LOOKING_FOR_SERVER",
    "COULD_NOT_FIND_SERVER",
    "DONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameWifiProvisioningStatus(WifiProvisioningStatus e) {
  if (flatbuffers::IsOutRange(e, WifiProvisioningStatus::NONE, WifiProvisioningStatus::DONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWifiProvisioningStatus()[index];
}

enum class AutoBoneProcessType : uint8_t {
  NONE = 0,
  RECORD = 1,
  SAVE = 2,
  PROCESS = 3,
  /// @deprecated
  /// Use AutoBoneApplyRequest instead
  APPLY = 4,
  MIN = NONE,
  MAX = APPLY
};

inline const AutoBoneProcessType (&EnumValuesAutoBoneProcessType())[5] {
  static const AutoBoneProcessType values[] = {
    AutoBoneProcessType::NONE,
    AutoBoneProcessType::RECORD,
    AutoBoneProcessType::SAVE,
    AutoBoneProcessType::PROCESS,
    AutoBoneProcessType::APPLY
  };
  return values;
}

inline const char * const *EnumNamesAutoBoneProcessType() {
  static const char * const names[6] = {
    "NONE",
    "RECORD",
    "SAVE",
    "PROCESS",
    "APPLY",
    nullptr
  };
  return names;
}

inline const char *EnumNameAutoBoneProcessType(AutoBoneProcessType e) {
  if (flatbuffers::IsOutRange(e, AutoBoneProcessType::NONE, AutoBoneProcessType::APPLY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAutoBoneProcessType()[index];
}

enum class StatusData : uint8_t {
  NONE = 0,
  StatusTrackerReset = 1,
  StatusTrackerError = 2,
  StatusSteamVRDisconnected = 3,
  MIN = NONE,
  MAX = StatusSteamVRDisconnected
};

inline const StatusData (&EnumValuesStatusData())[4] {
  static const StatusData values[] = {
    StatusData::NONE,
    StatusData::StatusTrackerReset,
    StatusData::StatusTrackerError,
    StatusData::StatusSteamVRDisconnected
  };
  return values;
}

inline const char * const *EnumNamesStatusData() {
  static const char * const names[5] = {
    "NONE",
    "StatusTrackerReset",
    "StatusTrackerError",
    "StatusSteamVRDisconnected",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatusData(StatusData e) {
  if (flatbuffers::IsOutRange(e, StatusData::NONE, StatusData::StatusSteamVRDisconnected)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatusData()[index];
}

template<typename T> struct StatusDataTraits {
  static const StatusData enum_value = StatusData::NONE;
};

template<> struct StatusDataTraits<solarxr_protocol::rpc::StatusTrackerReset> {
  static const StatusData enum_value = StatusData::StatusTrackerReset;
};

template<> struct StatusDataTraits<solarxr_protocol::rpc::StatusTrackerError> {
  static const StatusData enum_value = StatusData::StatusTrackerError;
};

template<> struct StatusDataTraits<solarxr_protocol::rpc::StatusSteamVRDisconnected> {
  static const StatusData enum_value = StatusData::StatusSteamVRDisconnected;
};

bool VerifyStatusData(flatbuffers::Verifier &verifier, const void *obj, StatusData type);
bool VerifyStatusDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<StatusData> *types);

}  // namespace rpc

namespace pub_sub {

enum class Topic : uint8_t {
  NONE = 0,
  TopicHandle = 1,
  TopicId = 2,
  MIN = NONE,
  MAX = TopicId
};

inline const Topic (&EnumValuesTopic())[3] {
  static const Topic values[] = {
    Topic::NONE,
    Topic::TopicHandle,
    Topic::TopicId
  };
  return values;
}

inline const char * const *EnumNamesTopic() {
  static const char * const names[4] = {
    "NONE",
    "TopicHandle",
    "TopicId",
    nullptr
  };
  return names;
}

inline const char *EnumNameTopic(Topic e) {
  if (flatbuffers::IsOutRange(e, Topic::NONE, Topic::TopicId)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTopic()[index];
}

template<typename T> struct TopicTraits {
  static const Topic enum_value = Topic::NONE;
};

template<> struct TopicTraits<solarxr_protocol::pub_sub::TopicHandle> {
  static const Topic enum_value = Topic::TopicHandle;
};

template<> struct TopicTraits<solarxr_protocol::pub_sub::TopicId> {
  static const Topic enum_value = Topic::TopicId;
};

bool VerifyTopic(flatbuffers::Verifier &verifier, const void *obj, Topic type);
bool VerifyTopicVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Topic> *types);

enum class PubSubUnion : uint8_t {
  NONE = 0,
  Message = 1,
  SubscriptionRequest = 2,
  TopicHandleRequest = 3,
  TopicMapping = 4,
  MIN = NONE,
  MAX = TopicMapping
};

inline const PubSubUnion (&EnumValuesPubSubUnion())[5] {
  static const PubSubUnion values[] = {
    PubSubUnion::NONE,
    PubSubUnion::Message,
    PubSubUnion::SubscriptionRequest,
    PubSubUnion::TopicHandleRequest,
    PubSubUnion::TopicMapping
  };
  return values;
}

inline const char * const *EnumNamesPubSubUnion() {
  static const char * const names[6] = {
    "NONE",
    "Message",
    "SubscriptionRequest",
    "TopicHandleRequest",
    "TopicMapping",
    nullptr
  };
  return names;
}

inline const char *EnumNamePubSubUnion(PubSubUnion e) {
  if (flatbuffers::IsOutRange(e, PubSubUnion::NONE, PubSubUnion::TopicMapping)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPubSubUnion()[index];
}

template<typename T> struct PubSubUnionTraits {
  static const PubSubUnion enum_value = PubSubUnion::NONE;
};

template<> struct PubSubUnionTraits<solarxr_protocol::pub_sub::Message> {
  static const PubSubUnion enum_value = PubSubUnion::Message;
};

template<> struct PubSubUnionTraits<solarxr_protocol::pub_sub::SubscriptionRequest> {
  static const PubSubUnion enum_value = PubSubUnion::SubscriptionRequest;
};

template<> struct PubSubUnionTraits<solarxr_protocol::pub_sub::TopicHandleRequest> {
  static const PubSubUnion enum_value = PubSubUnion::TopicHandleRequest;
};

template<> struct PubSubUnionTraits<solarxr_protocol::pub_sub::TopicMapping> {
  static const PubSubUnion enum_value = PubSubUnion::TopicMapping;
};

bool VerifyPubSubUnion(flatbuffers::Verifier &verifier, const void *obj, PubSubUnion type);
bool VerifyPubSubUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<PubSubUnion> *types);

enum class Payload : uint8_t {
  NONE = 0,
  solarxr_protocol_datatypes_StringTable = 1,
  solarxr_protocol_datatypes_Bytes = 2,
  KeyValues = 3,
  MIN = NONE,
  MAX = KeyValues
};

inline const Payload (&EnumValuesPayload())[4] {
  static const Payload values[] = {
    Payload::NONE,
    Payload::solarxr_protocol_datatypes_StringTable,
    Payload::solarxr_protocol_datatypes_Bytes,
    Payload::KeyValues
  };
  return values;
}

inline const char * const *EnumNamesPayload() {
  static const char * const names[5] = {
    "NONE",
    "solarxr_protocol_datatypes_StringTable",
    "solarxr_protocol_datatypes_Bytes",
    "KeyValues",
    nullptr
  };
  return names;
}

inline const char *EnumNamePayload(Payload e) {
  if (flatbuffers::IsOutRange(e, Payload::NONE, Payload::KeyValues)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPayload()[index];
}

template<typename T> struct PayloadTraits {
  static const Payload enum_value = Payload::NONE;
};

template<> struct PayloadTraits<solarxr_protocol::datatypes::StringTable> {
  static const Payload enum_value = Payload::solarxr_protocol_datatypes_StringTable;
};

template<> struct PayloadTraits<solarxr_protocol::datatypes::Bytes> {
  static const Payload enum_value = Payload::solarxr_protocol_datatypes_Bytes;
};

template<> struct PayloadTraits<solarxr_protocol::pub_sub::KeyValues> {
  static const Payload enum_value = Payload::KeyValues;
};

bool VerifyPayload(flatbuffers::Verifier &verifier, const void *obj, Payload type);
bool VerifyPayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Payload> *types);

}  // namespace pub_sub

namespace datatypes {

/// Frequency as 32 bit float
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) HzF32 FLATBUFFERS_FINAL_CLASS {
 private:
  float f_;

 public:
  HzF32()
      : f_(0) {
  }
  HzF32(float _f)
      : f_(flatbuffers::EndianScalar(_f)) {
  }
  float f() const {
    return flatbuffers::EndianScalar(f_);
  }
};
FLATBUFFERS_STRUCT_END(HzF32, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TransactionId FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;

 public:
  TransactionId()
      : id_(0) {
  }
  TransactionId(uint32_t _id)
      : id_(flatbuffers::EndianScalar(_id)) {
  }
  /// This is expected to overflow, networking logic should handle this case.
  uint32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
};
FLATBUFFERS_STRUCT_END(TransactionId, 4);

/// A unique ID for the device. IDs are not guaranteed to be the same after
/// the connection is terminated.
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) DeviceId FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t id_;

 public:
  DeviceId()
      : id_(0) {
  }
  DeviceId(uint8_t _id)
      : id_(flatbuffers::EndianScalar(_id)) {
  }
  uint8_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
};
FLATBUFFERS_STRUCT_END(DeviceId, 1);

/// Temperature in degrees celsius
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Temperature FLATBUFFERS_FINAL_CLASS {
 private:
  float temp_;

 public:
  Temperature()
      : temp_(0) {
  }
  Temperature(float _temp)
      : temp_(flatbuffers::EndianScalar(_temp)) {
  }
  float temp() const {
    return flatbuffers::EndianScalar(temp_);
  }
};
FLATBUFFERS_STRUCT_END(Temperature, 4);

/// The 4 bytes of an ip address are stored in 32 bits in big endian order.
/// We will switch over to fixed size arrays when they are supported better.
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Ipv4Address FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t addr_;

 public:
  Ipv4Address()
      : addr_(0) {
  }
  Ipv4Address(uint32_t _addr)
      : addr_(flatbuffers::EndianScalar(_addr)) {
  }
  uint32_t addr() const {
    return flatbuffers::EndianScalar(addr_);
  }
};
FLATBUFFERS_STRUCT_END(Ipv4Address, 4);

namespace hardware_info {

/// A MAC address or a bluetooth address, or some other uniquely identifying address
/// associated with the endpoint that we are communicating with. If it doesn't take
/// up the full set of bytes, it is aligned towards the least significant bits.
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) HardwareAddress FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t addr_;

 public:
  HardwareAddress()
      : addr_(0) {
  }
  HardwareAddress(uint64_t _addr)
      : addr_(flatbuffers::EndianScalar(_addr)) {
  }
  uint64_t addr() const {
    return flatbuffers::EndianScalar(addr_);
  }
};
FLATBUFFERS_STRUCT_END(HardwareAddress, 8);

}  // namespace hardware_info

namespace math {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Quat FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Quat()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Quat(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Quat, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3f()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3f(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3f, 12);

}  // namespace math

struct TrackerId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackerIdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICE_ID = 4,
    VT_TRACKER_NUM = 6
  };
  /// The device the tracker is associated with. If there is no hardware device it is
  /// associated with, this should be `null`.
  const solarxr_protocol::datatypes::DeviceId *device_id() const {
    return GetStruct<const solarxr_protocol::datatypes::DeviceId *>(VT_DEVICE_ID);
  }
  /// There are possibly multiple trackers per device. This identifies which one.
  uint8_t tracker_num() const {
    return GetField<uint8_t>(VT_TRACKER_NUM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<solarxr_protocol::datatypes::DeviceId>(verifier, VT_DEVICE_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_TRACKER_NUM, 1) &&
           verifier.EndTable();
  }
};

struct TrackerIdBuilder {
  typedef TrackerId Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_device_id(const solarxr_protocol::datatypes::DeviceId *device_id) {
    fbb_.AddStruct(TrackerId::VT_DEVICE_ID, device_id);
  }
  void add_tracker_num(uint8_t tracker_num) {
    fbb_.AddElement<uint8_t>(TrackerId::VT_TRACKER_NUM, tracker_num, 0);
  }
  explicit TrackerIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrackerId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackerId>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackerId> CreateTrackerId(
    flatbuffers::FlatBufferBuilder &_fbb,
    const solarxr_protocol::datatypes::DeviceId *device_id = nullptr,
    uint8_t tracker_num = 0) {
  TrackerIdBuilder builder_(_fbb);
  builder_.add_device_id(device_id);
  builder_.add_tracker_num(tracker_num);
  return builder_.Finish();
}

/// General purpose logging datatype
struct LogData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct LogDataBuilder {
  typedef LogData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(LogData::VT_MESSAGE, message);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(LogData::VT_DATA, data);
  }
  explicit LogDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogData> CreateLogData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  LogDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogData> CreateLogDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return solarxr_protocol::datatypes::CreateLogData(
      _fbb,
      message__,
      data__);
}

struct Bytes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BytesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_B = 4
  };
  const flatbuffers::Vector<uint8_t> *b() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_B);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_B) &&
           verifier.VerifyVector(b()) &&
           verifier.EndTable();
  }
};

struct BytesBuilder {
  typedef Bytes Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_b(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> b) {
    fbb_.AddOffset(Bytes::VT_B, b);
  }
  explicit BytesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Bytes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bytes>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bytes> CreateBytes(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> b = 0) {
  BytesBuilder builder_(_fbb);
  builder_.add_b(b);
  return builder_.Finish();
}

inline flatbuffers::Offset<Bytes> CreateBytesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *b = nullptr) {
  auto b__ = b ? _fbb.CreateVector<uint8_t>(*b) : 0;
  return solarxr_protocol::datatypes::CreateBytes(
      _fbb,
      b__);
}

struct StringTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_S = 4
  };
  const flatbuffers::String *s() const {
    return GetPointer<const flatbuffers::String *>(VT_S);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyString(s()) &&
           verifier.EndTable();
  }
};

struct StringTableBuilder {
  typedef StringTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_s(flatbuffers::Offset<flatbuffers::String> s) {
    fbb_.AddOffset(StringTable::VT_S, s);
  }
  explicit StringTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StringTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringTable> CreateStringTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> s = 0) {
  StringTableBuilder builder_(_fbb);
  builder_.add_s(s);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringTable> CreateStringTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *s = nullptr) {
  auto s__ = s ? _fbb.CreateString(s) : 0;
  return solarxr_protocol::datatypes::CreateStringTable(
      _fbb,
      s__);
}

namespace hardware_info {

/// Mostly static info about the device's hardware/firmware.
struct HardwareInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HardwareInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MCU_ID = 4,
    VT_DISPLAY_NAME = 6,
    VT_MODEL = 8,
    VT_MANUFACTURER = 10,
    VT_HARDWARE_REVISION = 12,
    VT_FIRMWARE_VERSION = 14,
    VT_HARDWARE_ADDRESS = 16,
    VT_IP_ADDRESS = 18,
    VT_BOARD_TYPE = 20,
    VT_HARDWARE_IDENTIFIER = 22
  };
  solarxr_protocol::datatypes::hardware_info::McuType mcu_id() const {
    return static_cast<solarxr_protocol::datatypes::hardware_info::McuType>(GetField<uint16_t>(VT_MCU_ID, 0));
  }
  /// A human-friendly name to display as the name of the device.
  const flatbuffers::String *display_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  /// A human-friendly string for the device model.
  const flatbuffers::String *model() const {
    return GetPointer<const flatbuffers::String *>(VT_MODEL);
  }
  /// A human-friendly string for the manufacturer of the device.
  const flatbuffers::String *manufacturer() const {
    return GetPointer<const flatbuffers::String *>(VT_MANUFACTURER);
  }
  /// The hardware version of the device. For example, pcb version.
  const flatbuffers::String *hardware_revision() const {
    return GetPointer<const flatbuffers::String *>(VT_HARDWARE_REVISION);
  }
  /// The version of the slimevr firmware that the device is running.
  const flatbuffers::String *firmware_version() const {
    return GetPointer<const flatbuffers::String *>(VT_FIRMWARE_VERSION);
  }
  const solarxr_protocol::datatypes::hardware_info::HardwareAddress *hardware_address() const {
    return GetStruct<const solarxr_protocol::datatypes::hardware_info::HardwareAddress *>(VT_HARDWARE_ADDRESS);
  }
  const solarxr_protocol::datatypes::Ipv4Address *ip_address() const {
    return GetStruct<const solarxr_protocol::datatypes::Ipv4Address *>(VT_IP_ADDRESS);
  }
  const flatbuffers::String *board_type() const {
    return GetPointer<const flatbuffers::String *>(VT_BOARD_TYPE);
  }
  /// A unique identifier for the device. Depending on the type of device it can be the MAC address,
  /// the IP address, or some other unique identifier like what USB device it is.
  const flatbuffers::String *hardware_identifier() const {
    return GetPointer<const flatbuffers::String *>(VT_HARDWARE_IDENTIFIER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MCU_ID, 2) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyOffset(verifier, VT_MODEL) &&
           verifier.VerifyString(model()) &&
           VerifyOffset(verifier, VT_MANUFACTURER) &&
           verifier.VerifyString(manufacturer()) &&
           VerifyOffset(verifier, VT_HARDWARE_REVISION) &&
           verifier.VerifyString(hardware_revision()) &&
           VerifyOffset(verifier, VT_FIRMWARE_VERSION) &&
           verifier.VerifyString(firmware_version()) &&
           VerifyField<solarxr_protocol::datatypes::hardware_info::HardwareAddress>(verifier, VT_HARDWARE_ADDRESS, 8) &&
           VerifyField<solarxr_protocol::datatypes::Ipv4Address>(verifier, VT_IP_ADDRESS, 4) &&
           VerifyOffset(verifier, VT_BOARD_TYPE) &&
           verifier.VerifyString(board_type()) &&
           VerifyOffset(verifier, VT_HARDWARE_IDENTIFIER) &&
           verifier.VerifyString(hardware_identifier()) &&
           verifier.EndTable();
  }
};

struct HardwareInfoBuilder {
  typedef HardwareInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mcu_id(solarxr_protocol::datatypes::hardware_info::McuType mcu_id) {
    fbb_.AddElement<uint16_t>(HardwareInfo::VT_MCU_ID, static_cast<uint16_t>(mcu_id), 0);
  }
  void add_display_name(flatbuffers::Offset<flatbuffers::String> display_name) {
    fbb_.AddOffset(HardwareInfo::VT_DISPLAY_NAME, display_name);
  }
  void add_model(flatbuffers::Offset<flatbuffers::String> model) {
    fbb_.AddOffset(HardwareInfo::VT_MODEL, model);
  }
  void add_manufacturer(flatbuffers::Offset<flatbuffers::String> manufacturer) {
    fbb_.AddOffset(HardwareInfo::VT_MANUFACTURER, manufacturer);
  }
  void add_hardware_revision(flatbuffers::Offset<flatbuffers::String> hardware_revision) {
    fbb_.AddOffset(HardwareInfo::VT_HARDWARE_REVISION, hardware_revision);
  }
  void add_firmware_version(flatbuffers::Offset<flatbuffers::String> firmware_version) {
    fbb_.AddOffset(HardwareInfo::VT_FIRMWARE_VERSION, firmware_version);
  }
  void add_hardware_address(const solarxr_protocol::datatypes::hardware_info::HardwareAddress *hardware_address) {
    fbb_.AddStruct(HardwareInfo::VT_HARDWARE_ADDRESS, hardware_address);
  }
  void add_ip_address(const solarxr_protocol::datatypes::Ipv4Address *ip_address) {
    fbb_.AddStruct(HardwareInfo::VT_IP_ADDRESS, ip_address);
  }
  void add_board_type(flatbuffers::Offset<flatbuffers::String> board_type) {
    fbb_.AddOffset(HardwareInfo::VT_BOARD_TYPE, board_type);
  }
  void add_hardware_identifier(flatbuffers::Offset<flatbuffers::String> hardware_identifier) {
    fbb_.AddOffset(HardwareInfo::VT_HARDWARE_IDENTIFIER, hardware_identifier);
  }
  explicit HardwareInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HardwareInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardwareInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardwareInfo> CreateHardwareInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::hardware_info::McuType mcu_id = solarxr_protocol::datatypes::hardware_info::McuType::Other,
    flatbuffers::Offset<flatbuffers::String> display_name = 0,
    flatbuffers::Offset<flatbuffers::String> model = 0,
    flatbuffers::Offset<flatbuffers::String> manufacturer = 0,
    flatbuffers::Offset<flatbuffers::String> hardware_revision = 0,
    flatbuffers::Offset<flatbuffers::String> firmware_version = 0,
    const solarxr_protocol::datatypes::hardware_info::HardwareAddress *hardware_address = nullptr,
    const solarxr_protocol::datatypes::Ipv4Address *ip_address = nullptr,
    flatbuffers::Offset<flatbuffers::String> board_type = 0,
    flatbuffers::Offset<flatbuffers::String> hardware_identifier = 0) {
  HardwareInfoBuilder builder_(_fbb);
  builder_.add_hardware_identifier(hardware_identifier);
  builder_.add_board_type(board_type);
  builder_.add_ip_address(ip_address);
  builder_.add_hardware_address(hardware_address);
  builder_.add_firmware_version(firmware_version);
  builder_.add_hardware_revision(hardware_revision);
  builder_.add_manufacturer(manufacturer);
  builder_.add_model(model);
  builder_.add_display_name(display_name);
  builder_.add_mcu_id(mcu_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<HardwareInfo> CreateHardwareInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::hardware_info::McuType mcu_id = solarxr_protocol::datatypes::hardware_info::McuType::Other,
    const char *display_name = nullptr,
    const char *model = nullptr,
    const char *manufacturer = nullptr,
    const char *hardware_revision = nullptr,
    const char *firmware_version = nullptr,
    const solarxr_protocol::datatypes::hardware_info::HardwareAddress *hardware_address = nullptr,
    const solarxr_protocol::datatypes::Ipv4Address *ip_address = nullptr,
    const char *board_type = nullptr,
    const char *hardware_identifier = nullptr) {
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  auto model__ = model ? _fbb.CreateString(model) : 0;
  auto manufacturer__ = manufacturer ? _fbb.CreateString(manufacturer) : 0;
  auto hardware_revision__ = hardware_revision ? _fbb.CreateString(hardware_revision) : 0;
  auto firmware_version__ = firmware_version ? _fbb.CreateString(firmware_version) : 0;
  auto board_type__ = board_type ? _fbb.CreateString(board_type) : 0;
  auto hardware_identifier__ = hardware_identifier ? _fbb.CreateString(hardware_identifier) : 0;
  return solarxr_protocol::datatypes::hardware_info::CreateHardwareInfo(
      _fbb,
      mcu_id,
      display_name__,
      model__,
      manufacturer__,
      hardware_revision__,
      firmware_version__,
      hardware_address,
      ip_address,
      board_type__,
      hardware_identifier__);
}

/// Mostly-dynamic status info about a tracked device's firmware
struct HardwareStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HardwareStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_STATUS = 4,
    VT_PING = 8,
    VT_RSSI = 10,
    VT_MCU_TEMP = 12,
    VT_BATTERY_VOLTAGE = 14,
    VT_BATTERY_PCT_ESTIMATE = 16,
    VT_LOG_DATA = 18
  };
  flatbuffers::Optional<solarxr_protocol::datatypes::FirmwareErrorCode> error_status() const {
    return GetOptional<uint8_t, solarxr_protocol::datatypes::FirmwareErrorCode>(VT_ERROR_STATUS);
  }
  flatbuffers::Optional<uint16_t> ping() const {
    return GetOptional<uint16_t, uint16_t>(VT_PING);
  }
  /// “Received Signal Strength Indicator" between device and wifi adapter in dBm
  flatbuffers::Optional<int16_t> rssi() const {
    return GetOptional<int16_t, int16_t>(VT_RSSI);
  }
  /// Temperature in degrees celsius
  flatbuffers::Optional<float> mcu_temp() const {
    return GetOptional<float, float>(VT_MCU_TEMP);
  }
  flatbuffers::Optional<float> battery_voltage() const {
    return GetOptional<float, float>(VT_BATTERY_VOLTAGE);
  }
  flatbuffers::Optional<uint8_t> battery_pct_estimate() const {
    return GetOptional<uint8_t, uint8_t>(VT_BATTERY_PCT_ESTIMATE);
  }
  const solarxr_protocol::datatypes::LogData *log_data() const {
    return GetPointer<const solarxr_protocol::datatypes::LogData *>(VT_LOG_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ERROR_STATUS, 1) &&
           VerifyField<uint16_t>(verifier, VT_PING, 2) &&
           VerifyField<int16_t>(verifier, VT_RSSI, 2) &&
           VerifyField<float>(verifier, VT_MCU_TEMP, 4) &&
           VerifyField<float>(verifier, VT_BATTERY_VOLTAGE, 4) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_PCT_ESTIMATE, 1) &&
           VerifyOffset(verifier, VT_LOG_DATA) &&
           verifier.VerifyTable(log_data()) &&
           verifier.EndTable();
  }
};

struct HardwareStatusBuilder {
  typedef HardwareStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_status(solarxr_protocol::datatypes::FirmwareErrorCode error_status) {
    fbb_.AddElement<uint8_t>(HardwareStatus::VT_ERROR_STATUS, static_cast<uint8_t>(error_status));
  }
  void add_ping(uint16_t ping) {
    fbb_.AddElement<uint16_t>(HardwareStatus::VT_PING, ping);
  }
  void add_rssi(int16_t rssi) {
    fbb_.AddElement<int16_t>(HardwareStatus::VT_RSSI, rssi);
  }
  void add_mcu_temp(float mcu_temp) {
    fbb_.AddElement<float>(HardwareStatus::VT_MCU_TEMP, mcu_temp);
  }
  void add_battery_voltage(float battery_voltage) {
    fbb_.AddElement<float>(HardwareStatus::VT_BATTERY_VOLTAGE, battery_voltage);
  }
  void add_battery_pct_estimate(uint8_t battery_pct_estimate) {
    fbb_.AddElement<uint8_t>(HardwareStatus::VT_BATTERY_PCT_ESTIMATE, battery_pct_estimate);
  }
  void add_log_data(flatbuffers::Offset<solarxr_protocol::datatypes::LogData> log_data) {
    fbb_.AddOffset(HardwareStatus::VT_LOG_DATA, log_data);
  }
  explicit HardwareStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HardwareStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardwareStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardwareStatus> CreateHardwareStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<solarxr_protocol::datatypes::FirmwareErrorCode> error_status = flatbuffers::nullopt,
    flatbuffers::Optional<uint16_t> ping = flatbuffers::nullopt,
    flatbuffers::Optional<int16_t> rssi = flatbuffers::nullopt,
    flatbuffers::Optional<float> mcu_temp = flatbuffers::nullopt,
    flatbuffers::Optional<float> battery_voltage = flatbuffers::nullopt,
    flatbuffers::Optional<uint8_t> battery_pct_estimate = flatbuffers::nullopt,
    flatbuffers::Offset<solarxr_protocol::datatypes::LogData> log_data = 0) {
  HardwareStatusBuilder builder_(_fbb);
  builder_.add_log_data(log_data);
  if(battery_voltage) { builder_.add_battery_voltage(*battery_voltage); }
  if(mcu_temp) { builder_.add_mcu_temp(*mcu_temp); }
  if(rssi) { builder_.add_rssi(*rssi); }
  if(ping) { builder_.add_ping(*ping); }
  if(battery_pct_estimate) { builder_.add_battery_pct_estimate(*battery_pct_estimate); }
  if(error_status) { builder_.add_error_status(*error_status); }
  return builder_.Finish();
}

/// A mask of the data in `FirmwareStatus`
struct FirmwareStatusMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FirmwareStatusMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_STATUS = 4,
    VT_TPS = 6,
    VT_PING = 8,
    VT_RSSI = 10,
    VT_MCU_TEMP = 12,
    VT_BATTERY_VOLTAGE = 14,
    VT_BATTERY_PCT_ESTIMATE = 16
  };
  bool error_status() const {
    return GetField<uint8_t>(VT_ERROR_STATUS, 0) != 0;
  }
  bool tps() const {
    return GetField<uint8_t>(VT_TPS, 0) != 0;
  }
  bool ping() const {
    return GetField<uint8_t>(VT_PING, 0) != 0;
  }
  bool rssi() const {
    return GetField<uint8_t>(VT_RSSI, 0) != 0;
  }
  bool mcu_temp() const {
    return GetField<uint8_t>(VT_MCU_TEMP, 0) != 0;
  }
  bool battery_voltage() const {
    return GetField<uint8_t>(VT_BATTERY_VOLTAGE, 0) != 0;
  }
  bool battery_pct_estimate() const {
    return GetField<uint8_t>(VT_BATTERY_PCT_ESTIMATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ERROR_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_TPS, 1) &&
           VerifyField<uint8_t>(verifier, VT_PING, 1) &&
           VerifyField<uint8_t>(verifier, VT_RSSI, 1) &&
           VerifyField<uint8_t>(verifier, VT_MCU_TEMP, 1) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_VOLTAGE, 1) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_PCT_ESTIMATE, 1) &&
           verifier.EndTable();
  }
};

struct FirmwareStatusMaskBuilder {
  typedef FirmwareStatusMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_status(bool error_status) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_ERROR_STATUS, static_cast<uint8_t>(error_status), 0);
  }
  void add_tps(bool tps) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_TPS, static_cast<uint8_t>(tps), 0);
  }
  void add_ping(bool ping) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_PING, static_cast<uint8_t>(ping), 0);
  }
  void add_rssi(bool rssi) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_RSSI, static_cast<uint8_t>(rssi), 0);
  }
  void add_mcu_temp(bool mcu_temp) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_MCU_TEMP, static_cast<uint8_t>(mcu_temp), 0);
  }
  void add_battery_voltage(bool battery_voltage) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_BATTERY_VOLTAGE, static_cast<uint8_t>(battery_voltage), 0);
  }
  void add_battery_pct_estimate(bool battery_pct_estimate) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_BATTERY_PCT_ESTIMATE, static_cast<uint8_t>(battery_pct_estimate), 0);
  }
  explicit FirmwareStatusMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FirmwareStatusMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FirmwareStatusMask>(end);
    return o;
  }
};

inline flatbuffers::Offset<FirmwareStatusMask> CreateFirmwareStatusMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool error_status = false,
    bool tps = false,
    bool ping = false,
    bool rssi = false,
    bool mcu_temp = false,
    bool battery_voltage = false,
    bool battery_pct_estimate = false) {
  FirmwareStatusMaskBuilder builder_(_fbb);
  builder_.add_battery_pct_estimate(battery_pct_estimate);
  builder_.add_battery_voltage(battery_voltage);
  builder_.add_mcu_temp(mcu_temp);
  builder_.add_rssi(rssi);
  builder_.add_ping(ping);
  builder_.add_tps(tps);
  builder_.add_error_status(error_status);
  return builder_.Finish();
}

}  // namespace hardware_info
}  // namespace datatypes

namespace data_feed {
namespace tracker {

/// Describes all possible information about a tracker. A tracker is anything that
/// provides kinematic data about a particular body part.
///
/// Trackers may be synthetic/computed or instead part of an actual hardware device.
/// There can be multiple trackers per hardware device.
struct TrackerData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackerDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACKER_ID = 4,
    VT_INFO = 6,
    VT_STATUS = 8,
    VT_ROTATION = 10,
    VT_POSITION = 12,
    VT_RAW_ANGULAR_VELOCITY = 14,
    VT_RAW_ACCELERATION = 16,
    VT_TEMP = 18,
    VT_LINEAR_ACCELERATION = 20,
    VT_ROTATION_REFERENCE_ADJUSTED = 22,
    VT_ROTATION_IDENTITY_ADJUSTED = 24,
    VT_TPS = 26
  };
  const solarxr_protocol::datatypes::TrackerId *tracker_id() const {
    return GetPointer<const solarxr_protocol::datatypes::TrackerId *>(VT_TRACKER_ID);
  }
  const solarxr_protocol::data_feed::tracker::TrackerInfo *info() const {
    return GetPointer<const solarxr_protocol::data_feed::tracker::TrackerInfo *>(VT_INFO);
  }
  solarxr_protocol::datatypes::TrackerStatus status() const {
    return static_cast<solarxr_protocol::datatypes::TrackerStatus>(GetField<uint8_t>(VT_STATUS, 0));
  }
  /// Sensor rotation after fusion
  const solarxr_protocol::datatypes::math::Quat *rotation() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_ROTATION);
  }
  /// Position, in meters
  const solarxr_protocol::datatypes::math::Vec3f *position() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Vec3f *>(VT_POSITION);
  }
  /// Raw angular velocity, in euler angles, rad/s
  const solarxr_protocol::datatypes::math::Vec3f *raw_angular_velocity() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Vec3f *>(VT_RAW_ANGULAR_VELOCITY);
  }
  /// Raw acceleration, in m/s^2
  const solarxr_protocol::datatypes::math::Vec3f *raw_acceleration() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Vec3f *>(VT_RAW_ACCELERATION);
  }
  /// Temperature, in degrees celsius
  const solarxr_protocol::datatypes::Temperature *temp() const {
    return GetStruct<const solarxr_protocol::datatypes::Temperature *>(VT_TEMP);
  }
  /// Acceleration without gravity, in m/s^2
  const solarxr_protocol::datatypes::math::Vec3f *linear_acceleration() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Vec3f *>(VT_LINEAR_ACCELERATION);
  }
  /// Reference-adjusted rotation for IMU-only trackers (VR HMD yaw is used as a reset reference).
  /// In other words, a rotation that is aligned to a reliable source of rotation ((0, VR HMD YAW, 0)),
  /// triggered after user input (using reset buttons).
  /// This is a SlimeVR-specific field and computed exclusively by SlimeVR server.
  /// Includes: mounting orientation, full, quick and mounting reset adjustments.
  /// This rotation can be used to reconstruct a skeleton pose using forward kinematics.
  const solarxr_protocol::datatypes::math::Quat *rotation_reference_adjusted() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_ROTATION_REFERENCE_ADJUSTED);
  }
  /// Zero-reference-adjusted rotation for IMU-only trackers (identity quaternion is used as a reset reference).
  /// In other words, a rotation that is aligned to a zero vector ((0, 0, 0)) by
  /// inverting the current rotation, triggered after user input (using reset buttons).
  /// This is a SlimeVR-specific field and computed exclusively by SlimeVR server.
  /// Includes: only full and quick reset adjustments.
  /// This rotation can be used in visualizations for IMU debugging.
  const solarxr_protocol::datatypes::math::Quat *rotation_identity_adjusted() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_ROTATION_IDENTITY_ADJUSTED);
  }
  /// Data ticks per second, processed by SlimeVR server
  flatbuffers::Optional<uint16_t> tps() const {
    return GetOptional<uint16_t, uint16_t>(VT_TPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACKER_ID) &&
           verifier.VerifyTable(tracker_id()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_ROTATION, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Vec3f>(verifier, VT_POSITION, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Vec3f>(verifier, VT_RAW_ANGULAR_VELOCITY, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Vec3f>(verifier, VT_RAW_ACCELERATION, 4) &&
           VerifyField<solarxr_protocol::datatypes::Temperature>(verifier, VT_TEMP, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Vec3f>(verifier, VT_LINEAR_ACCELERATION, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_ROTATION_REFERENCE_ADJUSTED, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_ROTATION_IDENTITY_ADJUSTED, 4) &&
           VerifyField<uint16_t>(verifier, VT_TPS, 2) &&
           verifier.EndTable();
  }
};

struct TrackerDataBuilder {
  typedef TrackerData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tracker_id(flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id) {
    fbb_.AddOffset(TrackerData::VT_TRACKER_ID, tracker_id);
  }
  void add_info(flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerInfo> info) {
    fbb_.AddOffset(TrackerData::VT_INFO, info);
  }
  void add_status(solarxr_protocol::datatypes::TrackerStatus status) {
    fbb_.AddElement<uint8_t>(TrackerData::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_rotation(const solarxr_protocol::datatypes::math::Quat *rotation) {
    fbb_.AddStruct(TrackerData::VT_ROTATION, rotation);
  }
  void add_position(const solarxr_protocol::datatypes::math::Vec3f *position) {
    fbb_.AddStruct(TrackerData::VT_POSITION, position);
  }
  void add_raw_angular_velocity(const solarxr_protocol::datatypes::math::Vec3f *raw_angular_velocity) {
    fbb_.AddStruct(TrackerData::VT_RAW_ANGULAR_VELOCITY, raw_angular_velocity);
  }
  void add_raw_acceleration(const solarxr_protocol::datatypes::math::Vec3f *raw_acceleration) {
    fbb_.AddStruct(TrackerData::VT_RAW_ACCELERATION, raw_acceleration);
  }
  void add_temp(const solarxr_protocol::datatypes::Temperature *temp) {
    fbb_.AddStruct(TrackerData::VT_TEMP, temp);
  }
  void add_linear_acceleration(const solarxr_protocol::datatypes::math::Vec3f *linear_acceleration) {
    fbb_.AddStruct(TrackerData::VT_LINEAR_ACCELERATION, linear_acceleration);
  }
  void add_rotation_reference_adjusted(const solarxr_protocol::datatypes::math::Quat *rotation_reference_adjusted) {
    fbb_.AddStruct(TrackerData::VT_ROTATION_REFERENCE_ADJUSTED, rotation_reference_adjusted);
  }
  void add_rotation_identity_adjusted(const solarxr_protocol::datatypes::math::Quat *rotation_identity_adjusted) {
    fbb_.AddStruct(TrackerData::VT_ROTATION_IDENTITY_ADJUSTED, rotation_identity_adjusted);
  }
  void add_tps(uint16_t tps) {
    fbb_.AddElement<uint16_t>(TrackerData::VT_TPS, tps);
  }
  explicit TrackerDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrackerData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackerData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackerData> CreateTrackerData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id = 0,
    flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerInfo> info = 0,
    solarxr_protocol::datatypes::TrackerStatus status = solarxr_protocol::datatypes::TrackerStatus::NONE,
    const solarxr_protocol::datatypes::math::Quat *rotation = nullptr,
    const solarxr_protocol::datatypes::math::Vec3f *position = nullptr,
    const solarxr_protocol::datatypes::math::Vec3f *raw_angular_velocity = nullptr,
    const solarxr_protocol::datatypes::math::Vec3f *raw_acceleration = nullptr,
    const solarxr_protocol::datatypes::Temperature *temp = nullptr,
    const solarxr_protocol::datatypes::math::Vec3f *linear_acceleration = nullptr,
    const solarxr_protocol::datatypes::math::Quat *rotation_reference_adjusted = nullptr,
    const solarxr_protocol::datatypes::math::Quat *rotation_identity_adjusted = nullptr,
    flatbuffers::Optional<uint16_t> tps = flatbuffers::nullopt) {
  TrackerDataBuilder builder_(_fbb);
  builder_.add_rotation_identity_adjusted(rotation_identity_adjusted);
  builder_.add_rotation_reference_adjusted(rotation_reference_adjusted);
  builder_.add_linear_acceleration(linear_acceleration);
  builder_.add_temp(temp);
  builder_.add_raw_acceleration(raw_acceleration);
  builder_.add_raw_angular_velocity(raw_angular_velocity);
  builder_.add_position(position);
  builder_.add_rotation(rotation);
  builder_.add_info(info);
  builder_.add_tracker_id(tracker_id);
  if(tps) { builder_.add_tps(*tps); }
  builder_.add_status(status);
  return builder_.Finish();
}

/// A mask of the different components in `TrackerComponent`
struct TrackerDataMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackerDataMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_STATUS = 6,
    VT_ROTATION = 8,
    VT_POSITION = 10,
    VT_RAW_ANGULAR_VELOCITY = 12,
    VT_RAW_ACCELERATION = 14,
    VT_TEMP = 16,
    VT_LINEAR_ACCELERATION = 18,
    VT_ROTATION_REFERENCE_ADJUSTED = 20,
    VT_ROTATION_IDENTITY_ADJUSTED = 22,
    VT_TPS = 24
  };
  bool info() const {
    return GetField<uint8_t>(VT_INFO, 0) != 0;
  }
  bool status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  bool rotation() const {
    return GetField<uint8_t>(VT_ROTATION, 0) != 0;
  }
  bool position() const {
    return GetField<uint8_t>(VT_POSITION, 0) != 0;
  }
  bool raw_angular_velocity() const {
    return GetField<uint8_t>(VT_RAW_ANGULAR_VELOCITY, 0) != 0;
  }
  bool raw_acceleration() const {
    return GetField<uint8_t>(VT_RAW_ACCELERATION, 0) != 0;
  }
  bool temp() const {
    return GetField<uint8_t>(VT_TEMP, 0) != 0;
  }
  bool linear_acceleration() const {
    return GetField<uint8_t>(VT_LINEAR_ACCELERATION, 0) != 0;
  }
  bool rotation_reference_adjusted() const {
    return GetField<uint8_t>(VT_ROTATION_REFERENCE_ADJUSTED, 0) != 0;
  }
  bool rotation_identity_adjusted() const {
    return GetField<uint8_t>(VT_ROTATION_IDENTITY_ADJUSTED, 0) != 0;
  }
  bool tps() const {
    return GetField<uint8_t>(VT_TPS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INFO, 1) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_ROTATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_POSITION, 1) &&
           VerifyField<uint8_t>(verifier, VT_RAW_ANGULAR_VELOCITY, 1) &&
           VerifyField<uint8_t>(verifier, VT_RAW_ACCELERATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_TEMP, 1) &&
           VerifyField<uint8_t>(verifier, VT_LINEAR_ACCELERATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_ROTATION_REFERENCE_ADJUSTED, 1) &&
           VerifyField<uint8_t>(verifier, VT_ROTATION_IDENTITY_ADJUSTED, 1) &&
           VerifyField<uint8_t>(verifier, VT_TPS, 1) &&
           verifier.EndTable();
  }
};

struct TrackerDataMaskBuilder {
  typedef TrackerDataMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(bool info) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_INFO, static_cast<uint8_t>(info), 0);
  }
  void add_status(bool status) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_rotation(bool rotation) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_ROTATION, static_cast<uint8_t>(rotation), 0);
  }
  void add_position(bool position) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_POSITION, static_cast<uint8_t>(position), 0);
  }
  void add_raw_angular_velocity(bool raw_angular_velocity) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_RAW_ANGULAR_VELOCITY, static_cast<uint8_t>(raw_angular_velocity), 0);
  }
  void add_raw_acceleration(bool raw_acceleration) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_RAW_ACCELERATION, static_cast<uint8_t>(raw_acceleration), 0);
  }
  void add_temp(bool temp) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_TEMP, static_cast<uint8_t>(temp), 0);
  }
  void add_linear_acceleration(bool linear_acceleration) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_LINEAR_ACCELERATION, static_cast<uint8_t>(linear_acceleration), 0);
  }
  void add_rotation_reference_adjusted(bool rotation_reference_adjusted) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_ROTATION_REFERENCE_ADJUSTED, static_cast<uint8_t>(rotation_reference_adjusted), 0);
  }
  void add_rotation_identity_adjusted(bool rotation_identity_adjusted) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_ROTATION_IDENTITY_ADJUSTED, static_cast<uint8_t>(rotation_identity_adjusted), 0);
  }
  void add_tps(bool tps) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_TPS, static_cast<uint8_t>(tps), 0);
  }
  explicit TrackerDataMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrackerDataMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackerDataMask>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackerDataMask> CreateTrackerDataMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool info = false,
    bool status = false,
    bool rotation = false,
    bool position = false,
    bool raw_angular_velocity = false,
    bool raw_acceleration = false,
    bool temp = false,
    bool linear_acceleration = false,
    bool rotation_reference_adjusted = false,
    bool rotation_identity_adjusted = false,
    bool tps = false) {
  TrackerDataMaskBuilder builder_(_fbb);
  builder_.add_tps(tps);
  builder_.add_rotation_identity_adjusted(rotation_identity_adjusted);
  builder_.add_rotation_reference_adjusted(rotation_reference_adjusted);
  builder_.add_linear_acceleration(linear_acceleration);
  builder_.add_temp(temp);
  builder_.add_raw_acceleration(raw_acceleration);
  builder_.add_raw_angular_velocity(raw_angular_velocity);
  builder_.add_position(position);
  builder_.add_rotation(rotation);
  builder_.add_status(status);
  builder_.add_info(info);
  return builder_.Finish();
}

/// Static description of a tracker
struct TrackerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMU_TYPE = 4,
    VT_BODY_PART = 6,
    VT_POLL_RATE = 8,
    VT_MOUNTING_ORIENTATION = 10,
    VT_EDITABLE = 12,
    VT_IS_COMPUTED = 14,
    VT_IS_IMU = 16,
    VT_DISPLAY_NAME = 18,
    VT_CUSTOM_NAME = 20,
    VT_ALLOW_DRIFT_COMPENSATION = 22,
    VT_MOUNTING_RESET_ORIENTATION = 24
  };
  solarxr_protocol::datatypes::hardware_info::ImuType imu_type() const {
    return static_cast<solarxr_protocol::datatypes::hardware_info::ImuType>(GetField<uint16_t>(VT_IMU_TYPE, 0));
  }
  /// The user-assigned role of the tracker.
  solarxr_protocol::datatypes::BodyPart body_part() const {
    return static_cast<solarxr_protocol::datatypes::BodyPart>(GetField<uint8_t>(VT_BODY_PART, 0));
  }
  /// average samples per second
  const solarxr_protocol::datatypes::HzF32 *poll_rate() const {
    return GetStruct<const solarxr_protocol::datatypes::HzF32 *>(VT_POLL_RATE);
  }
  /// The orientation of the tracker when mounted on the body
  const solarxr_protocol::datatypes::math::Quat *mounting_orientation() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_MOUNTING_ORIENTATION);
  }
  /// Should the tracker's settings be editable by the user
  bool editable() const {
    return GetField<uint8_t>(VT_EDITABLE, 0) != 0;
  }
  /// Indicates if the tracker is computed (solved position and rotation)
  bool is_computed() const {
    return GetField<uint8_t>(VT_IS_COMPUTED, 0) != 0;
  }
  /// Indicates if the tracker is using an IMU for its tracking data
  bool is_imu() const {
    return GetField<uint8_t>(VT_IS_IMU, 0) != 0;
  }
  /// A human-friendly name to display as the name of the tracker.
  const flatbuffers::String *display_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  /// name to display as the name of the tracker set by the user
  const flatbuffers::String *custom_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CUSTOM_NAME);
  }
  /// Whether to allow yaw drift compensation for this tracker or not.
  bool allow_drift_compensation() const {
    return GetField<uint8_t>(VT_ALLOW_DRIFT_COMPENSATION, 0) != 0;
  }
  /// Mounting Reset orientation overrides the current `mounting_orientation` of
  /// the tracker, this orientation is not saved and needs to be calculated
  /// each time the server is ran
  const solarxr_protocol::datatypes::math::Quat *mounting_reset_orientation() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_MOUNTING_RESET_ORIENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_IMU_TYPE, 2) &&
           VerifyField<uint8_t>(verifier, VT_BODY_PART, 1) &&
           VerifyField<solarxr_protocol::datatypes::HzF32>(verifier, VT_POLL_RATE, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_MOUNTING_ORIENTATION, 4) &&
           VerifyField<uint8_t>(verifier, VT_EDITABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_COMPUTED, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_IMU, 1) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyOffset(verifier, VT_CUSTOM_NAME) &&
           verifier.VerifyString(custom_name()) &&
           VerifyField<uint8_t>(verifier, VT_ALLOW_DRIFT_COMPENSATION, 1) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_MOUNTING_RESET_ORIENTATION, 4) &&
           verifier.EndTable();
  }
};

struct TrackerInfoBuilder {
  typedef TrackerInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_imu_type(solarxr_protocol::datatypes::hardware_info::ImuType imu_type) {
    fbb_.AddElement<uint16_t>(TrackerInfo::VT_IMU_TYPE, static_cast<uint16_t>(imu_type), 0);
  }
  void add_body_part(solarxr_protocol::datatypes::BodyPart body_part) {
    fbb_.AddElement<uint8_t>(TrackerInfo::VT_BODY_PART, static_cast<uint8_t>(body_part), 0);
  }
  void add_poll_rate(const solarxr_protocol::datatypes::HzF32 *poll_rate) {
    fbb_.AddStruct(TrackerInfo::VT_POLL_RATE, poll_rate);
  }
  void add_mounting_orientation(const solarxr_protocol::datatypes::math::Quat *mounting_orientation) {
    fbb_.AddStruct(TrackerInfo::VT_MOUNTING_ORIENTATION, mounting_orientation);
  }
  void add_editable(bool editable) {
    fbb_.AddElement<uint8_t>(TrackerInfo::VT_EDITABLE, static_cast<uint8_t>(editable), 0);
  }
  void add_is_computed(bool is_computed) {
    fbb_.AddElement<uint8_t>(TrackerInfo::VT_IS_COMPUTED, static_cast<uint8_t>(is_computed), 0);
  }
  void add_is_imu(bool is_imu) {
    fbb_.AddElement<uint8_t>(TrackerInfo::VT_IS_IMU, static_cast<uint8_t>(is_imu), 0);
  }
  void add_display_name(flatbuffers::Offset<flatbuffers::String> display_name) {
    fbb_.AddOffset(TrackerInfo::VT_DISPLAY_NAME, display_name);
  }
  void add_custom_name(flatbuffers::Offset<flatbuffers::String> custom_name) {
    fbb_.AddOffset(TrackerInfo::VT_CUSTOM_NAME, custom_name);
  }
  void add_allow_drift_compensation(bool allow_drift_compensation) {
    fbb_.AddElement<uint8_t>(TrackerInfo::VT_ALLOW_DRIFT_COMPENSATION, static_cast<uint8_t>(allow_drift_compensation), 0);
  }
  void add_mounting_reset_orientation(const solarxr_protocol::datatypes::math::Quat *mounting_reset_orientation) {
    fbb_.AddStruct(TrackerInfo::VT_MOUNTING_RESET_ORIENTATION, mounting_reset_orientation);
  }
  explicit TrackerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrackerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackerInfo> CreateTrackerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::hardware_info::ImuType imu_type = solarxr_protocol::datatypes::hardware_info::ImuType::Other,
    solarxr_protocol::datatypes::BodyPart body_part = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::HzF32 *poll_rate = nullptr,
    const solarxr_protocol::datatypes::math::Quat *mounting_orientation = nullptr,
    bool editable = false,
    bool is_computed = false,
    bool is_imu = false,
    flatbuffers::Offset<flatbuffers::String> display_name = 0,
    flatbuffers::Offset<flatbuffers::String> custom_name = 0,
    bool allow_drift_compensation = false,
    const solarxr_protocol::datatypes::math::Quat *mounting_reset_orientation = nullptr) {
  TrackerInfoBuilder builder_(_fbb);
  builder_.add_mounting_reset_orientation(mounting_reset_orientation);
  builder_.add_custom_name(custom_name);
  builder_.add_display_name(display_name);
  builder_.add_mounting_orientation(mounting_orientation);
  builder_.add_poll_rate(poll_rate);
  builder_.add_imu_type(imu_type);
  builder_.add_allow_drift_compensation(allow_drift_compensation);
  builder_.add_is_imu(is_imu);
  builder_.add_is_computed(is_computed);
  builder_.add_editable(editable);
  builder_.add_body_part(body_part);
  return builder_.Finish();
}

inline flatbuffers::Offset<TrackerInfo> CreateTrackerInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::hardware_info::ImuType imu_type = solarxr_protocol::datatypes::hardware_info::ImuType::Other,
    solarxr_protocol::datatypes::BodyPart body_part = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::HzF32 *poll_rate = nullptr,
    const solarxr_protocol::datatypes::math::Quat *mounting_orientation = nullptr,
    bool editable = false,
    bool is_computed = false,
    bool is_imu = false,
    const char *display_name = nullptr,
    const char *custom_name = nullptr,
    bool allow_drift_compensation = false,
    const solarxr_protocol::datatypes::math::Quat *mounting_reset_orientation = nullptr) {
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  auto custom_name__ = custom_name ? _fbb.CreateString(custom_name) : 0;
  return solarxr_protocol::data_feed::tracker::CreateTrackerInfo(
      _fbb,
      imu_type,
      body_part,
      poll_rate,
      mounting_orientation,
      editable,
      is_computed,
      is_imu,
      display_name__,
      custom_name__,
      allow_drift_compensation,
      mounting_reset_orientation);
}

}  // namespace tracker

namespace device_data {

/// A mask of values to be reported in subsequent DeviceStatus. Values set to `false`
/// or `null` will not reported. By default, all fields are false/null.
///
/// If you set a value to `true`, it is not guaranteed that the sender actually has
/// such a value to send. In this case, they will probably send `null`, and the receiver
/// has the choice to disconnect due to missing data.
struct DeviceDataMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceDataMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACKER_DATA = 4,
    VT_DEVICE_DATA = 6
  };
  /// Which tracker data should be sent in this data feed
  const solarxr_protocol::data_feed::tracker::TrackerDataMask *tracker_data() const {
    return GetPointer<const solarxr_protocol::data_feed::tracker::TrackerDataMask *>(VT_TRACKER_DATA);
  }
  /// true if device data should be sent in this data feed
  bool device_data() const {
    return GetField<uint8_t>(VT_DEVICE_DATA, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACKER_DATA) &&
           verifier.VerifyTable(tracker_data()) &&
           VerifyField<uint8_t>(verifier, VT_DEVICE_DATA, 1) &&
           verifier.EndTable();
  }
};

struct DeviceDataMaskBuilder {
  typedef DeviceDataMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tracker_data(flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerDataMask> tracker_data) {
    fbb_.AddOffset(DeviceDataMask::VT_TRACKER_DATA, tracker_data);
  }
  void add_device_data(bool device_data) {
    fbb_.AddElement<uint8_t>(DeviceDataMask::VT_DEVICE_DATA, static_cast<uint8_t>(device_data), 0);
  }
  explicit DeviceDataMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceDataMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceDataMask>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceDataMask> CreateDeviceDataMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerDataMask> tracker_data = 0,
    bool device_data = false) {
  DeviceDataMaskBuilder builder_(_fbb);
  builder_.add_tracker_data(tracker_data);
  builder_.add_device_data(device_data);
  return builder_.Finish();
}

/// Describes all possible information about a hardware device. For example, a
/// vive tracker is a  single hardware device, and a slime tracker with two
/// extensions is a single hardware device but two trackers.
struct DeviceData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CUSTOM_NAME = 6,
    VT_HARDWARE_INFO = 8,
    VT_HARDWARE_STATUS = 10,
    VT_TRACKERS = 12
  };
  const solarxr_protocol::datatypes::DeviceId *id() const {
    return GetStruct<const solarxr_protocol::datatypes::DeviceId *>(VT_ID);
  }
  /// The dynamically changeable name of the device. This might be set by the
  /// user to help them remember which tracker is which.
  const flatbuffers::String *custom_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CUSTOM_NAME);
  }
  /// Mostly-static info about the device hardware
  const solarxr_protocol::datatypes::hardware_info::HardwareInfo *hardware_info() const {
    return GetPointer<const solarxr_protocol::datatypes::hardware_info::HardwareInfo *>(VT_HARDWARE_INFO);
  }
  /// General info about the status of the device
  const solarxr_protocol::datatypes::hardware_info::HardwareStatus *hardware_status() const {
    return GetPointer<const solarxr_protocol::datatypes::hardware_info::HardwareStatus *>(VT_HARDWARE_STATUS);
  }
  /// Info about all trackers attached to this device
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>> *trackers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>> *>(VT_TRACKERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<solarxr_protocol::datatypes::DeviceId>(verifier, VT_ID, 1) &&
           VerifyOffset(verifier, VT_CUSTOM_NAME) &&
           verifier.VerifyString(custom_name()) &&
           VerifyOffset(verifier, VT_HARDWARE_INFO) &&
           verifier.VerifyTable(hardware_info()) &&
           VerifyOffset(verifier, VT_HARDWARE_STATUS) &&
           verifier.VerifyTable(hardware_status()) &&
           VerifyOffset(verifier, VT_TRACKERS) &&
           verifier.VerifyVector(trackers()) &&
           verifier.VerifyVectorOfTables(trackers()) &&
           verifier.EndTable();
  }
};

struct DeviceDataBuilder {
  typedef DeviceData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(const solarxr_protocol::datatypes::DeviceId *id) {
    fbb_.AddStruct(DeviceData::VT_ID, id);
  }
  void add_custom_name(flatbuffers::Offset<flatbuffers::String> custom_name) {
    fbb_.AddOffset(DeviceData::VT_CUSTOM_NAME, custom_name);
  }
  void add_hardware_info(flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareInfo> hardware_info) {
    fbb_.AddOffset(DeviceData::VT_HARDWARE_INFO, hardware_info);
  }
  void add_hardware_status(flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareStatus> hardware_status) {
    fbb_.AddOffset(DeviceData::VT_HARDWARE_STATUS, hardware_status);
  }
  void add_trackers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>>> trackers) {
    fbb_.AddOffset(DeviceData::VT_TRACKERS, trackers);
  }
  explicit DeviceDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceData> CreateDeviceData(
    flatbuffers::FlatBufferBuilder &_fbb,
    const solarxr_protocol::datatypes::DeviceId *id = nullptr,
    flatbuffers::Offset<flatbuffers::String> custom_name = 0,
    flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareInfo> hardware_info = 0,
    flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareStatus> hardware_status = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>>> trackers = 0) {
  DeviceDataBuilder builder_(_fbb);
  builder_.add_trackers(trackers);
  builder_.add_hardware_status(hardware_status);
  builder_.add_hardware_info(hardware_info);
  builder_.add_custom_name(custom_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceData> CreateDeviceDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const solarxr_protocol::datatypes::DeviceId *id = nullptr,
    const char *custom_name = nullptr,
    flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareInfo> hardware_info = 0,
    flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareStatus> hardware_status = 0,
    const std::vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>> *trackers = nullptr) {
  auto custom_name__ = custom_name ? _fbb.CreateString(custom_name) : 0;
  auto trackers__ = trackers ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>>(*trackers) : 0;
  return solarxr_protocol::data_feed::device_data::CreateDeviceData(
      _fbb,
      id,
      custom_name__,
      hardware_info,
      hardware_status,
      trackers__);
}

}  // namespace device_data

struct Bone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoneBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BODY_PART = 4,
    VT_ROTATION_G = 6,
    VT_BONE_LENGTH = 8,
    VT_HEAD_POSITION_G = 10
  };
  solarxr_protocol::datatypes::BodyPart body_part() const {
    return static_cast<solarxr_protocol::datatypes::BodyPart>(GetField<uint8_t>(VT_BODY_PART, 0));
  }
  /// The global rotation of the bone.
  ///
  /// Note that the identity rotation is where a bone's tail is towards -y (assuming
  /// the head of the bone is the origin)
  const solarxr_protocol::datatypes::math::Quat *rotation_g() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_ROTATION_G);
  }
  float bone_length() const {
    return GetField<float>(VT_BONE_LENGTH, 0.0f);
  }
  /// The global position of the head of this bone.
  ///
  /// The head of a bone is joint/node of the bone touching the parent bone. The
  /// parent is defined as the bone closer to the HMD.
  const solarxr_protocol::datatypes::math::Vec3f *head_position_g() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Vec3f *>(VT_HEAD_POSITION_G);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BODY_PART, 1) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_ROTATION_G, 4) &&
           VerifyField<float>(verifier, VT_BONE_LENGTH, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Vec3f>(verifier, VT_HEAD_POSITION_G, 4) &&
           verifier.EndTable();
  }
};

struct BoneBuilder {
  typedef Bone Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_body_part(solarxr_protocol::datatypes::BodyPart body_part) {
    fbb_.AddElement<uint8_t>(Bone::VT_BODY_PART, static_cast<uint8_t>(body_part), 0);
  }
  void add_rotation_g(const solarxr_protocol::datatypes::math::Quat *rotation_g) {
    fbb_.AddStruct(Bone::VT_ROTATION_G, rotation_g);
  }
  void add_bone_length(float bone_length) {
    fbb_.AddElement<float>(Bone::VT_BONE_LENGTH, bone_length, 0.0f);
  }
  void add_head_position_g(const solarxr_protocol::datatypes::math::Vec3f *head_position_g) {
    fbb_.AddStruct(Bone::VT_HEAD_POSITION_G, head_position_g);
  }
  explicit BoneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Bone> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bone>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bone> CreateBone(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::BodyPart body_part = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::math::Quat *rotation_g = nullptr,
    float bone_length = 0.0f,
    const solarxr_protocol::datatypes::math::Vec3f *head_position_g = nullptr) {
  BoneBuilder builder_(_fbb);
  builder_.add_head_position_g(head_position_g);
  builder_.add_bone_length(bone_length);
  builder_.add_rotation_g(rotation_g);
  builder_.add_body_part(body_part);
  return builder_.Finish();
}

struct DataFeedMessageHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataFeedMessageHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  solarxr_protocol::data_feed::DataFeedMessage message_type() const {
    return static_cast<solarxr_protocol::data_feed::DataFeedMessage>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const solarxr_protocol::data_feed::PollDataFeed *message_as_PollDataFeed() const {
    return message_type() == solarxr_protocol::data_feed::DataFeedMessage::PollDataFeed ? static_cast<const solarxr_protocol::data_feed::PollDataFeed *>(message()) : nullptr;
  }
  const solarxr_protocol::data_feed::StartDataFeed *message_as_StartDataFeed() const {
    return message_type() == solarxr_protocol::data_feed::DataFeedMessage::StartDataFeed ? static_cast<const solarxr_protocol::data_feed::StartDataFeed *>(message()) : nullptr;
  }
  const solarxr_protocol::data_feed::DataFeedUpdate *message_as_DataFeedUpdate() const {
    return message_type() == solarxr_protocol::data_feed::DataFeedMessage::DataFeedUpdate ? static_cast<const solarxr_protocol::data_feed::DataFeedUpdate *>(message()) : nullptr;
  }
  const solarxr_protocol::data_feed::DataFeedConfig *message_as_DataFeedConfig() const {
    return message_type() == solarxr_protocol::data_feed::DataFeedMessage::DataFeedConfig ? static_cast<const solarxr_protocol::data_feed::DataFeedConfig *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyDataFeedMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::data_feed::PollDataFeed *DataFeedMessageHeader::message_as<solarxr_protocol::data_feed::PollDataFeed>() const {
  return message_as_PollDataFeed();
}

template<> inline const solarxr_protocol::data_feed::StartDataFeed *DataFeedMessageHeader::message_as<solarxr_protocol::data_feed::StartDataFeed>() const {
  return message_as_StartDataFeed();
}

template<> inline const solarxr_protocol::data_feed::DataFeedUpdate *DataFeedMessageHeader::message_as<solarxr_protocol::data_feed::DataFeedUpdate>() const {
  return message_as_DataFeedUpdate();
}

template<> inline const solarxr_protocol::data_feed::DataFeedConfig *DataFeedMessageHeader::message_as<solarxr_protocol::data_feed::DataFeedConfig>() const {
  return message_as_DataFeedConfig();
}

struct DataFeedMessageHeaderBuilder {
  typedef DataFeedMessageHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(solarxr_protocol::data_feed::DataFeedMessage message_type) {
    fbb_.AddElement<uint8_t>(DataFeedMessageHeader::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(DataFeedMessageHeader::VT_MESSAGE, message);
  }
  explicit DataFeedMessageHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataFeedMessageHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFeedMessageHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFeedMessageHeader> CreateDataFeedMessageHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::data_feed::DataFeedMessage message_type = solarxr_protocol::data_feed::DataFeedMessage::NONE,
    flatbuffers::Offset<void> message = 0) {
  DataFeedMessageHeaderBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

/// Requests for a single `Update` to be sent. This is helpful when getting
/// initial info about the device.
struct PollDataFeed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PollDataFeedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIG = 4
  };
  const solarxr_protocol::data_feed::DataFeedConfig *config() const {
    return GetPointer<const solarxr_protocol::data_feed::DataFeedConfig *>(VT_CONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           verifier.EndTable();
  }
};

struct PollDataFeedBuilder {
  typedef PollDataFeed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_config(flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig> config) {
    fbb_.AddOffset(PollDataFeed::VT_CONFIG, config);
  }
  explicit PollDataFeedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PollDataFeed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PollDataFeed>(end);
    return o;
  }
};

inline flatbuffers::Offset<PollDataFeed> CreatePollDataFeed(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig> config = 0) {
  PollDataFeedBuilder builder_(_fbb);
  builder_.add_config(config);
  return builder_.Finish();
}

/// Requests for the other party to send `data_feeds`.
/// For example, GUI requests for position data to be sent from server.
///
/// When sending a new `StartFeed`, the old data feeds should stop being sent.
/// We still support multiple data feeds at the same time, because `data_feeds`
/// is a list.
///
/// Multiple data feeds are useful to get data at different frequencies.
struct StartDataFeed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StartDataFeedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_FEEDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig>> *data_feeds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig>> *>(VT_DATA_FEEDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA_FEEDS) &&
           verifier.VerifyVector(data_feeds()) &&
           verifier.VerifyVectorOfTables(data_feeds()) &&
           verifier.EndTable();
  }
};

struct StartDataFeedBuilder {
  typedef StartDataFeed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_feeds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig>>> data_feeds) {
    fbb_.AddOffset(StartDataFeed::VT_DATA_FEEDS, data_feeds);
  }
  explicit StartDataFeedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StartDataFeed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartDataFeed>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartDataFeed> CreateStartDataFeed(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig>>> data_feeds = 0) {
  StartDataFeedBuilder builder_(_fbb);
  builder_.add_data_feeds(data_feeds);
  return builder_.Finish();
}

inline flatbuffers::Offset<StartDataFeed> CreateStartDataFeedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig>> *data_feeds = nullptr) {
  auto data_feeds__ = data_feeds ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedConfig>>(*data_feeds) : 0;
  return solarxr_protocol::data_feed::CreateStartDataFeed(
      _fbb,
      data_feeds__);
}

/// All of the data components related to a single data feed. A data feed is comprised
/// of device data, and tracker data.
///
/// A data feed might send data only when it changes/updates, and we should make no
/// assumptions that the data is actually delivered. If you want to guarantee
/// delivery and avoid dropped observations of data (such as a user-initiated
/// button press), it is better to use the RPC system.
struct DataFeedUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataFeedUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICES = 4,
    VT_SYNTHETIC_TRACKERS = 6,
    VT_BONES = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceData>> *devices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceData>> *>(VT_DEVICES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>> *synthetic_trackers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>> *>(VT_SYNTHETIC_TRACKERS);
  }
  /// This must represent a set, where there is no more than one bone for a `BodyPart`.
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::Bone>> *bones() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::Bone>> *>(VT_BONES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICES) &&
           verifier.VerifyVector(devices()) &&
           verifier.VerifyVectorOfTables(devices()) &&
           VerifyOffset(verifier, VT_SYNTHETIC_TRACKERS) &&
           verifier.VerifyVector(synthetic_trackers()) &&
           verifier.VerifyVectorOfTables(synthetic_trackers()) &&
           VerifyOffset(verifier, VT_BONES) &&
           verifier.VerifyVector(bones()) &&
           verifier.VerifyVectorOfTables(bones()) &&
           verifier.EndTable();
  }
};

struct DataFeedUpdateBuilder {
  typedef DataFeedUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_devices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceData>>> devices) {
    fbb_.AddOffset(DataFeedUpdate::VT_DEVICES, devices);
  }
  void add_synthetic_trackers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>>> synthetic_trackers) {
    fbb_.AddOffset(DataFeedUpdate::VT_SYNTHETIC_TRACKERS, synthetic_trackers);
  }
  void add_bones(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::Bone>>> bones) {
    fbb_.AddOffset(DataFeedUpdate::VT_BONES, bones);
  }
  explicit DataFeedUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataFeedUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFeedUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFeedUpdate> CreateDataFeedUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceData>>> devices = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>>> synthetic_trackers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::Bone>>> bones = 0) {
  DataFeedUpdateBuilder builder_(_fbb);
  builder_.add_bones(bones);
  builder_.add_synthetic_trackers(synthetic_trackers);
  builder_.add_devices(devices);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataFeedUpdate> CreateDataFeedUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceData>> *devices = nullptr,
    const std::vector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>> *synthetic_trackers = nullptr,
    const std::vector<flatbuffers::Offset<solarxr_protocol::data_feed::Bone>> *bones = nullptr) {
  auto devices__ = devices ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceData>>(*devices) : 0;
  auto synthetic_trackers__ = synthetic_trackers ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerData>>(*synthetic_trackers) : 0;
  auto bones__ = bones ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::data_feed::Bone>>(*bones) : 0;
  return solarxr_protocol::data_feed::CreateDataFeedUpdate(
      _fbb,
      devices__,
      synthetic_trackers__,
      bones__);
}

/// All information related to the configuration of a data feed. This may be sent
/// as part of a `StartFeed`.
struct DataFeedConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataFeedConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINIMUM_TIME_SINCE_LAST = 4,
    VT_DATA_MASK = 6,
    VT_SYNTHETIC_TRACKERS_MASK = 8,
    VT_BONE_MASK = 10
  };
  /// Minimum delay in milliseconds between new data updates. This value will be
  /// ignored when used for a `PollDataFeed`.
  uint16_t minimum_time_since_last() const {
    return GetField<uint16_t>(VT_MINIMUM_TIME_SINCE_LAST, 0);
  }
  const solarxr_protocol::data_feed::device_data::DeviceDataMask *data_mask() const {
    return GetPointer<const solarxr_protocol::data_feed::device_data::DeviceDataMask *>(VT_DATA_MASK);
  }
  const solarxr_protocol::data_feed::tracker::TrackerDataMask *synthetic_trackers_mask() const {
    return GetPointer<const solarxr_protocol::data_feed::tracker::TrackerDataMask *>(VT_SYNTHETIC_TRACKERS_MASK);
  }
  bool bone_mask() const {
    return GetField<uint8_t>(VT_BONE_MASK, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MINIMUM_TIME_SINCE_LAST, 2) &&
           VerifyOffset(verifier, VT_DATA_MASK) &&
           verifier.VerifyTable(data_mask()) &&
           VerifyOffset(verifier, VT_SYNTHETIC_TRACKERS_MASK) &&
           verifier.VerifyTable(synthetic_trackers_mask()) &&
           VerifyField<uint8_t>(verifier, VT_BONE_MASK, 1) &&
           verifier.EndTable();
  }
};

struct DataFeedConfigBuilder {
  typedef DataFeedConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minimum_time_since_last(uint16_t minimum_time_since_last) {
    fbb_.AddElement<uint16_t>(DataFeedConfig::VT_MINIMUM_TIME_SINCE_LAST, minimum_time_since_last, 0);
  }
  void add_data_mask(flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceDataMask> data_mask) {
    fbb_.AddOffset(DataFeedConfig::VT_DATA_MASK, data_mask);
  }
  void add_synthetic_trackers_mask(flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerDataMask> synthetic_trackers_mask) {
    fbb_.AddOffset(DataFeedConfig::VT_SYNTHETIC_TRACKERS_MASK, synthetic_trackers_mask);
  }
  void add_bone_mask(bool bone_mask) {
    fbb_.AddElement<uint8_t>(DataFeedConfig::VT_BONE_MASK, static_cast<uint8_t>(bone_mask), 0);
  }
  explicit DataFeedConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataFeedConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFeedConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFeedConfig> CreateDataFeedConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t minimum_time_since_last = 0,
    flatbuffers::Offset<solarxr_protocol::data_feed::device_data::DeviceDataMask> data_mask = 0,
    flatbuffers::Offset<solarxr_protocol::data_feed::tracker::TrackerDataMask> synthetic_trackers_mask = 0,
    bool bone_mask = false) {
  DataFeedConfigBuilder builder_(_fbb);
  builder_.add_synthetic_trackers_mask(synthetic_trackers_mask);
  builder_.add_data_mask(data_mask);
  builder_.add_minimum_time_since_last(minimum_time_since_last);
  builder_.add_bone_mask(bone_mask);
  return builder_.Finish();
}

}  // namespace data_feed

namespace rpc {
namespace settings {

/// Settings for the skeletal model that are toggles.
struct ModelToggles FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelTogglesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXTENDED_SPINE = 4,
    VT_EXTENDED_PELVIS = 6,
    VT_EXTENDED_KNEE = 8,
    VT_FORCE_ARMS_FROM_HMD = 10,
    VT_FLOOR_CLIP = 12,
    VT_SKATING_CORRECTION = 14,
    VT_VIVE_EMULATION = 16,
    VT_TOE_SNAP = 18,
    VT_FOOT_PLANT = 20,
    VT_SELF_LOCALIZATION = 22
  };
  flatbuffers::Optional<bool> extended_spine() const {
    return GetOptional<uint8_t, bool>(VT_EXTENDED_SPINE);
  }
  flatbuffers::Optional<bool> extended_pelvis() const {
    return GetOptional<uint8_t, bool>(VT_EXTENDED_PELVIS);
  }
  flatbuffers::Optional<bool> extended_knee() const {
    return GetOptional<uint8_t, bool>(VT_EXTENDED_KNEE);
  }
  flatbuffers::Optional<bool> force_arms_from_hmd() const {
    return GetOptional<uint8_t, bool>(VT_FORCE_ARMS_FROM_HMD);
  }
  flatbuffers::Optional<bool> floor_clip() const {
    return GetOptional<uint8_t, bool>(VT_FLOOR_CLIP);
  }
  flatbuffers::Optional<bool> skating_correction() const {
    return GetOptional<uint8_t, bool>(VT_SKATING_CORRECTION);
  }
  flatbuffers::Optional<bool> vive_emulation() const {
    return GetOptional<uint8_t, bool>(VT_VIVE_EMULATION);
  }
  flatbuffers::Optional<bool> toe_snap() const {
    return GetOptional<uint8_t, bool>(VT_TOE_SNAP);
  }
  flatbuffers::Optional<bool> foot_plant() const {
    return GetOptional<uint8_t, bool>(VT_FOOT_PLANT);
  }
  flatbuffers::Optional<bool> self_localization() const {
    return GetOptional<uint8_t, bool>(VT_SELF_LOCALIZATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXTENDED_SPINE, 1) &&
           VerifyField<uint8_t>(verifier, VT_EXTENDED_PELVIS, 1) &&
           VerifyField<uint8_t>(verifier, VT_EXTENDED_KNEE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FORCE_ARMS_FROM_HMD, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLOOR_CLIP, 1) &&
           VerifyField<uint8_t>(verifier, VT_SKATING_CORRECTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_VIVE_EMULATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_TOE_SNAP, 1) &&
           VerifyField<uint8_t>(verifier, VT_FOOT_PLANT, 1) &&
           VerifyField<uint8_t>(verifier, VT_SELF_LOCALIZATION, 1) &&
           verifier.EndTable();
  }
};

struct ModelTogglesBuilder {
  typedef ModelToggles Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_extended_spine(bool extended_spine) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_EXTENDED_SPINE, static_cast<uint8_t>(extended_spine));
  }
  void add_extended_pelvis(bool extended_pelvis) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_EXTENDED_PELVIS, static_cast<uint8_t>(extended_pelvis));
  }
  void add_extended_knee(bool extended_knee) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_EXTENDED_KNEE, static_cast<uint8_t>(extended_knee));
  }
  void add_force_arms_from_hmd(bool force_arms_from_hmd) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_FORCE_ARMS_FROM_HMD, static_cast<uint8_t>(force_arms_from_hmd));
  }
  void add_floor_clip(bool floor_clip) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_FLOOR_CLIP, static_cast<uint8_t>(floor_clip));
  }
  void add_skating_correction(bool skating_correction) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_SKATING_CORRECTION, static_cast<uint8_t>(skating_correction));
  }
  void add_vive_emulation(bool vive_emulation) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_VIVE_EMULATION, static_cast<uint8_t>(vive_emulation));
  }
  void add_toe_snap(bool toe_snap) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_TOE_SNAP, static_cast<uint8_t>(toe_snap));
  }
  void add_foot_plant(bool foot_plant) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_FOOT_PLANT, static_cast<uint8_t>(foot_plant));
  }
  void add_self_localization(bool self_localization) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_SELF_LOCALIZATION, static_cast<uint8_t>(self_localization));
  }
  explicit ModelTogglesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ModelToggles> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelToggles>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelToggles> CreateModelToggles(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<bool> extended_spine = flatbuffers::nullopt,
    flatbuffers::Optional<bool> extended_pelvis = flatbuffers::nullopt,
    flatbuffers::Optional<bool> extended_knee = flatbuffers::nullopt,
    flatbuffers::Optional<bool> force_arms_from_hmd = flatbuffers::nullopt,
    flatbuffers::Optional<bool> floor_clip = flatbuffers::nullopt,
    flatbuffers::Optional<bool> skating_correction = flatbuffers::nullopt,
    flatbuffers::Optional<bool> vive_emulation = flatbuffers::nullopt,
    flatbuffers::Optional<bool> toe_snap = flatbuffers::nullopt,
    flatbuffers::Optional<bool> foot_plant = flatbuffers::nullopt,
    flatbuffers::Optional<bool> self_localization = flatbuffers::nullopt) {
  ModelTogglesBuilder builder_(_fbb);
  if(self_localization) { builder_.add_self_localization(*self_localization); }
  if(foot_plant) { builder_.add_foot_plant(*foot_plant); }
  if(toe_snap) { builder_.add_toe_snap(*toe_snap); }
  if(vive_emulation) { builder_.add_vive_emulation(*vive_emulation); }
  if(skating_correction) { builder_.add_skating_correction(*skating_correction); }
  if(floor_clip) { builder_.add_floor_clip(*floor_clip); }
  if(force_arms_from_hmd) { builder_.add_force_arms_from_hmd(*force_arms_from_hmd); }
  if(extended_knee) { builder_.add_extended_knee(*extended_knee); }
  if(extended_pelvis) { builder_.add_extended_pelvis(*extended_pelvis); }
  if(extended_spine) { builder_.add_extended_spine(*extended_spine); }
  return builder_.Finish();
}

/// Settings for the skeletal model that are ratios.
/// These values range from 0 to 1.
struct ModelRatios FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelRatiosBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMPUTE_WAIST_FROM_CHEST_HIP = 4,
    VT_IMPUTE_WAIST_FROM_CHEST_LEGS = 6,
    VT_IMPUTE_HIP_FROM_CHEST_LEGS = 8,
    VT_IMPUTE_HIP_FROM_WAIST_LEGS = 10,
    VT_INTERP_HIP_LEGS = 12,
    VT_INTERP_KNEE_TRACKER_ANKLE = 14
  };
  flatbuffers::Optional<float> impute_waist_from_chest_hip() const {
    return GetOptional<float, float>(VT_IMPUTE_WAIST_FROM_CHEST_HIP);
  }
  flatbuffers::Optional<float> impute_waist_from_chest_legs() const {
    return GetOptional<float, float>(VT_IMPUTE_WAIST_FROM_CHEST_LEGS);
  }
  flatbuffers::Optional<float> impute_hip_from_chest_legs() const {
    return GetOptional<float, float>(VT_IMPUTE_HIP_FROM_CHEST_LEGS);
  }
  flatbuffers::Optional<float> impute_hip_from_waist_legs() const {
    return GetOptional<float, float>(VT_IMPUTE_HIP_FROM_WAIST_LEGS);
  }
  /// Hip's yaw and roll is set to the average of legs when 1.0
  flatbuffers::Optional<float> interp_hip_legs() const {
    return GetOptional<float, float>(VT_INTERP_HIP_LEGS);
  }
  /// Knee trackers' yaw and roll is set to the ankle's when 1.0
  flatbuffers::Optional<float> interp_knee_tracker_ankle() const {
    return GetOptional<float, float>(VT_INTERP_KNEE_TRACKER_ANKLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_IMPUTE_WAIST_FROM_CHEST_HIP, 4) &&
           VerifyField<float>(verifier, VT_IMPUTE_WAIST_FROM_CHEST_LEGS, 4) &&
           VerifyField<float>(verifier, VT_IMPUTE_HIP_FROM_CHEST_LEGS, 4) &&
           VerifyField<float>(verifier, VT_IMPUTE_HIP_FROM_WAIST_LEGS, 4) &&
           VerifyField<float>(verifier, VT_INTERP_HIP_LEGS, 4) &&
           VerifyField<float>(verifier, VT_INTERP_KNEE_TRACKER_ANKLE, 4) &&
           verifier.EndTable();
  }
};

struct ModelRatiosBuilder {
  typedef ModelRatios Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_impute_waist_from_chest_hip(float impute_waist_from_chest_hip) {
    fbb_.AddElement<float>(ModelRatios::VT_IMPUTE_WAIST_FROM_CHEST_HIP, impute_waist_from_chest_hip);
  }
  void add_impute_waist_from_chest_legs(float impute_waist_from_chest_legs) {
    fbb_.AddElement<float>(ModelRatios::VT_IMPUTE_WAIST_FROM_CHEST_LEGS, impute_waist_from_chest_legs);
  }
  void add_impute_hip_from_chest_legs(float impute_hip_from_chest_legs) {
    fbb_.AddElement<float>(ModelRatios::VT_IMPUTE_HIP_FROM_CHEST_LEGS, impute_hip_from_chest_legs);
  }
  void add_impute_hip_from_waist_legs(float impute_hip_from_waist_legs) {
    fbb_.AddElement<float>(ModelRatios::VT_IMPUTE_HIP_FROM_WAIST_LEGS, impute_hip_from_waist_legs);
  }
  void add_interp_hip_legs(float interp_hip_legs) {
    fbb_.AddElement<float>(ModelRatios::VT_INTERP_HIP_LEGS, interp_hip_legs);
  }
  void add_interp_knee_tracker_ankle(float interp_knee_tracker_ankle) {
    fbb_.AddElement<float>(ModelRatios::VT_INTERP_KNEE_TRACKER_ANKLE, interp_knee_tracker_ankle);
  }
  explicit ModelRatiosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ModelRatios> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelRatios>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelRatios> CreateModelRatios(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<float> impute_waist_from_chest_hip = flatbuffers::nullopt,
    flatbuffers::Optional<float> impute_waist_from_chest_legs = flatbuffers::nullopt,
    flatbuffers::Optional<float> impute_hip_from_chest_legs = flatbuffers::nullopt,
    flatbuffers::Optional<float> impute_hip_from_waist_legs = flatbuffers::nullopt,
    flatbuffers::Optional<float> interp_hip_legs = flatbuffers::nullopt,
    flatbuffers::Optional<float> interp_knee_tracker_ankle = flatbuffers::nullopt) {
  ModelRatiosBuilder builder_(_fbb);
  if(interp_knee_tracker_ankle) { builder_.add_interp_knee_tracker_ankle(*interp_knee_tracker_ankle); }
  if(interp_hip_legs) { builder_.add_interp_hip_legs(*interp_hip_legs); }
  if(impute_hip_from_waist_legs) { builder_.add_impute_hip_from_waist_legs(*impute_hip_from_waist_legs); }
  if(impute_hip_from_chest_legs) { builder_.add_impute_hip_from_chest_legs(*impute_hip_from_chest_legs); }
  if(impute_waist_from_chest_legs) { builder_.add_impute_waist_from_chest_legs(*impute_waist_from_chest_legs); }
  if(impute_waist_from_chest_hip) { builder_.add_impute_waist_from_chest_hip(*impute_waist_from_chest_hip); }
  return builder_.Finish();
}

struct LegTweaksSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LegTweaksSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CORRECTION_STRENGTH = 4
  };
  flatbuffers::Optional<float> correction_strength() const {
    return GetOptional<float, float>(VT_CORRECTION_STRENGTH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CORRECTION_STRENGTH, 4) &&
           verifier.EndTable();
  }
};

struct LegTweaksSettingsBuilder {
  typedef LegTweaksSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_correction_strength(float correction_strength) {
    fbb_.AddElement<float>(LegTweaksSettings::VT_CORRECTION_STRENGTH, correction_strength);
  }
  explicit LegTweaksSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LegTweaksSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LegTweaksSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<LegTweaksSettings> CreateLegTweaksSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<float> correction_strength = flatbuffers::nullopt) {
  LegTweaksSettingsBuilder builder_(_fbb);
  if(correction_strength) { builder_.add_correction_strength(*correction_strength); }
  return builder_.Finish();
}

/// Settings for the skeletal model.
struct ModelSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOGGLES = 4,
    VT_RATIOS = 6,
    VT_LEG_TWEAKS = 8
  };
  const solarxr_protocol::rpc::settings::ModelToggles *toggles() const {
    return GetPointer<const solarxr_protocol::rpc::settings::ModelToggles *>(VT_TOGGLES);
  }
  const solarxr_protocol::rpc::settings::ModelRatios *ratios() const {
    return GetPointer<const solarxr_protocol::rpc::settings::ModelRatios *>(VT_RATIOS);
  }
  const solarxr_protocol::rpc::settings::LegTweaksSettings *leg_tweaks() const {
    return GetPointer<const solarxr_protocol::rpc::settings::LegTweaksSettings *>(VT_LEG_TWEAKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOGGLES) &&
           verifier.VerifyTable(toggles()) &&
           VerifyOffset(verifier, VT_RATIOS) &&
           verifier.VerifyTable(ratios()) &&
           VerifyOffset(verifier, VT_LEG_TWEAKS) &&
           verifier.VerifyTable(leg_tweaks()) &&
           verifier.EndTable();
  }
};

struct ModelSettingsBuilder {
  typedef ModelSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_toggles(flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelToggles> toggles) {
    fbb_.AddOffset(ModelSettings::VT_TOGGLES, toggles);
  }
  void add_ratios(flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelRatios> ratios) {
    fbb_.AddOffset(ModelSettings::VT_RATIOS, ratios);
  }
  void add_leg_tweaks(flatbuffers::Offset<solarxr_protocol::rpc::settings::LegTweaksSettings> leg_tweaks) {
    fbb_.AddOffset(ModelSettings::VT_LEG_TWEAKS, leg_tweaks);
  }
  explicit ModelSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ModelSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelSettings> CreateModelSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelToggles> toggles = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelRatios> ratios = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::settings::LegTweaksSettings> leg_tweaks = 0) {
  ModelSettingsBuilder builder_(_fbb);
  builder_.add_leg_tweaks(leg_tweaks);
  builder_.add_ratios(ratios);
  builder_.add_toggles(toggles);
  return builder_.Finish();
}

}  // namespace settings

struct RpcMessageHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RpcMessageHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TX_ID = 4,
    VT_MESSAGE_TYPE = 6,
    VT_MESSAGE = 8
  };
  /// For a request, this identifies the request. For a response, this corresponds
  /// to the request that it is responding to.
  const solarxr_protocol::datatypes::TransactionId *tx_id() const {
    return GetStruct<const solarxr_protocol::datatypes::TransactionId *>(VT_TX_ID);
  }
  solarxr_protocol::rpc::RpcMessage message_type() const {
    return static_cast<solarxr_protocol::rpc::RpcMessage>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const solarxr_protocol::rpc::HeartbeatRequest *message_as_HeartbeatRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::HeartbeatRequest ? static_cast<const solarxr_protocol::rpc::HeartbeatRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::HeartbeatResponse *message_as_HeartbeatResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::HeartbeatResponse ? static_cast<const solarxr_protocol::rpc::HeartbeatResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::ResetRequest *message_as_ResetRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::ResetRequest ? static_cast<const solarxr_protocol::rpc::ResetRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::ResetResponse *message_as_ResetResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::ResetResponse ? static_cast<const solarxr_protocol::rpc::ResetResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::AssignTrackerRequest *message_as_AssignTrackerRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::AssignTrackerRequest ? static_cast<const solarxr_protocol::rpc::AssignTrackerRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SettingsRequest *message_as_SettingsRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SettingsRequest ? static_cast<const solarxr_protocol::rpc::SettingsRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SettingsResponse *message_as_SettingsResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SettingsResponse ? static_cast<const solarxr_protocol::rpc::SettingsResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::ChangeSettingsRequest *message_as_ChangeSettingsRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::ChangeSettingsRequest ? static_cast<const solarxr_protocol::rpc::ChangeSettingsRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::ClearDriftCompensationRequest *message_as_ClearDriftCompensationRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::ClearDriftCompensationRequest ? static_cast<const solarxr_protocol::rpc::ClearDriftCompensationRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::RecordBVHRequest *message_as_RecordBVHRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::RecordBVHRequest ? static_cast<const solarxr_protocol::rpc::RecordBVHRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::RecordBVHStatus *message_as_RecordBVHStatus() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::RecordBVHStatus ? static_cast<const solarxr_protocol::rpc::RecordBVHStatus *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SkeletonConfigRequest *message_as_SkeletonConfigRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SkeletonConfigRequest ? static_cast<const solarxr_protocol::rpc::SkeletonConfigRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::ChangeSkeletonConfigRequest *message_as_ChangeSkeletonConfigRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::ChangeSkeletonConfigRequest ? static_cast<const solarxr_protocol::rpc::ChangeSkeletonConfigRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SkeletonResetAllRequest *message_as_SkeletonResetAllRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SkeletonResetAllRequest ? static_cast<const solarxr_protocol::rpc::SkeletonResetAllRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SkeletonConfigResponse *message_as_SkeletonConfigResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SkeletonConfigResponse ? static_cast<const solarxr_protocol::rpc::SkeletonConfigResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::OpenSerialRequest *message_as_OpenSerialRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::OpenSerialRequest ? static_cast<const solarxr_protocol::rpc::OpenSerialRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::CloseSerialRequest *message_as_CloseSerialRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::CloseSerialRequest ? static_cast<const solarxr_protocol::rpc::CloseSerialRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SetWifiRequest *message_as_SetWifiRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SetWifiRequest ? static_cast<const solarxr_protocol::rpc::SetWifiRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SerialUpdateResponse *message_as_SerialUpdateResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SerialUpdateResponse ? static_cast<const solarxr_protocol::rpc::SerialUpdateResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::AutoBoneProcessRequest *message_as_AutoBoneProcessRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::AutoBoneProcessRequest ? static_cast<const solarxr_protocol::rpc::AutoBoneProcessRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::AutoBoneProcessStatusResponse *message_as_AutoBoneProcessStatusResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::AutoBoneProcessStatusResponse ? static_cast<const solarxr_protocol::rpc::AutoBoneProcessStatusResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::AutoBoneEpochResponse *message_as_AutoBoneEpochResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::AutoBoneEpochResponse ? static_cast<const solarxr_protocol::rpc::AutoBoneEpochResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::OverlayDisplayModeRequest *message_as_OverlayDisplayModeRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::OverlayDisplayModeRequest ? static_cast<const solarxr_protocol::rpc::OverlayDisplayModeRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::OverlayDisplayModeChangeRequest *message_as_OverlayDisplayModeChangeRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::OverlayDisplayModeChangeRequest ? static_cast<const solarxr_protocol::rpc::OverlayDisplayModeChangeRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::OverlayDisplayModeResponse *message_as_OverlayDisplayModeResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::OverlayDisplayModeResponse ? static_cast<const solarxr_protocol::rpc::OverlayDisplayModeResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SerialTrackerRebootRequest *message_as_SerialTrackerRebootRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SerialTrackerRebootRequest ? static_cast<const solarxr_protocol::rpc::SerialTrackerRebootRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SerialTrackerGetInfoRequest *message_as_SerialTrackerGetInfoRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SerialTrackerGetInfoRequest ? static_cast<const solarxr_protocol::rpc::SerialTrackerGetInfoRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SerialTrackerFactoryResetRequest *message_as_SerialTrackerFactoryResetRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SerialTrackerFactoryResetRequest ? static_cast<const solarxr_protocol::rpc::SerialTrackerFactoryResetRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SerialDevicesRequest *message_as_SerialDevicesRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SerialDevicesRequest ? static_cast<const solarxr_protocol::rpc::SerialDevicesRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SerialDevicesResponse *message_as_SerialDevicesResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SerialDevicesResponse ? static_cast<const solarxr_protocol::rpc::SerialDevicesResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::NewSerialDeviceResponse *message_as_NewSerialDeviceResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::NewSerialDeviceResponse ? static_cast<const solarxr_protocol::rpc::NewSerialDeviceResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::StartWifiProvisioningRequest *message_as_StartWifiProvisioningRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::StartWifiProvisioningRequest ? static_cast<const solarxr_protocol::rpc::StartWifiProvisioningRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::StopWifiProvisioningRequest *message_as_StopWifiProvisioningRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::StopWifiProvisioningRequest ? static_cast<const solarxr_protocol::rpc::StopWifiProvisioningRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::WifiProvisioningStatusResponse *message_as_WifiProvisioningStatusResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::WifiProvisioningStatusResponse ? static_cast<const solarxr_protocol::rpc::WifiProvisioningStatusResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::ServerInfosRequest *message_as_ServerInfosRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::ServerInfosRequest ? static_cast<const solarxr_protocol::rpc::ServerInfosRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::ServerInfosResponse *message_as_ServerInfosResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::ServerInfosResponse ? static_cast<const solarxr_protocol::rpc::ServerInfosResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::LegTweaksTmpChange *message_as_LegTweaksTmpChange() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::LegTweaksTmpChange ? static_cast<const solarxr_protocol::rpc::LegTweaksTmpChange *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::LegTweaksTmpClear *message_as_LegTweaksTmpClear() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::LegTweaksTmpClear ? static_cast<const solarxr_protocol::rpc::LegTweaksTmpClear *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::TapDetectionSetupNotification *message_as_TapDetectionSetupNotification() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::TapDetectionSetupNotification ? static_cast<const solarxr_protocol::rpc::TapDetectionSetupNotification *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::SetPauseTrackingRequest *message_as_SetPauseTrackingRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::SetPauseTrackingRequest ? static_cast<const solarxr_protocol::rpc::SetPauseTrackingRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::StatusSystemRequest *message_as_StatusSystemRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::StatusSystemRequest ? static_cast<const solarxr_protocol::rpc::StatusSystemRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::StatusSystemResponse *message_as_StatusSystemResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::StatusSystemResponse ? static_cast<const solarxr_protocol::rpc::StatusSystemResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::StatusSystemUpdate *message_as_StatusSystemUpdate() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::StatusSystemUpdate ? static_cast<const solarxr_protocol::rpc::StatusSystemUpdate *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::StatusSystemFixed *message_as_StatusSystemFixed() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::StatusSystemFixed ? static_cast<const solarxr_protocol::rpc::StatusSystemFixed *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::ClearMountingResetRequest *message_as_ClearMountingResetRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::ClearMountingResetRequest ? static_cast<const solarxr_protocol::rpc::ClearMountingResetRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::HeightRequest *message_as_HeightRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::HeightRequest ? static_cast<const solarxr_protocol::rpc::HeightRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::HeightResponse *message_as_HeightResponse() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::HeightResponse ? static_cast<const solarxr_protocol::rpc::HeightResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::AutoBoneApplyRequest *message_as_AutoBoneApplyRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::AutoBoneApplyRequest ? static_cast<const solarxr_protocol::rpc::AutoBoneApplyRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::AutoBoneStopRecordingRequest *message_as_AutoBoneStopRecordingRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::AutoBoneStopRecordingRequest ? static_cast<const solarxr_protocol::rpc::AutoBoneStopRecordingRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::rpc::AutoBoneCancelRecordingRequest *message_as_AutoBoneCancelRecordingRequest() const {
    return message_type() == solarxr_protocol::rpc::RpcMessage::AutoBoneCancelRecordingRequest ? static_cast<const solarxr_protocol::rpc::AutoBoneCancelRecordingRequest *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<solarxr_protocol::datatypes::TransactionId>(verifier, VT_TX_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyRpcMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::rpc::HeartbeatRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::HeartbeatRequest>() const {
  return message_as_HeartbeatRequest();
}

template<> inline const solarxr_protocol::rpc::HeartbeatResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::HeartbeatResponse>() const {
  return message_as_HeartbeatResponse();
}

template<> inline const solarxr_protocol::rpc::ResetRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::ResetRequest>() const {
  return message_as_ResetRequest();
}

template<> inline const solarxr_protocol::rpc::ResetResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::ResetResponse>() const {
  return message_as_ResetResponse();
}

template<> inline const solarxr_protocol::rpc::AssignTrackerRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::AssignTrackerRequest>() const {
  return message_as_AssignTrackerRequest();
}

template<> inline const solarxr_protocol::rpc::SettingsRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::SettingsRequest>() const {
  return message_as_SettingsRequest();
}

template<> inline const solarxr_protocol::rpc::SettingsResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::SettingsResponse>() const {
  return message_as_SettingsResponse();
}

template<> inline const solarxr_protocol::rpc::ChangeSettingsRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::ChangeSettingsRequest>() const {
  return message_as_ChangeSettingsRequest();
}

template<> inline const solarxr_protocol::rpc::ClearDriftCompensationRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::ClearDriftCompensationRequest>() const {
  return message_as_ClearDriftCompensationRequest();
}

template<> inline const solarxr_protocol::rpc::RecordBVHRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::RecordBVHRequest>() const {
  return message_as_RecordBVHRequest();
}

template<> inline const solarxr_protocol::rpc::RecordBVHStatus *RpcMessageHeader::message_as<solarxr_protocol::rpc::RecordBVHStatus>() const {
  return message_as_RecordBVHStatus();
}

template<> inline const solarxr_protocol::rpc::SkeletonConfigRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::SkeletonConfigRequest>() const {
  return message_as_SkeletonConfigRequest();
}

template<> inline const solarxr_protocol::rpc::ChangeSkeletonConfigRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::ChangeSkeletonConfigRequest>() const {
  return message_as_ChangeSkeletonConfigRequest();
}

template<> inline const solarxr_protocol::rpc::SkeletonResetAllRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::SkeletonResetAllRequest>() const {
  return message_as_SkeletonResetAllRequest();
}

template<> inline const solarxr_protocol::rpc::SkeletonConfigResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::SkeletonConfigResponse>() const {
  return message_as_SkeletonConfigResponse();
}

template<> inline const solarxr_protocol::rpc::OpenSerialRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::OpenSerialRequest>() const {
  return message_as_OpenSerialRequest();
}

template<> inline const solarxr_protocol::rpc::CloseSerialRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::CloseSerialRequest>() const {
  return message_as_CloseSerialRequest();
}

template<> inline const solarxr_protocol::rpc::SetWifiRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::SetWifiRequest>() const {
  return message_as_SetWifiRequest();
}

template<> inline const solarxr_protocol::rpc::SerialUpdateResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::SerialUpdateResponse>() const {
  return message_as_SerialUpdateResponse();
}

template<> inline const solarxr_protocol::rpc::AutoBoneProcessRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::AutoBoneProcessRequest>() const {
  return message_as_AutoBoneProcessRequest();
}

template<> inline const solarxr_protocol::rpc::AutoBoneProcessStatusResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::AutoBoneProcessStatusResponse>() const {
  return message_as_AutoBoneProcessStatusResponse();
}

template<> inline const solarxr_protocol::rpc::AutoBoneEpochResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::AutoBoneEpochResponse>() const {
  return message_as_AutoBoneEpochResponse();
}

template<> inline const solarxr_protocol::rpc::OverlayDisplayModeRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::OverlayDisplayModeRequest>() const {
  return message_as_OverlayDisplayModeRequest();
}

template<> inline const solarxr_protocol::rpc::OverlayDisplayModeChangeRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::OverlayDisplayModeChangeRequest>() const {
  return message_as_OverlayDisplayModeChangeRequest();
}

template<> inline const solarxr_protocol::rpc::OverlayDisplayModeResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::OverlayDisplayModeResponse>() const {
  return message_as_OverlayDisplayModeResponse();
}

template<> inline const solarxr_protocol::rpc::SerialTrackerRebootRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::SerialTrackerRebootRequest>() const {
  return message_as_SerialTrackerRebootRequest();
}

template<> inline const solarxr_protocol::rpc::SerialTrackerGetInfoRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::SerialTrackerGetInfoRequest>() const {
  return message_as_SerialTrackerGetInfoRequest();
}

template<> inline const solarxr_protocol::rpc::SerialTrackerFactoryResetRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::SerialTrackerFactoryResetRequest>() const {
  return message_as_SerialTrackerFactoryResetRequest();
}

template<> inline const solarxr_protocol::rpc::SerialDevicesRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::SerialDevicesRequest>() const {
  return message_as_SerialDevicesRequest();
}

template<> inline const solarxr_protocol::rpc::SerialDevicesResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::SerialDevicesResponse>() const {
  return message_as_SerialDevicesResponse();
}

template<> inline const solarxr_protocol::rpc::NewSerialDeviceResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::NewSerialDeviceResponse>() const {
  return message_as_NewSerialDeviceResponse();
}

template<> inline const solarxr_protocol::rpc::StartWifiProvisioningRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::StartWifiProvisioningRequest>() const {
  return message_as_StartWifiProvisioningRequest();
}

template<> inline const solarxr_protocol::rpc::StopWifiProvisioningRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::StopWifiProvisioningRequest>() const {
  return message_as_StopWifiProvisioningRequest();
}

template<> inline const solarxr_protocol::rpc::WifiProvisioningStatusResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::WifiProvisioningStatusResponse>() const {
  return message_as_WifiProvisioningStatusResponse();
}

template<> inline const solarxr_protocol::rpc::ServerInfosRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::ServerInfosRequest>() const {
  return message_as_ServerInfosRequest();
}

template<> inline const solarxr_protocol::rpc::ServerInfosResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::ServerInfosResponse>() const {
  return message_as_ServerInfosResponse();
}

template<> inline const solarxr_protocol::rpc::LegTweaksTmpChange *RpcMessageHeader::message_as<solarxr_protocol::rpc::LegTweaksTmpChange>() const {
  return message_as_LegTweaksTmpChange();
}

template<> inline const solarxr_protocol::rpc::LegTweaksTmpClear *RpcMessageHeader::message_as<solarxr_protocol::rpc::LegTweaksTmpClear>() const {
  return message_as_LegTweaksTmpClear();
}

template<> inline const solarxr_protocol::rpc::TapDetectionSetupNotification *RpcMessageHeader::message_as<solarxr_protocol::rpc::TapDetectionSetupNotification>() const {
  return message_as_TapDetectionSetupNotification();
}

template<> inline const solarxr_protocol::rpc::SetPauseTrackingRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::SetPauseTrackingRequest>() const {
  return message_as_SetPauseTrackingRequest();
}

template<> inline const solarxr_protocol::rpc::StatusSystemRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::StatusSystemRequest>() const {
  return message_as_StatusSystemRequest();
}

template<> inline const solarxr_protocol::rpc::StatusSystemResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::StatusSystemResponse>() const {
  return message_as_StatusSystemResponse();
}

template<> inline const solarxr_protocol::rpc::StatusSystemUpdate *RpcMessageHeader::message_as<solarxr_protocol::rpc::StatusSystemUpdate>() const {
  return message_as_StatusSystemUpdate();
}

template<> inline const solarxr_protocol::rpc::StatusSystemFixed *RpcMessageHeader::message_as<solarxr_protocol::rpc::StatusSystemFixed>() const {
  return message_as_StatusSystemFixed();
}

template<> inline const solarxr_protocol::rpc::ClearMountingResetRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::ClearMountingResetRequest>() const {
  return message_as_ClearMountingResetRequest();
}

template<> inline const solarxr_protocol::rpc::HeightRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::HeightRequest>() const {
  return message_as_HeightRequest();
}

template<> inline const solarxr_protocol::rpc::HeightResponse *RpcMessageHeader::message_as<solarxr_protocol::rpc::HeightResponse>() const {
  return message_as_HeightResponse();
}

template<> inline const solarxr_protocol::rpc::AutoBoneApplyRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::AutoBoneApplyRequest>() const {
  return message_as_AutoBoneApplyRequest();
}

template<> inline const solarxr_protocol::rpc::AutoBoneStopRecordingRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::AutoBoneStopRecordingRequest>() const {
  return message_as_AutoBoneStopRecordingRequest();
}

template<> inline const solarxr_protocol::rpc::AutoBoneCancelRecordingRequest *RpcMessageHeader::message_as<solarxr_protocol::rpc::AutoBoneCancelRecordingRequest>() const {
  return message_as_AutoBoneCancelRecordingRequest();
}

struct RpcMessageHeaderBuilder {
  typedef RpcMessageHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tx_id(const solarxr_protocol::datatypes::TransactionId *tx_id) {
    fbb_.AddStruct(RpcMessageHeader::VT_TX_ID, tx_id);
  }
  void add_message_type(solarxr_protocol::rpc::RpcMessage message_type) {
    fbb_.AddElement<uint8_t>(RpcMessageHeader::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(RpcMessageHeader::VT_MESSAGE, message);
  }
  explicit RpcMessageHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RpcMessageHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RpcMessageHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<RpcMessageHeader> CreateRpcMessageHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    const solarxr_protocol::datatypes::TransactionId *tx_id = nullptr,
    solarxr_protocol::rpc::RpcMessage message_type = solarxr_protocol::rpc::RpcMessage::NONE,
    flatbuffers::Offset<void> message = 0) {
  RpcMessageHeaderBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_tx_id(tx_id);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct HeartbeatRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeartbeatRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HeartbeatRequestBuilder {
  typedef HeartbeatRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HeartbeatRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HeartbeatRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeartbeatRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeartbeatRequest> CreateHeartbeatRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HeartbeatRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HeartbeatResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeartbeatResponseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HeartbeatResponseBuilder {
  typedef HeartbeatResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HeartbeatResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HeartbeatResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeartbeatResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeartbeatResponse> CreateHeartbeatResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HeartbeatResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ResetRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResetRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESET_TYPE = 4
  };
  solarxr_protocol::rpc::ResetType reset_type() const {
    return static_cast<solarxr_protocol::rpc::ResetType>(GetField<uint8_t>(VT_RESET_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESET_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct ResetRequestBuilder {
  typedef ResetRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reset_type(solarxr_protocol::rpc::ResetType reset_type) {
    fbb_.AddElement<uint8_t>(ResetRequest::VT_RESET_TYPE, static_cast<uint8_t>(reset_type), 0);
  }
  explicit ResetRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResetRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResetRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResetRequest> CreateResetRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::rpc::ResetType reset_type = solarxr_protocol::rpc::ResetType::Yaw) {
  ResetRequestBuilder builder_(_fbb);
  builder_.add_reset_type(reset_type);
  return builder_.Finish();
}

struct ResetResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResetResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESET_TYPE = 4,
    VT_STATUS = 6
  };
  solarxr_protocol::rpc::ResetType reset_type() const {
    return static_cast<solarxr_protocol::rpc::ResetType>(GetField<uint8_t>(VT_RESET_TYPE, 0));
  }
  solarxr_protocol::rpc::ResetStatus status() const {
    return static_cast<solarxr_protocol::rpc::ResetStatus>(GetField<uint8_t>(VT_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESET_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           verifier.EndTable();
  }
};

struct ResetResponseBuilder {
  typedef ResetResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reset_type(solarxr_protocol::rpc::ResetType reset_type) {
    fbb_.AddElement<uint8_t>(ResetResponse::VT_RESET_TYPE, static_cast<uint8_t>(reset_type), 0);
  }
  void add_status(solarxr_protocol::rpc::ResetStatus status) {
    fbb_.AddElement<uint8_t>(ResetResponse::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  explicit ResetResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResetResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResetResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResetResponse> CreateResetResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::rpc::ResetType reset_type = solarxr_protocol::rpc::ResetType::Yaw,
    solarxr_protocol::rpc::ResetStatus status = solarxr_protocol::rpc::ResetStatus::STARTED) {
  ResetResponseBuilder builder_(_fbb);
  builder_.add_status(status);
  builder_.add_reset_type(reset_type);
  return builder_.Finish();
}

struct AssignTrackerRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssignTrackerRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACKER_ID = 4,
    VT_BODY_POSITION = 6,
    VT_MOUNTING_ORIENTATION = 8,
    VT_DISPLAY_NAME = 10,
    VT_ALLOW_DRIFT_COMPENSATION = 12
  };
  const solarxr_protocol::datatypes::TrackerId *tracker_id() const {
    return GetPointer<const solarxr_protocol::datatypes::TrackerId *>(VT_TRACKER_ID);
  }
  solarxr_protocol::datatypes::BodyPart body_position() const {
    return static_cast<solarxr_protocol::datatypes::BodyPart>(GetField<uint8_t>(VT_BODY_POSITION, 0));
  }
  const solarxr_protocol::datatypes::math::Quat *mounting_orientation() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_MOUNTING_ORIENTATION);
  }
  const flatbuffers::String *display_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  bool allow_drift_compensation() const {
    return GetField<uint8_t>(VT_ALLOW_DRIFT_COMPENSATION, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACKER_ID) &&
           verifier.VerifyTable(tracker_id()) &&
           VerifyField<uint8_t>(verifier, VT_BODY_POSITION, 1) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_MOUNTING_ORIENTATION, 4) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyField<uint8_t>(verifier, VT_ALLOW_DRIFT_COMPENSATION, 1) &&
           verifier.EndTable();
  }
};

struct AssignTrackerRequestBuilder {
  typedef AssignTrackerRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tracker_id(flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id) {
    fbb_.AddOffset(AssignTrackerRequest::VT_TRACKER_ID, tracker_id);
  }
  void add_body_position(solarxr_protocol::datatypes::BodyPart body_position) {
    fbb_.AddElement<uint8_t>(AssignTrackerRequest::VT_BODY_POSITION, static_cast<uint8_t>(body_position), 0);
  }
  void add_mounting_orientation(const solarxr_protocol::datatypes::math::Quat *mounting_orientation) {
    fbb_.AddStruct(AssignTrackerRequest::VT_MOUNTING_ORIENTATION, mounting_orientation);
  }
  void add_display_name(flatbuffers::Offset<flatbuffers::String> display_name) {
    fbb_.AddOffset(AssignTrackerRequest::VT_DISPLAY_NAME, display_name);
  }
  void add_allow_drift_compensation(bool allow_drift_compensation) {
    fbb_.AddElement<uint8_t>(AssignTrackerRequest::VT_ALLOW_DRIFT_COMPENSATION, static_cast<uint8_t>(allow_drift_compensation), 0);
  }
  explicit AssignTrackerRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AssignTrackerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignTrackerRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignTrackerRequest> CreateAssignTrackerRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id = 0,
    solarxr_protocol::datatypes::BodyPart body_position = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::math::Quat *mounting_orientation = nullptr,
    flatbuffers::Offset<flatbuffers::String> display_name = 0,
    bool allow_drift_compensation = false) {
  AssignTrackerRequestBuilder builder_(_fbb);
  builder_.add_display_name(display_name);
  builder_.add_mounting_orientation(mounting_orientation);
  builder_.add_tracker_id(tracker_id);
  builder_.add_allow_drift_compensation(allow_drift_compensation);
  builder_.add_body_position(body_position);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssignTrackerRequest> CreateAssignTrackerRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id = 0,
    solarxr_protocol::datatypes::BodyPart body_position = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::math::Quat *mounting_orientation = nullptr,
    const char *display_name = nullptr,
    bool allow_drift_compensation = false) {
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  return solarxr_protocol::rpc::CreateAssignTrackerRequest(
      _fbb,
      tracker_id,
      body_position,
      mounting_orientation,
      display_name__,
      allow_drift_compensation);
}

struct ClearDriftCompensationRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClearDriftCompensationRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ClearDriftCompensationRequestBuilder {
  typedef ClearDriftCompensationRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ClearDriftCompensationRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClearDriftCompensationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClearDriftCompensationRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClearDriftCompensationRequest> CreateClearDriftCompensationRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ClearDriftCompensationRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SettingsRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SettingsRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SettingsRequestBuilder {
  typedef SettingsRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SettingsRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SettingsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SettingsRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SettingsRequest> CreateSettingsRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SettingsRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SettingsResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SettingsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEAM_VR_TRACKERS = 4,
    VT_FILTERING = 6,
    VT_DRIFT_COMPENSATION = 8,
    VT_OSC_ROUTER = 10,
    VT_VRC_OSC = 12,
    VT_VMC_OSC = 14,
    VT_MODEL_SETTINGS = 16,
    VT_TAP_DETECTION_SETTINGS = 18,
    VT_AUTO_BONE_SETTINGS = 20
  };
  const solarxr_protocol::rpc::SteamVRTrackersSetting *steam_vr_trackers() const {
    return GetPointer<const solarxr_protocol::rpc::SteamVRTrackersSetting *>(VT_STEAM_VR_TRACKERS);
  }
  const solarxr_protocol::rpc::FilteringSettings *filtering() const {
    return GetPointer<const solarxr_protocol::rpc::FilteringSettings *>(VT_FILTERING);
  }
  const solarxr_protocol::rpc::DriftCompensationSettings *drift_compensation() const {
    return GetPointer<const solarxr_protocol::rpc::DriftCompensationSettings *>(VT_DRIFT_COMPENSATION);
  }
  const solarxr_protocol::rpc::OSCRouterSettings *osc_router() const {
    return GetPointer<const solarxr_protocol::rpc::OSCRouterSettings *>(VT_OSC_ROUTER);
  }
  const solarxr_protocol::rpc::VRCOSCSettings *vrc_osc() const {
    return GetPointer<const solarxr_protocol::rpc::VRCOSCSettings *>(VT_VRC_OSC);
  }
  const solarxr_protocol::rpc::VMCOSCSettings *vmc_osc() const {
    return GetPointer<const solarxr_protocol::rpc::VMCOSCSettings *>(VT_VMC_OSC);
  }
  const solarxr_protocol::rpc::settings::ModelSettings *model_settings() const {
    return GetPointer<const solarxr_protocol::rpc::settings::ModelSettings *>(VT_MODEL_SETTINGS);
  }
  const solarxr_protocol::rpc::TapDetectionSettings *tap_detection_settings() const {
    return GetPointer<const solarxr_protocol::rpc::TapDetectionSettings *>(VT_TAP_DETECTION_SETTINGS);
  }
  const solarxr_protocol::rpc::AutoBoneSettings *auto_bone_settings() const {
    return GetPointer<const solarxr_protocol::rpc::AutoBoneSettings *>(VT_AUTO_BONE_SETTINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STEAM_VR_TRACKERS) &&
           verifier.VerifyTable(steam_vr_trackers()) &&
           VerifyOffset(verifier, VT_FILTERING) &&
           verifier.VerifyTable(filtering()) &&
           VerifyOffset(verifier, VT_DRIFT_COMPENSATION) &&
           verifier.VerifyTable(drift_compensation()) &&
           VerifyOffset(verifier, VT_OSC_ROUTER) &&
           verifier.VerifyTable(osc_router()) &&
           VerifyOffset(verifier, VT_VRC_OSC) &&
           verifier.VerifyTable(vrc_osc()) &&
           VerifyOffset(verifier, VT_VMC_OSC) &&
           verifier.VerifyTable(vmc_osc()) &&
           VerifyOffset(verifier, VT_MODEL_SETTINGS) &&
           verifier.VerifyTable(model_settings()) &&
           VerifyOffset(verifier, VT_TAP_DETECTION_SETTINGS) &&
           verifier.VerifyTable(tap_detection_settings()) &&
           VerifyOffset(verifier, VT_AUTO_BONE_SETTINGS) &&
           verifier.VerifyTable(auto_bone_settings()) &&
           verifier.EndTable();
  }
};

struct SettingsResponseBuilder {
  typedef SettingsResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_steam_vr_trackers(flatbuffers::Offset<solarxr_protocol::rpc::SteamVRTrackersSetting> steam_vr_trackers) {
    fbb_.AddOffset(SettingsResponse::VT_STEAM_VR_TRACKERS, steam_vr_trackers);
  }
  void add_filtering(flatbuffers::Offset<solarxr_protocol::rpc::FilteringSettings> filtering) {
    fbb_.AddOffset(SettingsResponse::VT_FILTERING, filtering);
  }
  void add_drift_compensation(flatbuffers::Offset<solarxr_protocol::rpc::DriftCompensationSettings> drift_compensation) {
    fbb_.AddOffset(SettingsResponse::VT_DRIFT_COMPENSATION, drift_compensation);
  }
  void add_osc_router(flatbuffers::Offset<solarxr_protocol::rpc::OSCRouterSettings> osc_router) {
    fbb_.AddOffset(SettingsResponse::VT_OSC_ROUTER, osc_router);
  }
  void add_vrc_osc(flatbuffers::Offset<solarxr_protocol::rpc::VRCOSCSettings> vrc_osc) {
    fbb_.AddOffset(SettingsResponse::VT_VRC_OSC, vrc_osc);
  }
  void add_vmc_osc(flatbuffers::Offset<solarxr_protocol::rpc::VMCOSCSettings> vmc_osc) {
    fbb_.AddOffset(SettingsResponse::VT_VMC_OSC, vmc_osc);
  }
  void add_model_settings(flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelSettings> model_settings) {
    fbb_.AddOffset(SettingsResponse::VT_MODEL_SETTINGS, model_settings);
  }
  void add_tap_detection_settings(flatbuffers::Offset<solarxr_protocol::rpc::TapDetectionSettings> tap_detection_settings) {
    fbb_.AddOffset(SettingsResponse::VT_TAP_DETECTION_SETTINGS, tap_detection_settings);
  }
  void add_auto_bone_settings(flatbuffers::Offset<solarxr_protocol::rpc::AutoBoneSettings> auto_bone_settings) {
    fbb_.AddOffset(SettingsResponse::VT_AUTO_BONE_SETTINGS, auto_bone_settings);
  }
  explicit SettingsResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SettingsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SettingsResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SettingsResponse> CreateSettingsResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::rpc::SteamVRTrackersSetting> steam_vr_trackers = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::FilteringSettings> filtering = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::DriftCompensationSettings> drift_compensation = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::OSCRouterSettings> osc_router = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::VRCOSCSettings> vrc_osc = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::VMCOSCSettings> vmc_osc = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelSettings> model_settings = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::TapDetectionSettings> tap_detection_settings = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::AutoBoneSettings> auto_bone_settings = 0) {
  SettingsResponseBuilder builder_(_fbb);
  builder_.add_auto_bone_settings(auto_bone_settings);
  builder_.add_tap_detection_settings(tap_detection_settings);
  builder_.add_model_settings(model_settings);
  builder_.add_vmc_osc(vmc_osc);
  builder_.add_vrc_osc(vrc_osc);
  builder_.add_osc_router(osc_router);
  builder_.add_drift_compensation(drift_compensation);
  builder_.add_filtering(filtering);
  builder_.add_steam_vr_trackers(steam_vr_trackers);
  return builder_.Finish();
}

struct ChangeSettingsRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChangeSettingsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEAM_VR_TRACKERS = 4,
    VT_FILTERING = 6,
    VT_DRIFT_COMPENSATION = 8,
    VT_OSC_ROUTER = 10,
    VT_VRC_OSC = 12,
    VT_VMC_OSC = 14,
    VT_MODEL_SETTINGS = 16,
    VT_TAP_DETECTION_SETTINGS = 18,
    VT_AUTO_BONE_SETTINGS = 20
  };
  const solarxr_protocol::rpc::SteamVRTrackersSetting *steam_vr_trackers() const {
    return GetPointer<const solarxr_protocol::rpc::SteamVRTrackersSetting *>(VT_STEAM_VR_TRACKERS);
  }
  const solarxr_protocol::rpc::FilteringSettings *filtering() const {
    return GetPointer<const solarxr_protocol::rpc::FilteringSettings *>(VT_FILTERING);
  }
  const solarxr_protocol::rpc::DriftCompensationSettings *drift_compensation() const {
    return GetPointer<const solarxr_protocol::rpc::DriftCompensationSettings *>(VT_DRIFT_COMPENSATION);
  }
  const solarxr_protocol::rpc::OSCRouterSettings *osc_router() const {
    return GetPointer<const solarxr_protocol::rpc::OSCRouterSettings *>(VT_OSC_ROUTER);
  }
  const solarxr_protocol::rpc::VRCOSCSettings *vrc_osc() const {
    return GetPointer<const solarxr_protocol::rpc::VRCOSCSettings *>(VT_VRC_OSC);
  }
  const solarxr_protocol::rpc::VMCOSCSettings *vmc_osc() const {
    return GetPointer<const solarxr_protocol::rpc::VMCOSCSettings *>(VT_VMC_OSC);
  }
  const solarxr_protocol::rpc::settings::ModelSettings *model_settings() const {
    return GetPointer<const solarxr_protocol::rpc::settings::ModelSettings *>(VT_MODEL_SETTINGS);
  }
  const solarxr_protocol::rpc::TapDetectionSettings *tap_detection_settings() const {
    return GetPointer<const solarxr_protocol::rpc::TapDetectionSettings *>(VT_TAP_DETECTION_SETTINGS);
  }
  const solarxr_protocol::rpc::AutoBoneSettings *auto_bone_settings() const {
    return GetPointer<const solarxr_protocol::rpc::AutoBoneSettings *>(VT_AUTO_BONE_SETTINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STEAM_VR_TRACKERS) &&
           verifier.VerifyTable(steam_vr_trackers()) &&
           VerifyOffset(verifier, VT_FILTERING) &&
           verifier.VerifyTable(filtering()) &&
           VerifyOffset(verifier, VT_DRIFT_COMPENSATION) &&
           verifier.VerifyTable(drift_compensation()) &&
           VerifyOffset(verifier, VT_OSC_ROUTER) &&
           verifier.VerifyTable(osc_router()) &&
           VerifyOffset(verifier, VT_VRC_OSC) &&
           verifier.VerifyTable(vrc_osc()) &&
           VerifyOffset(verifier, VT_VMC_OSC) &&
           verifier.VerifyTable(vmc_osc()) &&
           VerifyOffset(verifier, VT_MODEL_SETTINGS) &&
           verifier.VerifyTable(model_settings()) &&
           VerifyOffset(verifier, VT_TAP_DETECTION_SETTINGS) &&
           verifier.VerifyTable(tap_detection_settings()) &&
           VerifyOffset(verifier, VT_AUTO_BONE_SETTINGS) &&
           verifier.VerifyTable(auto_bone_settings()) &&
           verifier.EndTable();
  }
};

struct ChangeSettingsRequestBuilder {
  typedef ChangeSettingsRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_steam_vr_trackers(flatbuffers::Offset<solarxr_protocol::rpc::SteamVRTrackersSetting> steam_vr_trackers) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_STEAM_VR_TRACKERS, steam_vr_trackers);
  }
  void add_filtering(flatbuffers::Offset<solarxr_protocol::rpc::FilteringSettings> filtering) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_FILTERING, filtering);
  }
  void add_drift_compensation(flatbuffers::Offset<solarxr_protocol::rpc::DriftCompensationSettings> drift_compensation) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_DRIFT_COMPENSATION, drift_compensation);
  }
  void add_osc_router(flatbuffers::Offset<solarxr_protocol::rpc::OSCRouterSettings> osc_router) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_OSC_ROUTER, osc_router);
  }
  void add_vrc_osc(flatbuffers::Offset<solarxr_protocol::rpc::VRCOSCSettings> vrc_osc) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_VRC_OSC, vrc_osc);
  }
  void add_vmc_osc(flatbuffers::Offset<solarxr_protocol::rpc::VMCOSCSettings> vmc_osc) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_VMC_OSC, vmc_osc);
  }
  void add_model_settings(flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelSettings> model_settings) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_MODEL_SETTINGS, model_settings);
  }
  void add_tap_detection_settings(flatbuffers::Offset<solarxr_protocol::rpc::TapDetectionSettings> tap_detection_settings) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_TAP_DETECTION_SETTINGS, tap_detection_settings);
  }
  void add_auto_bone_settings(flatbuffers::Offset<solarxr_protocol::rpc::AutoBoneSettings> auto_bone_settings) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_AUTO_BONE_SETTINGS, auto_bone_settings);
  }
  explicit ChangeSettingsRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ChangeSettingsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangeSettingsRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangeSettingsRequest> CreateChangeSettingsRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::rpc::SteamVRTrackersSetting> steam_vr_trackers = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::FilteringSettings> filtering = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::DriftCompensationSettings> drift_compensation = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::OSCRouterSettings> osc_router = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::VRCOSCSettings> vrc_osc = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::VMCOSCSettings> vmc_osc = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::settings::ModelSettings> model_settings = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::TapDetectionSettings> tap_detection_settings = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::AutoBoneSettings> auto_bone_settings = 0) {
  ChangeSettingsRequestBuilder builder_(_fbb);
  builder_.add_auto_bone_settings(auto_bone_settings);
  builder_.add_tap_detection_settings(tap_detection_settings);
  builder_.add_model_settings(model_settings);
  builder_.add_vmc_osc(vmc_osc);
  builder_.add_vrc_osc(vrc_osc);
  builder_.add_osc_router(osc_router);
  builder_.add_drift_compensation(drift_compensation);
  builder_.add_filtering(filtering);
  builder_.add_steam_vr_trackers(steam_vr_trackers);
  return builder_.Finish();
}

struct SteamVRTrackersSetting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SteamVRTrackersSettingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WAIST = 4,
    VT_CHEST = 6,
    VT_FEET = 8,
    VT_KNEES = 10,
    VT_ELBOWS = 12,
    VT_HANDS = 14
  };
  bool waist() const {
    return GetField<uint8_t>(VT_WAIST, 0) != 0;
  }
  bool chest() const {
    return GetField<uint8_t>(VT_CHEST, 0) != 0;
  }
  bool feet() const {
    return GetField<uint8_t>(VT_FEET, 0) != 0;
  }
  bool knees() const {
    return GetField<uint8_t>(VT_KNEES, 0) != 0;
  }
  bool elbows() const {
    return GetField<uint8_t>(VT_ELBOWS, 0) != 0;
  }
  bool hands() const {
    return GetField<uint8_t>(VT_HANDS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_WAIST, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHEST, 1) &&
           VerifyField<uint8_t>(verifier, VT_FEET, 1) &&
           VerifyField<uint8_t>(verifier, VT_KNEES, 1) &&
           VerifyField<uint8_t>(verifier, VT_ELBOWS, 1) &&
           VerifyField<uint8_t>(verifier, VT_HANDS, 1) &&
           verifier.EndTable();
  }
};

struct SteamVRTrackersSettingBuilder {
  typedef SteamVRTrackersSetting Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_waist(bool waist) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_WAIST, static_cast<uint8_t>(waist), 0);
  }
  void add_chest(bool chest) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_CHEST, static_cast<uint8_t>(chest), 0);
  }
  void add_feet(bool feet) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_FEET, static_cast<uint8_t>(feet), 0);
  }
  void add_knees(bool knees) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_KNEES, static_cast<uint8_t>(knees), 0);
  }
  void add_elbows(bool elbows) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_ELBOWS, static_cast<uint8_t>(elbows), 0);
  }
  void add_hands(bool hands) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_HANDS, static_cast<uint8_t>(hands), 0);
  }
  explicit SteamVRTrackersSettingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SteamVRTrackersSetting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SteamVRTrackersSetting>(end);
    return o;
  }
};

inline flatbuffers::Offset<SteamVRTrackersSetting> CreateSteamVRTrackersSetting(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool waist = false,
    bool chest = false,
    bool feet = false,
    bool knees = false,
    bool elbows = false,
    bool hands = false) {
  SteamVRTrackersSettingBuilder builder_(_fbb);
  builder_.add_hands(hands);
  builder_.add_elbows(elbows);
  builder_.add_knees(knees);
  builder_.add_feet(feet);
  builder_.add_chest(chest);
  builder_.add_waist(waist);
  return builder_.Finish();
}

struct FilteringSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FilteringSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_AMOUNT = 6
  };
  solarxr_protocol::datatypes::FilteringType type() const {
    return static_cast<solarxr_protocol::datatypes::FilteringType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  /// 0 to 1. A higher value results in more smoothing or prediction
  float amount() const {
    return GetField<float>(VT_AMOUNT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<float>(verifier, VT_AMOUNT, 4) &&
           verifier.EndTable();
  }
};

struct FilteringSettingsBuilder {
  typedef FilteringSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(solarxr_protocol::datatypes::FilteringType type) {
    fbb_.AddElement<uint8_t>(FilteringSettings::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_amount(float amount) {
    fbb_.AddElement<float>(FilteringSettings::VT_AMOUNT, amount, 0.0f);
  }
  explicit FilteringSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FilteringSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FilteringSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<FilteringSettings> CreateFilteringSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::FilteringType type = solarxr_protocol::datatypes::FilteringType::NONE,
    float amount = 0.0f) {
  FilteringSettingsBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_type(type);
  return builder_.Finish();
}

/// Settings related to IMU yaw drift compensation
struct DriftCompensationSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DriftCompensationSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLED = 4,
    VT_AMOUNT = 6,
    VT_MAX_RESETS = 8
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  /// 0 to 1. A higher value results in more yaw drift compensation
  float amount() const {
    return GetField<float>(VT_AMOUNT, 0.0f);
  }
  /// Number of previous resets to take into account when calculating yaw drift
  uint16_t max_resets() const {
    return GetField<uint16_t>(VT_MAX_RESETS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED, 1) &&
           VerifyField<float>(verifier, VT_AMOUNT, 4) &&
           VerifyField<uint16_t>(verifier, VT_MAX_RESETS, 2) &&
           verifier.EndTable();
  }
};

struct DriftCompensationSettingsBuilder {
  typedef DriftCompensationSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(DriftCompensationSettings::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_amount(float amount) {
    fbb_.AddElement<float>(DriftCompensationSettings::VT_AMOUNT, amount, 0.0f);
  }
  void add_max_resets(uint16_t max_resets) {
    fbb_.AddElement<uint16_t>(DriftCompensationSettings::VT_MAX_RESETS, max_resets, 0);
  }
  explicit DriftCompensationSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DriftCompensationSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DriftCompensationSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<DriftCompensationSettings> CreateDriftCompensationSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    float amount = 0.0f,
    uint16_t max_resets = 0) {
  DriftCompensationSettingsBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_max_resets(max_resets);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

/// OSC router forwards messages it receives, to allow the usage of multiple OSC programs for the same app.
struct OSCRouterSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OSCRouterSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OSC_SETTINGS = 4
  };
  const solarxr_protocol::rpc::OSCSettings *osc_settings() const {
    return GetPointer<const solarxr_protocol::rpc::OSCSettings *>(VT_OSC_SETTINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OSC_SETTINGS) &&
           verifier.VerifyTable(osc_settings()) &&
           verifier.EndTable();
  }
};

struct OSCRouterSettingsBuilder {
  typedef OSCRouterSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_osc_settings(flatbuffers::Offset<solarxr_protocol::rpc::OSCSettings> osc_settings) {
    fbb_.AddOffset(OSCRouterSettings::VT_OSC_SETTINGS, osc_settings);
  }
  explicit OSCRouterSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OSCRouterSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OSCRouterSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<OSCRouterSettings> CreateOSCRouterSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::rpc::OSCSettings> osc_settings = 0) {
  OSCRouterSettingsBuilder builder_(_fbb);
  builder_.add_osc_settings(osc_settings);
  return builder_.Finish();
}

/// OSC Settings specific to VRChat
struct VRCOSCSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VRCOSCSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OSC_SETTINGS = 4,
    VT_TRACKERS = 6
  };
  const solarxr_protocol::rpc::OSCSettings *osc_settings() const {
    return GetPointer<const solarxr_protocol::rpc::OSCSettings *>(VT_OSC_SETTINGS);
  }
  const solarxr_protocol::rpc::OSCTrackersSetting *trackers() const {
    return GetPointer<const solarxr_protocol::rpc::OSCTrackersSetting *>(VT_TRACKERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OSC_SETTINGS) &&
           verifier.VerifyTable(osc_settings()) &&
           VerifyOffset(verifier, VT_TRACKERS) &&
           verifier.VerifyTable(trackers()) &&
           verifier.EndTable();
  }
};

struct VRCOSCSettingsBuilder {
  typedef VRCOSCSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_osc_settings(flatbuffers::Offset<solarxr_protocol::rpc::OSCSettings> osc_settings) {
    fbb_.AddOffset(VRCOSCSettings::VT_OSC_SETTINGS, osc_settings);
  }
  void add_trackers(flatbuffers::Offset<solarxr_protocol::rpc::OSCTrackersSetting> trackers) {
    fbb_.AddOffset(VRCOSCSettings::VT_TRACKERS, trackers);
  }
  explicit VRCOSCSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VRCOSCSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VRCOSCSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<VRCOSCSettings> CreateVRCOSCSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::rpc::OSCSettings> osc_settings = 0,
    flatbuffers::Offset<solarxr_protocol::rpc::OSCTrackersSetting> trackers = 0) {
  VRCOSCSettingsBuilder builder_(_fbb);
  builder_.add_trackers(trackers);
  builder_.add_osc_settings(osc_settings);
  return builder_.Finish();
}

/// OSC Settings specific to VMC
struct VMCOSCSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VMCOSCSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OSC_SETTINGS = 4,
    VT_VRM_JSON = 6,
    VT_ANCHOR_HIP = 8
  };
  const solarxr_protocol::rpc::OSCSettings *osc_settings() const {
    return GetPointer<const solarxr_protocol::rpc::OSCSettings *>(VT_OSC_SETTINGS);
  }
  const flatbuffers::String *vrm_json() const {
    return GetPointer<const flatbuffers::String *>(VT_VRM_JSON);
  }
  bool anchor_hip() const {
    return GetField<uint8_t>(VT_ANCHOR_HIP, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OSC_SETTINGS) &&
           verifier.VerifyTable(osc_settings()) &&
           VerifyOffset(verifier, VT_VRM_JSON) &&
           verifier.VerifyString(vrm_json()) &&
           VerifyField<uint8_t>(verifier, VT_ANCHOR_HIP, 1) &&
           verifier.EndTable();
  }
};

struct VMCOSCSettingsBuilder {
  typedef VMCOSCSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_osc_settings(flatbuffers::Offset<solarxr_protocol::rpc::OSCSettings> osc_settings) {
    fbb_.AddOffset(VMCOSCSettings::VT_OSC_SETTINGS, osc_settings);
  }
  void add_vrm_json(flatbuffers::Offset<flatbuffers::String> vrm_json) {
    fbb_.AddOffset(VMCOSCSettings::VT_VRM_JSON, vrm_json);
  }
  void add_anchor_hip(bool anchor_hip) {
    fbb_.AddElement<uint8_t>(VMCOSCSettings::VT_ANCHOR_HIP, static_cast<uint8_t>(anchor_hip), 0);
  }
  explicit VMCOSCSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VMCOSCSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VMCOSCSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<VMCOSCSettings> CreateVMCOSCSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::rpc::OSCSettings> osc_settings = 0,
    flatbuffers::Offset<flatbuffers::String> vrm_json = 0,
    bool anchor_hip = false) {
  VMCOSCSettingsBuilder builder_(_fbb);
  builder_.add_vrm_json(vrm_json);
  builder_.add_osc_settings(osc_settings);
  builder_.add_anchor_hip(anchor_hip);
  return builder_.Finish();
}

inline flatbuffers::Offset<VMCOSCSettings> CreateVMCOSCSettingsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::rpc::OSCSettings> osc_settings = 0,
    const char *vrm_json = nullptr,
    bool anchor_hip = false) {
  auto vrm_json__ = vrm_json ? _fbb.CreateString(vrm_json) : 0;
  return solarxr_protocol::rpc::CreateVMCOSCSettings(
      _fbb,
      osc_settings,
      vrm_json__,
      anchor_hip);
}

/// OSC Settings that are used in *any* osc application.
struct OSCSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OSCSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLED = 4,
    VT_PORT_IN = 6,
    VT_PORT_OUT = 8,
    VT_ADDRESS = 10
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  uint16_t port_in() const {
    return GetField<uint16_t>(VT_PORT_IN, 0);
  }
  uint16_t port_out() const {
    return GetField<uint16_t>(VT_PORT_OUT, 0);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED, 1) &&
           VerifyField<uint16_t>(verifier, VT_PORT_IN, 2) &&
           VerifyField<uint16_t>(verifier, VT_PORT_OUT, 2) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyString(address()) &&
           verifier.EndTable();
  }
};

struct OSCSettingsBuilder {
  typedef OSCSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(OSCSettings::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_port_in(uint16_t port_in) {
    fbb_.AddElement<uint16_t>(OSCSettings::VT_PORT_IN, port_in, 0);
  }
  void add_port_out(uint16_t port_out) {
    fbb_.AddElement<uint16_t>(OSCSettings::VT_PORT_OUT, port_out, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(OSCSettings::VT_ADDRESS, address);
  }
  explicit OSCSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OSCSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OSCSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<OSCSettings> CreateOSCSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    uint16_t port_in = 0,
    uint16_t port_out = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0) {
  OSCSettingsBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_port_out(port_out);
  builder_.add_port_in(port_in);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<OSCSettings> CreateOSCSettingsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    uint16_t port_in = 0,
    uint16_t port_out = 0,
    const char *address = nullptr) {
  auto address__ = address ? _fbb.CreateString(address) : 0;
  return solarxr_protocol::rpc::CreateOSCSettings(
      _fbb,
      enabled,
      port_in,
      port_out,
      address__);
}

struct OSCTrackersSetting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OSCTrackersSettingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEAD = 4,
    VT_CHEST = 6,
    VT_WAIST = 8,
    VT_KNEES = 10,
    VT_FEET = 12,
    VT_ELBOWS = 14,
    VT_HANDS = 16
  };
  bool head() const {
    return GetField<uint8_t>(VT_HEAD, 0) != 0;
  }
  bool chest() const {
    return GetField<uint8_t>(VT_CHEST, 0) != 0;
  }
  bool waist() const {
    return GetField<uint8_t>(VT_WAIST, 0) != 0;
  }
  bool knees() const {
    return GetField<uint8_t>(VT_KNEES, 0) != 0;
  }
  bool feet() const {
    return GetField<uint8_t>(VT_FEET, 0) != 0;
  }
  bool elbows() const {
    return GetField<uint8_t>(VT_ELBOWS, 0) != 0;
  }
  bool hands() const {
    return GetField<uint8_t>(VT_HANDS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HEAD, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHEST, 1) &&
           VerifyField<uint8_t>(verifier, VT_WAIST, 1) &&
           VerifyField<uint8_t>(verifier, VT_KNEES, 1) &&
           VerifyField<uint8_t>(verifier, VT_FEET, 1) &&
           VerifyField<uint8_t>(verifier, VT_ELBOWS, 1) &&
           VerifyField<uint8_t>(verifier, VT_HANDS, 1) &&
           verifier.EndTable();
  }
};

struct OSCTrackersSettingBuilder {
  typedef OSCTrackersSetting Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_head(bool head) {
    fbb_.AddElement<uint8_t>(OSCTrackersSetting::VT_HEAD, static_cast<uint8_t>(head), 0);
  }
  void add_chest(bool chest) {
    fbb_.AddElement<uint8_t>(OSCTrackersSetting::VT_CHEST, static_cast<uint8_t>(chest), 0);
  }
  void add_waist(bool waist) {
    fbb_.AddElement<uint8_t>(OSCTrackersSetting::VT_WAIST, static_cast<uint8_t>(waist), 0);
  }
  void add_knees(bool knees) {
    fbb_.AddElement<uint8_t>(OSCTrackersSetting::VT_KNEES, static_cast<uint8_t>(knees), 0);
  }
  void add_feet(bool feet) {
    fbb_.AddElement<uint8_t>(OSCTrackersSetting::VT_FEET, static_cast<uint8_t>(feet), 0);
  }
  void add_elbows(bool elbows) {
    fbb_.AddElement<uint8_t>(OSCTrackersSetting::VT_ELBOWS, static_cast<uint8_t>(elbows), 0);
  }
  void add_hands(bool hands) {
    fbb_.AddElement<uint8_t>(OSCTrackersSetting::VT_HANDS, static_cast<uint8_t>(hands), 0);
  }
  explicit OSCTrackersSettingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OSCTrackersSetting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OSCTrackersSetting>(end);
    return o;
  }
};

inline flatbuffers::Offset<OSCTrackersSetting> CreateOSCTrackersSetting(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool head = false,
    bool chest = false,
    bool waist = false,
    bool knees = false,
    bool feet = false,
    bool elbows = false,
    bool hands = false) {
  OSCTrackersSettingBuilder builder_(_fbb);
  builder_.add_hands(hands);
  builder_.add_elbows(elbows);
  builder_.add_feet(feet);
  builder_.add_knees(knees);
  builder_.add_waist(waist);
  builder_.add_chest(chest);
  builder_.add_head(head);
  return builder_.Finish();
}

struct TapDetectionSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TapDetectionSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FULL_RESET_DELAY = 4,
    VT_FULL_RESET_ENABLED = 6,
    VT_FULL_RESET_TAPS = 8,
    VT_YAW_RESET_DELAY = 10,
    VT_YAW_RESET_ENABLED = 12,
    VT_YAW_RESET_TAPS = 14,
    VT_MOUNTING_RESET_DELAY = 16,
    VT_MOUNTING_RESET_ENABLED = 18,
    VT_MOUNTING_RESET_TAPS = 20,
    VT_SETUP_MODE = 22
  };
  flatbuffers::Optional<float> full_reset_delay() const {
    return GetOptional<float, float>(VT_FULL_RESET_DELAY);
  }
  flatbuffers::Optional<bool> full_reset_enabled() const {
    return GetOptional<uint8_t, bool>(VT_FULL_RESET_ENABLED);
  }
  flatbuffers::Optional<uint8_t> full_reset_taps() const {
    return GetOptional<uint8_t, uint8_t>(VT_FULL_RESET_TAPS);
  }
  flatbuffers::Optional<float> yaw_reset_delay() const {
    return GetOptional<float, float>(VT_YAW_RESET_DELAY);
  }
  flatbuffers::Optional<bool> yaw_reset_enabled() const {
    return GetOptional<uint8_t, bool>(VT_YAW_RESET_ENABLED);
  }
  flatbuffers::Optional<uint8_t> yaw_reset_taps() const {
    return GetOptional<uint8_t, uint8_t>(VT_YAW_RESET_TAPS);
  }
  flatbuffers::Optional<float> mounting_reset_delay() const {
    return GetOptional<float, float>(VT_MOUNTING_RESET_DELAY);
  }
  flatbuffers::Optional<bool> mounting_reset_enabled() const {
    return GetOptional<uint8_t, bool>(VT_MOUNTING_RESET_ENABLED);
  }
  flatbuffers::Optional<uint8_t> mounting_reset_taps() const {
    return GetOptional<uint8_t, uint8_t>(VT_MOUNTING_RESET_TAPS);
  }
  /// Iff true, disables reset behavior of tap detection and sends a
  /// TapDetectionSetupNotification, each time 2 taps are detected on any tracker
  flatbuffers::Optional<bool> setup_mode() const {
    return GetOptional<uint8_t, bool>(VT_SETUP_MODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FULL_RESET_DELAY, 4) &&
           VerifyField<uint8_t>(verifier, VT_FULL_RESET_ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_FULL_RESET_TAPS, 1) &&
           VerifyField<float>(verifier, VT_YAW_RESET_DELAY, 4) &&
           VerifyField<uint8_t>(verifier, VT_YAW_RESET_ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_YAW_RESET_TAPS, 1) &&
           VerifyField<float>(verifier, VT_MOUNTING_RESET_DELAY, 4) &&
           VerifyField<uint8_t>(verifier, VT_MOUNTING_RESET_ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_MOUNTING_RESET_TAPS, 1) &&
           VerifyField<uint8_t>(verifier, VT_SETUP_MODE, 1) &&
           verifier.EndTable();
  }
};

struct TapDetectionSettingsBuilder {
  typedef TapDetectionSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_full_reset_delay(float full_reset_delay) {
    fbb_.AddElement<float>(TapDetectionSettings::VT_FULL_RESET_DELAY, full_reset_delay);
  }
  void add_full_reset_enabled(bool full_reset_enabled) {
    fbb_.AddElement<uint8_t>(TapDetectionSettings::VT_FULL_RESET_ENABLED, static_cast<uint8_t>(full_reset_enabled));
  }
  void add_full_reset_taps(uint8_t full_reset_taps) {
    fbb_.AddElement<uint8_t>(TapDetectionSettings::VT_FULL_RESET_TAPS, full_reset_taps);
  }
  void add_yaw_reset_delay(float yaw_reset_delay) {
    fbb_.AddElement<float>(TapDetectionSettings::VT_YAW_RESET_DELAY, yaw_reset_delay);
  }
  void add_yaw_reset_enabled(bool yaw_reset_enabled) {
    fbb_.AddElement<uint8_t>(TapDetectionSettings::VT_YAW_RESET_ENABLED, static_cast<uint8_t>(yaw_reset_enabled));
  }
  void add_yaw_reset_taps(uint8_t yaw_reset_taps) {
    fbb_.AddElement<uint8_t>(TapDetectionSettings::VT_YAW_RESET_TAPS, yaw_reset_taps);
  }
  void add_mounting_reset_delay(float mounting_reset_delay) {
    fbb_.AddElement<float>(TapDetectionSettings::VT_MOUNTING_RESET_DELAY, mounting_reset_delay);
  }
  void add_mounting_reset_enabled(bool mounting_reset_enabled) {
    fbb_.AddElement<uint8_t>(TapDetectionSettings::VT_MOUNTING_RESET_ENABLED, static_cast<uint8_t>(mounting_reset_enabled));
  }
  void add_mounting_reset_taps(uint8_t mounting_reset_taps) {
    fbb_.AddElement<uint8_t>(TapDetectionSettings::VT_MOUNTING_RESET_TAPS, mounting_reset_taps);
  }
  void add_setup_mode(bool setup_mode) {
    fbb_.AddElement<uint8_t>(TapDetectionSettings::VT_SETUP_MODE, static_cast<uint8_t>(setup_mode));
  }
  explicit TapDetectionSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TapDetectionSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TapDetectionSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<TapDetectionSettings> CreateTapDetectionSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<float> full_reset_delay = flatbuffers::nullopt,
    flatbuffers::Optional<bool> full_reset_enabled = flatbuffers::nullopt,
    flatbuffers::Optional<uint8_t> full_reset_taps = flatbuffers::nullopt,
    flatbuffers::Optional<float> yaw_reset_delay = flatbuffers::nullopt,
    flatbuffers::Optional<bool> yaw_reset_enabled = flatbuffers::nullopt,
    flatbuffers::Optional<uint8_t> yaw_reset_taps = flatbuffers::nullopt,
    flatbuffers::Optional<float> mounting_reset_delay = flatbuffers::nullopt,
    flatbuffers::Optional<bool> mounting_reset_enabled = flatbuffers::nullopt,
    flatbuffers::Optional<uint8_t> mounting_reset_taps = flatbuffers::nullopt,
    flatbuffers::Optional<bool> setup_mode = flatbuffers::nullopt) {
  TapDetectionSettingsBuilder builder_(_fbb);
  if(mounting_reset_delay) { builder_.add_mounting_reset_delay(*mounting_reset_delay); }
  if(yaw_reset_delay) { builder_.add_yaw_reset_delay(*yaw_reset_delay); }
  if(full_reset_delay) { builder_.add_full_reset_delay(*full_reset_delay); }
  if(setup_mode) { builder_.add_setup_mode(*setup_mode); }
  if(mounting_reset_taps) { builder_.add_mounting_reset_taps(*mounting_reset_taps); }
  if(mounting_reset_enabled) { builder_.add_mounting_reset_enabled(*mounting_reset_enabled); }
  if(yaw_reset_taps) { builder_.add_yaw_reset_taps(*yaw_reset_taps); }
  if(yaw_reset_enabled) { builder_.add_yaw_reset_enabled(*yaw_reset_enabled); }
  if(full_reset_taps) { builder_.add_full_reset_taps(*full_reset_taps); }
  if(full_reset_enabled) { builder_.add_full_reset_enabled(*full_reset_enabled); }
  return builder_.Finish();
}

/// See TapDetectionSettings::setup_mode
struct TapDetectionSetupNotification FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TapDetectionSetupNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACKER_ID = 4
  };
  const solarxr_protocol::datatypes::TrackerId *tracker_id() const {
    return GetPointer<const solarxr_protocol::datatypes::TrackerId *>(VT_TRACKER_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACKER_ID) &&
           verifier.VerifyTable(tracker_id()) &&
           verifier.EndTable();
  }
};

struct TapDetectionSetupNotificationBuilder {
  typedef TapDetectionSetupNotification Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tracker_id(flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id) {
    fbb_.AddOffset(TapDetectionSetupNotification::VT_TRACKER_ID, tracker_id);
  }
  explicit TapDetectionSetupNotificationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TapDetectionSetupNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TapDetectionSetupNotification>(end);
    return o;
  }
};

inline flatbuffers::Offset<TapDetectionSetupNotification> CreateTapDetectionSetupNotification(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id = 0) {
  TapDetectionSetupNotificationBuilder builder_(_fbb);
  builder_.add_tracker_id(tracker_id);
  return builder_.Finish();
}

struct RecordBVHRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordBVHRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STOP = 4
  };
  bool stop() const {
    return GetField<uint8_t>(VT_STOP, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STOP, 1) &&
           verifier.EndTable();
  }
};

struct RecordBVHRequestBuilder {
  typedef RecordBVHRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stop(bool stop) {
    fbb_.AddElement<uint8_t>(RecordBVHRequest::VT_STOP, static_cast<uint8_t>(stop), 0);
  }
  explicit RecordBVHRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RecordBVHRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecordBVHRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecordBVHRequest> CreateRecordBVHRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool stop = false) {
  RecordBVHRequestBuilder builder_(_fbb);
  builder_.add_stop(stop);
  return builder_.Finish();
}

struct RecordBVHStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordBVHStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDING = 4
  };
  bool recording() const {
    return GetField<uint8_t>(VT_RECORDING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RECORDING, 1) &&
           verifier.EndTable();
  }
};

struct RecordBVHStatusBuilder {
  typedef RecordBVHStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_recording(bool recording) {
    fbb_.AddElement<uint8_t>(RecordBVHStatus::VT_RECORDING, static_cast<uint8_t>(recording), 0);
  }
  explicit RecordBVHStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RecordBVHStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecordBVHStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecordBVHStatus> CreateRecordBVHStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool recording = false) {
  RecordBVHStatusBuilder builder_(_fbb);
  builder_.add_recording(recording);
  return builder_.Finish();
}

struct SkeletonPart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkeletonPartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BONE = 4,
    VT_VALUE = 6
  };
  solarxr_protocol::rpc::SkeletonBone bone() const {
    return static_cast<solarxr_protocol::rpc::SkeletonBone>(GetField<uint8_t>(VT_BONE, 0));
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BONE, 1) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct SkeletonPartBuilder {
  typedef SkeletonPart Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bone(solarxr_protocol::rpc::SkeletonBone bone) {
    fbb_.AddElement<uint8_t>(SkeletonPart::VT_BONE, static_cast<uint8_t>(bone), 0);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(SkeletonPart::VT_VALUE, value, 0.0f);
  }
  explicit SkeletonPartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkeletonPart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkeletonPart>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkeletonPart> CreateSkeletonPart(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::rpc::SkeletonBone bone = solarxr_protocol::rpc::SkeletonBone::NONE,
    float value = 0.0f) {
  SkeletonPartBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_bone(bone);
  return builder_.Finish();
}

struct SkeletonConfigRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkeletonConfigRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SkeletonConfigRequestBuilder {
  typedef SkeletonConfigRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SkeletonConfigRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkeletonConfigRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkeletonConfigRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkeletonConfigRequest> CreateSkeletonConfigRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SkeletonConfigRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SkeletonConfigResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkeletonConfigResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKELETON_PARTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>> *skeleton_parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>> *>(VT_SKELETON_PARTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SKELETON_PARTS) &&
           verifier.VerifyVector(skeleton_parts()) &&
           verifier.VerifyVectorOfTables(skeleton_parts()) &&
           verifier.EndTable();
  }
};

struct SkeletonConfigResponseBuilder {
  typedef SkeletonConfigResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skeleton_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>>> skeleton_parts) {
    fbb_.AddOffset(SkeletonConfigResponse::VT_SKELETON_PARTS, skeleton_parts);
  }
  explicit SkeletonConfigResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkeletonConfigResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkeletonConfigResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkeletonConfigResponse> CreateSkeletonConfigResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>>> skeleton_parts = 0) {
  SkeletonConfigResponseBuilder builder_(_fbb);
  builder_.add_skeleton_parts(skeleton_parts);
  return builder_.Finish();
}

inline flatbuffers::Offset<SkeletonConfigResponse> CreateSkeletonConfigResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>> *skeleton_parts = nullptr) {
  auto skeleton_parts__ = skeleton_parts ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>>(*skeleton_parts) : 0;
  return solarxr_protocol::rpc::CreateSkeletonConfigResponse(
      _fbb,
      skeleton_parts__);
}

struct SkeletonResetAllRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkeletonResetAllRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SkeletonResetAllRequestBuilder {
  typedef SkeletonResetAllRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SkeletonResetAllRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkeletonResetAllRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkeletonResetAllRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkeletonResetAllRequest> CreateSkeletonResetAllRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SkeletonResetAllRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ChangeSkeletonConfigRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChangeSkeletonConfigRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BONE = 4,
    VT_VALUE = 6
  };
  solarxr_protocol::rpc::SkeletonBone bone() const {
    return static_cast<solarxr_protocol::rpc::SkeletonBone>(GetField<uint8_t>(VT_BONE, 0));
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BONE, 1) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct ChangeSkeletonConfigRequestBuilder {
  typedef ChangeSkeletonConfigRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bone(solarxr_protocol::rpc::SkeletonBone bone) {
    fbb_.AddElement<uint8_t>(ChangeSkeletonConfigRequest::VT_BONE, static_cast<uint8_t>(bone), 0);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(ChangeSkeletonConfigRequest::VT_VALUE, value, 0.0f);
  }
  explicit ChangeSkeletonConfigRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ChangeSkeletonConfigRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangeSkeletonConfigRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangeSkeletonConfigRequest> CreateChangeSkeletonConfigRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::rpc::SkeletonBone bone = solarxr_protocol::rpc::SkeletonBone::NONE,
    float value = 0.0f) {
  ChangeSkeletonConfigRequestBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_bone(bone);
  return builder_.Finish();
}

struct SerialDevice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerialDeviceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PORT = 4,
    VT_NAME = 6
  };
  const flatbuffers::String *port() const {
    return GetPointer<const flatbuffers::String *>(VT_PORT);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PORT) &&
           verifier.VerifyString(port()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct SerialDeviceBuilder {
  typedef SerialDevice Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_port(flatbuffers::Offset<flatbuffers::String> port) {
    fbb_.AddOffset(SerialDevice::VT_PORT, port);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SerialDevice::VT_NAME, name);
  }
  explicit SerialDeviceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SerialDevice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerialDevice>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerialDevice> CreateSerialDevice(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> port = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  SerialDeviceBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_port(port);
  return builder_.Finish();
}

inline flatbuffers::Offset<SerialDevice> CreateSerialDeviceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *port = nullptr,
    const char *name = nullptr) {
  auto port__ = port ? _fbb.CreateString(port) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return solarxr_protocol::rpc::CreateSerialDevice(
      _fbb,
      port__,
      name__);
}

struct OpenSerialRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpenSerialRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AUTO_ = 4,
    VT_PORT = 6
  };
  /// Automaticaly pick the first serial device available
  bool auto_() const {
    return GetField<uint8_t>(VT_AUTO_, 0) != 0;
  }
  const flatbuffers::String *port() const {
    return GetPointer<const flatbuffers::String *>(VT_PORT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_AUTO_, 1) &&
           VerifyOffset(verifier, VT_PORT) &&
           verifier.VerifyString(port()) &&
           verifier.EndTable();
  }
};

struct OpenSerialRequestBuilder {
  typedef OpenSerialRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_auto_(bool auto_) {
    fbb_.AddElement<uint8_t>(OpenSerialRequest::VT_AUTO_, static_cast<uint8_t>(auto_), 0);
  }
  void add_port(flatbuffers::Offset<flatbuffers::String> port) {
    fbb_.AddOffset(OpenSerialRequest::VT_PORT, port);
  }
  explicit OpenSerialRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OpenSerialRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpenSerialRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpenSerialRequest> CreateOpenSerialRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool auto_ = false,
    flatbuffers::Offset<flatbuffers::String> port = 0) {
  OpenSerialRequestBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_auto_(auto_);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpenSerialRequest> CreateOpenSerialRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool auto_ = false,
    const char *port = nullptr) {
  auto port__ = port ? _fbb.CreateString(port) : 0;
  return solarxr_protocol::rpc::CreateOpenSerialRequest(
      _fbb,
      auto_,
      port__);
}

struct CloseSerialRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CloseSerialRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CloseSerialRequestBuilder {
  typedef CloseSerialRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CloseSerialRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CloseSerialRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CloseSerialRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CloseSerialRequest> CreateCloseSerialRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CloseSerialRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SetWifiRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetWifiRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSID = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *ssid() const {
    return GetPointer<const flatbuffers::String *>(VT_SSID);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SSID) &&
           verifier.VerifyString(ssid()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           verifier.EndTable();
  }
};

struct SetWifiRequestBuilder {
  typedef SetWifiRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ssid(flatbuffers::Offset<flatbuffers::String> ssid) {
    fbb_.AddOffset(SetWifiRequest::VT_SSID, ssid);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(SetWifiRequest::VT_PASSWORD, password);
  }
  explicit SetWifiRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SetWifiRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetWifiRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetWifiRequest> CreateSetWifiRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ssid = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  SetWifiRequestBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_ssid(ssid);
  return builder_.Finish();
}

inline flatbuffers::Offset<SetWifiRequest> CreateSetWifiRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ssid = nullptr,
    const char *password = nullptr) {
  auto ssid__ = ssid ? _fbb.CreateString(ssid) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return solarxr_protocol::rpc::CreateSetWifiRequest(
      _fbb,
      ssid__,
      password__);
}

struct SerialUpdateResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerialUpdateResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOG = 4,
    VT_CLOSED = 6
  };
  const flatbuffers::String *log() const {
    return GetPointer<const flatbuffers::String *>(VT_LOG);
  }
  bool closed() const {
    return GetField<uint8_t>(VT_CLOSED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOG) &&
           verifier.VerifyString(log()) &&
           VerifyField<uint8_t>(verifier, VT_CLOSED, 1) &&
           verifier.EndTable();
  }
};

struct SerialUpdateResponseBuilder {
  typedef SerialUpdateResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_log(flatbuffers::Offset<flatbuffers::String> log) {
    fbb_.AddOffset(SerialUpdateResponse::VT_LOG, log);
  }
  void add_closed(bool closed) {
    fbb_.AddElement<uint8_t>(SerialUpdateResponse::VT_CLOSED, static_cast<uint8_t>(closed), 0);
  }
  explicit SerialUpdateResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SerialUpdateResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerialUpdateResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerialUpdateResponse> CreateSerialUpdateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> log = 0,
    bool closed = false) {
  SerialUpdateResponseBuilder builder_(_fbb);
  builder_.add_log(log);
  builder_.add_closed(closed);
  return builder_.Finish();
}

inline flatbuffers::Offset<SerialUpdateResponse> CreateSerialUpdateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *log = nullptr,
    bool closed = false) {
  auto log__ = log ? _fbb.CreateString(log) : 0;
  return solarxr_protocol::rpc::CreateSerialUpdateResponse(
      _fbb,
      log__,
      closed);
}

/// Reboots the tracker connected to the serial monitor
struct SerialTrackerRebootRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerialTrackerRebootRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SerialTrackerRebootRequestBuilder {
  typedef SerialTrackerRebootRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SerialTrackerRebootRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SerialTrackerRebootRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerialTrackerRebootRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerialTrackerRebootRequest> CreateSerialTrackerRebootRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SerialTrackerRebootRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Sends the GET INFO cmd to the current tracker on the serial monitor
struct SerialTrackerGetInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerialTrackerGetInfoRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SerialTrackerGetInfoRequestBuilder {
  typedef SerialTrackerGetInfoRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SerialTrackerGetInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SerialTrackerGetInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerialTrackerGetInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerialTrackerGetInfoRequest> CreateSerialTrackerGetInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SerialTrackerGetInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Sends the FRST cmd to the currently over the Serial Montior connected Tracker
struct SerialTrackerFactoryResetRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerialTrackerFactoryResetRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SerialTrackerFactoryResetRequestBuilder {
  typedef SerialTrackerFactoryResetRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SerialTrackerFactoryResetRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SerialTrackerFactoryResetRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerialTrackerFactoryResetRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerialTrackerFactoryResetRequest> CreateSerialTrackerFactoryResetRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SerialTrackerFactoryResetRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SerialDevicesRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerialDevicesRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SerialDevicesRequestBuilder {
  typedef SerialDevicesRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SerialDevicesRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SerialDevicesRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerialDevicesRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerialDevicesRequest> CreateSerialDevicesRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SerialDevicesRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SerialDevicesResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerialDevicesResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SerialDevice>> *devices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SerialDevice>> *>(VT_DEVICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICES) &&
           verifier.VerifyVector(devices()) &&
           verifier.VerifyVectorOfTables(devices()) &&
           verifier.EndTable();
  }
};

struct SerialDevicesResponseBuilder {
  typedef SerialDevicesResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_devices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SerialDevice>>> devices) {
    fbb_.AddOffset(SerialDevicesResponse::VT_DEVICES, devices);
  }
  explicit SerialDevicesResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SerialDevicesResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerialDevicesResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerialDevicesResponse> CreateSerialDevicesResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SerialDevice>>> devices = 0) {
  SerialDevicesResponseBuilder builder_(_fbb);
  builder_.add_devices(devices);
  return builder_.Finish();
}

inline flatbuffers::Offset<SerialDevicesResponse> CreateSerialDevicesResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::rpc::SerialDevice>> *devices = nullptr) {
  auto devices__ = devices ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::rpc::SerialDevice>>(*devices) : 0;
  return solarxr_protocol::rpc::CreateSerialDevicesResponse(
      _fbb,
      devices__);
}

struct NewSerialDeviceResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NewSerialDeviceResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICE = 4
  };
  const solarxr_protocol::rpc::SerialDevice *device() const {
    return GetPointer<const solarxr_protocol::rpc::SerialDevice *>(VT_DEVICE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICE) &&
           verifier.VerifyTable(device()) &&
           verifier.EndTable();
  }
};

struct NewSerialDeviceResponseBuilder {
  typedef NewSerialDeviceResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_device(flatbuffers::Offset<solarxr_protocol::rpc::SerialDevice> device) {
    fbb_.AddOffset(NewSerialDeviceResponse::VT_DEVICE, device);
  }
  explicit NewSerialDeviceResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NewSerialDeviceResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NewSerialDeviceResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<NewSerialDeviceResponse> CreateNewSerialDeviceResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::rpc::SerialDevice> device = 0) {
  NewSerialDeviceResponseBuilder builder_(_fbb);
  builder_.add_device(device);
  return builder_.Finish();
}

struct StartWifiProvisioningRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StartWifiProvisioningRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSID = 4,
    VT_PASSWORD = 6,
    VT_PORT = 8
  };
  const flatbuffers::String *ssid() const {
    return GetPointer<const flatbuffers::String *>(VT_SSID);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  const flatbuffers::String *port() const {
    return GetPointer<const flatbuffers::String *>(VT_PORT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SSID) &&
           verifier.VerifyString(ssid()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           VerifyOffset(verifier, VT_PORT) &&
           verifier.VerifyString(port()) &&
           verifier.EndTable();
  }
};

struct StartWifiProvisioningRequestBuilder {
  typedef StartWifiProvisioningRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ssid(flatbuffers::Offset<flatbuffers::String> ssid) {
    fbb_.AddOffset(StartWifiProvisioningRequest::VT_SSID, ssid);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(StartWifiProvisioningRequest::VT_PASSWORD, password);
  }
  void add_port(flatbuffers::Offset<flatbuffers::String> port) {
    fbb_.AddOffset(StartWifiProvisioningRequest::VT_PORT, port);
  }
  explicit StartWifiProvisioningRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StartWifiProvisioningRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartWifiProvisioningRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartWifiProvisioningRequest> CreateStartWifiProvisioningRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ssid = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0,
    flatbuffers::Offset<flatbuffers::String> port = 0) {
  StartWifiProvisioningRequestBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_password(password);
  builder_.add_ssid(ssid);
  return builder_.Finish();
}

inline flatbuffers::Offset<StartWifiProvisioningRequest> CreateStartWifiProvisioningRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ssid = nullptr,
    const char *password = nullptr,
    const char *port = nullptr) {
  auto ssid__ = ssid ? _fbb.CreateString(ssid) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  auto port__ = port ? _fbb.CreateString(port) : 0;
  return solarxr_protocol::rpc::CreateStartWifiProvisioningRequest(
      _fbb,
      ssid__,
      password__,
      port__);
}

struct StopWifiProvisioningRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StopWifiProvisioningRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct StopWifiProvisioningRequestBuilder {
  typedef StopWifiProvisioningRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit StopWifiProvisioningRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StopWifiProvisioningRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StopWifiProvisioningRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<StopWifiProvisioningRequest> CreateStopWifiProvisioningRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StopWifiProvisioningRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct WifiProvisioningStatusResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WifiProvisioningStatusResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4
  };
  solarxr_protocol::rpc::WifiProvisioningStatus status() const {
    return static_cast<solarxr_protocol::rpc::WifiProvisioningStatus>(GetField<uint8_t>(VT_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           verifier.EndTable();
  }
};

struct WifiProvisioningStatusResponseBuilder {
  typedef WifiProvisioningStatusResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(solarxr_protocol::rpc::WifiProvisioningStatus status) {
    fbb_.AddElement<uint8_t>(WifiProvisioningStatusResponse::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  explicit WifiProvisioningStatusResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WifiProvisioningStatusResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WifiProvisioningStatusResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<WifiProvisioningStatusResponse> CreateWifiProvisioningStatusResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::rpc::WifiProvisioningStatus status = solarxr_protocol::rpc::WifiProvisioningStatus::NONE) {
  WifiProvisioningStatusResponseBuilder builder_(_fbb);
  builder_.add_status(status);
  return builder_.Finish();
}

struct AutoBoneProcessRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoBoneProcessRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROCESS_TYPE = 4
  };
  solarxr_protocol::rpc::AutoBoneProcessType process_type() const {
    return static_cast<solarxr_protocol::rpc::AutoBoneProcessType>(GetField<uint8_t>(VT_PROCESS_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PROCESS_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct AutoBoneProcessRequestBuilder {
  typedef AutoBoneProcessRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_process_type(solarxr_protocol::rpc::AutoBoneProcessType process_type) {
    fbb_.AddElement<uint8_t>(AutoBoneProcessRequest::VT_PROCESS_TYPE, static_cast<uint8_t>(process_type), 0);
  }
  explicit AutoBoneProcessRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AutoBoneProcessRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoBoneProcessRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoBoneProcessRequest> CreateAutoBoneProcessRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::rpc::AutoBoneProcessType process_type = solarxr_protocol::rpc::AutoBoneProcessType::NONE) {
  AutoBoneProcessRequestBuilder builder_(_fbb);
  builder_.add_process_type(process_type);
  return builder_.Finish();
}

struct AutoBoneProcessStatusResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoBoneProcessStatusResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROCESS_TYPE = 4,
    VT_CURRENT = 8,
    VT_TOTAL = 10,
    VT_COMPLETED = 12,
    VT_SUCCESS = 14,
    VT_ETA = 16
  };
  solarxr_protocol::rpc::AutoBoneProcessType process_type() const {
    return static_cast<solarxr_protocol::rpc::AutoBoneProcessType>(GetField<uint8_t>(VT_PROCESS_TYPE, 0));
  }
  /// The current count. This value is -1 if there is nothing to report.
  uint32_t current() const {
    return GetField<uint32_t>(VT_CURRENT, 0);
  }
  /// The total count. This value is -1 if there is nothing to report.
  uint32_t total() const {
    return GetField<uint32_t>(VT_TOTAL, 0);
  }
  /// True if the operation has completed with any result, successful or not.
  bool completed() const {
    return GetField<uint8_t>(VT_COMPLETED, 0) != 0;
  }
  /// True if the completed operation was successful, only observe if `completed` is true.
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  /// The time remaining in seconds. This value is -1 if there is nothing to report.
  float eta() const {
    return GetField<float>(VT_ETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PROCESS_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_CURRENT, 4) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL, 4) &&
           VerifyField<uint8_t>(verifier, VT_COMPLETED, 1) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyField<float>(verifier, VT_ETA, 4) &&
           verifier.EndTable();
  }
};

struct AutoBoneProcessStatusResponseBuilder {
  typedef AutoBoneProcessStatusResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_process_type(solarxr_protocol::rpc::AutoBoneProcessType process_type) {
    fbb_.AddElement<uint8_t>(AutoBoneProcessStatusResponse::VT_PROCESS_TYPE, static_cast<uint8_t>(process_type), 0);
  }
  void add_current(uint32_t current) {
    fbb_.AddElement<uint32_t>(AutoBoneProcessStatusResponse::VT_CURRENT, current, 0);
  }
  void add_total(uint32_t total) {
    fbb_.AddElement<uint32_t>(AutoBoneProcessStatusResponse::VT_TOTAL, total, 0);
  }
  void add_completed(bool completed) {
    fbb_.AddElement<uint8_t>(AutoBoneProcessStatusResponse::VT_COMPLETED, static_cast<uint8_t>(completed), 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(AutoBoneProcessStatusResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_eta(float eta) {
    fbb_.AddElement<float>(AutoBoneProcessStatusResponse::VT_ETA, eta, 0.0f);
  }
  explicit AutoBoneProcessStatusResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AutoBoneProcessStatusResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoBoneProcessStatusResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoBoneProcessStatusResponse> CreateAutoBoneProcessStatusResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::rpc::AutoBoneProcessType process_type = solarxr_protocol::rpc::AutoBoneProcessType::NONE,
    uint32_t current = 0,
    uint32_t total = 0,
    bool completed = false,
    bool success = false,
    float eta = 0.0f) {
  AutoBoneProcessStatusResponseBuilder builder_(_fbb);
  builder_.add_eta(eta);
  builder_.add_total(total);
  builder_.add_current(current);
  builder_.add_success(success);
  builder_.add_completed(completed);
  builder_.add_process_type(process_type);
  return builder_.Finish();
}

struct AutoBoneEpochResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoBoneEpochResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURRENT_EPOCH = 4,
    VT_TOTAL_EPOCHS = 6,
    VT_EPOCH_ERROR = 8,
    VT_ADJUSTED_SKELETON_PARTS = 10
  };
  uint32_t current_epoch() const {
    return GetField<uint32_t>(VT_CURRENT_EPOCH, 0);
  }
  uint32_t total_epochs() const {
    return GetField<uint32_t>(VT_TOTAL_EPOCHS, 0);
  }
  /// The current error value. This can be any positive number, where lower is better.
  float epoch_error() const {
    return GetField<float>(VT_EPOCH_ERROR, 0.0f);
  }
  /// A list of the current estimated body proportions.
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>> *adjusted_skeleton_parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>> *>(VT_ADJUSTED_SKELETON_PARTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CURRENT_EPOCH, 4) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_EPOCHS, 4) &&
           VerifyField<float>(verifier, VT_EPOCH_ERROR, 4) &&
           VerifyOffset(verifier, VT_ADJUSTED_SKELETON_PARTS) &&
           verifier.VerifyVector(adjusted_skeleton_parts()) &&
           verifier.VerifyVectorOfTables(adjusted_skeleton_parts()) &&
           verifier.EndTable();
  }
};

struct AutoBoneEpochResponseBuilder {
  typedef AutoBoneEpochResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_current_epoch(uint32_t current_epoch) {
    fbb_.AddElement<uint32_t>(AutoBoneEpochResponse::VT_CURRENT_EPOCH, current_epoch, 0);
  }
  void add_total_epochs(uint32_t total_epochs) {
    fbb_.AddElement<uint32_t>(AutoBoneEpochResponse::VT_TOTAL_EPOCHS, total_epochs, 0);
  }
  void add_epoch_error(float epoch_error) {
    fbb_.AddElement<float>(AutoBoneEpochResponse::VT_EPOCH_ERROR, epoch_error, 0.0f);
  }
  void add_adjusted_skeleton_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>>> adjusted_skeleton_parts) {
    fbb_.AddOffset(AutoBoneEpochResponse::VT_ADJUSTED_SKELETON_PARTS, adjusted_skeleton_parts);
  }
  explicit AutoBoneEpochResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AutoBoneEpochResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoBoneEpochResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoBoneEpochResponse> CreateAutoBoneEpochResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t current_epoch = 0,
    uint32_t total_epochs = 0,
    float epoch_error = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>>> adjusted_skeleton_parts = 0) {
  AutoBoneEpochResponseBuilder builder_(_fbb);
  builder_.add_adjusted_skeleton_parts(adjusted_skeleton_parts);
  builder_.add_epoch_error(epoch_error);
  builder_.add_total_epochs(total_epochs);
  builder_.add_current_epoch(current_epoch);
  return builder_.Finish();
}

inline flatbuffers::Offset<AutoBoneEpochResponse> CreateAutoBoneEpochResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t current_epoch = 0,
    uint32_t total_epochs = 0,
    float epoch_error = 0.0f,
    const std::vector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>> *adjusted_skeleton_parts = nullptr) {
  auto adjusted_skeleton_parts__ = adjusted_skeleton_parts ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::rpc::SkeletonPart>>(*adjusted_skeleton_parts) : 0;
  return solarxr_protocol::rpc::CreateAutoBoneEpochResponse(
      _fbb,
      current_epoch,
      total_epochs,
      epoch_error,
      adjusted_skeleton_parts__);
}

/// https://github.com/SlimeVR/SlimeVR-Server/blob/v0.8.3/server/src/main/java/dev/slimevr/config/AutoBoneConfig.kt
struct AutoBoneSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoBoneSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURSOR_INCREMENT = 4,
    VT_MIN_DATA_DISTANCE = 6,
    VT_MAX_DATA_DISTANCE = 8,
    VT_NUM_EPOCHS = 10,
    VT_PRINT_EVERY_NUM_EPOCHS = 12,
    VT_INITIAL_ADJUST_RATE = 14,
    VT_ADJUST_RATE_DECAY = 16,
    VT_SLIDE_ERROR_FACTOR = 18,
    VT_OFFSET_SLIDE_ERROR_FACTOR = 20,
    VT_FOOT_HEIGHT_OFFSET_ERROR_FACTOR = 22,
    VT_BODY_PROPORTION_ERROR_FACTOR = 24,
    VT_HEIGHT_ERROR_FACTOR = 26,
    VT_POSITION_ERROR_FACTOR = 28,
    VT_POSITION_OFFSET_ERROR_FACTOR = 30,
    VT_CALC_INIT_ERROR = 32,
    VT_TARGET_HMD_HEIGHT = 34,
    VT_TARGET_FULL_HEIGHT = 36,
    VT_RANDOMIZE_FRAME_ORDER = 38,
    VT_SCALE_EACH_STEP = 40,
    VT_SAMPLE_COUNT = 42,
    VT_SAMPLE_RATE_MS = 44,
    VT_SAVE_RECORDINGS = 46,
    VT_USE_SKELETON_HEIGHT = 48,
    VT_RAND_SEED = 50
  };
  flatbuffers::Optional<int32_t> cursor_increment() const {
    return GetOptional<int32_t, int32_t>(VT_CURSOR_INCREMENT);
  }
  flatbuffers::Optional<int32_t> min_data_distance() const {
    return GetOptional<int32_t, int32_t>(VT_MIN_DATA_DISTANCE);
  }
  flatbuffers::Optional<int32_t> max_data_distance() const {
    return GetOptional<int32_t, int32_t>(VT_MAX_DATA_DISTANCE);
  }
  flatbuffers::Optional<int32_t> num_epochs() const {
    return GetOptional<int32_t, int32_t>(VT_NUM_EPOCHS);
  }
  flatbuffers::Optional<int32_t> print_every_num_epochs() const {
    return GetOptional<int32_t, int32_t>(VT_PRINT_EVERY_NUM_EPOCHS);
  }
  flatbuffers::Optional<float> initial_adjust_rate() const {
    return GetOptional<float, float>(VT_INITIAL_ADJUST_RATE);
  }
  flatbuffers::Optional<float> adjust_rate_decay() const {
    return GetOptional<float, float>(VT_ADJUST_RATE_DECAY);
  }
  flatbuffers::Optional<float> slide_error_factor() const {
    return GetOptional<float, float>(VT_SLIDE_ERROR_FACTOR);
  }
  flatbuffers::Optional<float> offset_slide_error_factor() const {
    return GetOptional<float, float>(VT_OFFSET_SLIDE_ERROR_FACTOR);
  }
  flatbuffers::Optional<float> foot_height_offset_error_factor() const {
    return GetOptional<float, float>(VT_FOOT_HEIGHT_OFFSET_ERROR_FACTOR);
  }
  flatbuffers::Optional<float> body_proportion_error_factor() const {
    return GetOptional<float, float>(VT_BODY_PROPORTION_ERROR_FACTOR);
  }
  flatbuffers::Optional<float> height_error_factor() const {
    return GetOptional<float, float>(VT_HEIGHT_ERROR_FACTOR);
  }
  flatbuffers::Optional<float> position_error_factor() const {
    return GetOptional<float, float>(VT_POSITION_ERROR_FACTOR);
  }
  flatbuffers::Optional<float> position_offset_error_factor() const {
    return GetOptional<float, float>(VT_POSITION_OFFSET_ERROR_FACTOR);
  }
  flatbuffers::Optional<bool> calc_init_error() const {
    return GetOptional<uint8_t, bool>(VT_CALC_INIT_ERROR);
  }
  flatbuffers::Optional<float> target_hmd_height() const {
    return GetOptional<float, float>(VT_TARGET_HMD_HEIGHT);
  }
  flatbuffers::Optional<float> target_full_height() const {
    return GetOptional<float, float>(VT_TARGET_FULL_HEIGHT);
  }
  flatbuffers::Optional<bool> randomize_frame_order() const {
    return GetOptional<uint8_t, bool>(VT_RANDOMIZE_FRAME_ORDER);
  }
  flatbuffers::Optional<bool> scale_each_step() const {
    return GetOptional<uint8_t, bool>(VT_SCALE_EACH_STEP);
  }
  flatbuffers::Optional<int32_t> sample_count() const {
    return GetOptional<int32_t, int32_t>(VT_SAMPLE_COUNT);
  }
  flatbuffers::Optional<int64_t> sample_rate_ms() const {
    return GetOptional<int64_t, int64_t>(VT_SAMPLE_RATE_MS);
  }
  flatbuffers::Optional<bool> save_recordings() const {
    return GetOptional<uint8_t, bool>(VT_SAVE_RECORDINGS);
  }
  flatbuffers::Optional<bool> use_skeleton_height() const {
    return GetOptional<uint8_t, bool>(VT_USE_SKELETON_HEIGHT);
  }
  flatbuffers::Optional<int64_t> rand_seed() const {
    return GetOptional<int64_t, int64_t>(VT_RAND_SEED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CURSOR_INCREMENT, 4) &&
           VerifyField<int32_t>(verifier, VT_MIN_DATA_DISTANCE, 4) &&
           VerifyField<int32_t>(verifier, VT_MAX_DATA_DISTANCE, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_EPOCHS, 4) &&
           VerifyField<int32_t>(verifier, VT_PRINT_EVERY_NUM_EPOCHS, 4) &&
           VerifyField<float>(verifier, VT_INITIAL_ADJUST_RATE, 4) &&
           VerifyField<float>(verifier, VT_ADJUST_RATE_DECAY, 4) &&
           VerifyField<float>(verifier, VT_SLIDE_ERROR_FACTOR, 4) &&
           VerifyField<float>(verifier, VT_OFFSET_SLIDE_ERROR_FACTOR, 4) &&
           VerifyField<float>(verifier, VT_FOOT_HEIGHT_OFFSET_ERROR_FACTOR, 4) &&
           VerifyField<float>(verifier, VT_BODY_PROPORTION_ERROR_FACTOR, 4) &&
           VerifyField<float>(verifier, VT_HEIGHT_ERROR_FACTOR, 4) &&
           VerifyField<float>(verifier, VT_POSITION_ERROR_FACTOR, 4) &&
           VerifyField<float>(verifier, VT_POSITION_OFFSET_ERROR_FACTOR, 4) &&
           VerifyField<uint8_t>(verifier, VT_CALC_INIT_ERROR, 1) &&
           VerifyField<float>(verifier, VT_TARGET_HMD_HEIGHT, 4) &&
           VerifyField<float>(verifier, VT_TARGET_FULL_HEIGHT, 4) &&
           VerifyField<uint8_t>(verifier, VT_RANDOMIZE_FRAME_ORDER, 1) &&
           VerifyField<uint8_t>(verifier, VT_SCALE_EACH_STEP, 1) &&
           VerifyField<int32_t>(verifier, VT_SAMPLE_COUNT, 4) &&
           VerifyField<int64_t>(verifier, VT_SAMPLE_RATE_MS, 8) &&
           VerifyField<uint8_t>(verifier, VT_SAVE_RECORDINGS, 1) &&
           VerifyField<uint8_t>(verifier, VT_USE_SKELETON_HEIGHT, 1) &&
           VerifyField<int64_t>(verifier, VT_RAND_SEED, 8) &&
           verifier.EndTable();
  }
};

struct AutoBoneSettingsBuilder {
  typedef AutoBoneSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cursor_increment(int32_t cursor_increment) {
    fbb_.AddElement<int32_t>(AutoBoneSettings::VT_CURSOR_INCREMENT, cursor_increment);
  }
  void add_min_data_distance(int32_t min_data_distance) {
    fbb_.AddElement<int32_t>(AutoBoneSettings::VT_MIN_DATA_DISTANCE, min_data_distance);
  }
  void add_max_data_distance(int32_t max_data_distance) {
    fbb_.AddElement<int32_t>(AutoBoneSettings::VT_MAX_DATA_DISTANCE, max_data_distance);
  }
  void add_num_epochs(int32_t num_epochs) {
    fbb_.AddElement<int32_t>(AutoBoneSettings::VT_NUM_EPOCHS, num_epochs);
  }
  void add_print_every_num_epochs(int32_t print_every_num_epochs) {
    fbb_.AddElement<int32_t>(AutoBoneSettings::VT_PRINT_EVERY_NUM_EPOCHS, print_every_num_epochs);
  }
  void add_initial_adjust_rate(float initial_adjust_rate) {
    fbb_.AddElement<float>(AutoBoneSettings::VT_INITIAL_ADJUST_RATE, initial_adjust_rate);
  }
  void add_adjust_rate_decay(float adjust_rate_decay) {
    fbb_.AddElement<float>(AutoBoneSettings::VT_ADJUST_RATE_DECAY, adjust_rate_decay);
  }
  void add_slide_error_factor(float slide_error_factor) {
    fbb_.AddElement<float>(AutoBoneSettings::VT_SLIDE_ERROR_FACTOR, slide_error_factor);
  }
  void add_offset_slide_error_factor(float offset_slide_error_factor) {
    fbb_.AddElement<float>(AutoBoneSettings::VT_OFFSET_SLIDE_ERROR_FACTOR, offset_slide_error_factor);
  }
  void add_foot_height_offset_error_factor(float foot_height_offset_error_factor) {
    fbb_.AddElement<float>(AutoBoneSettings::VT_FOOT_HEIGHT_OFFSET_ERROR_FACTOR, foot_height_offset_error_factor);
  }
  void add_body_proportion_error_factor(float body_proportion_error_factor) {
    fbb_.AddElement<float>(AutoBoneSettings::VT_BODY_PROPORTION_ERROR_FACTOR, body_proportion_error_factor);
  }
  void add_height_error_factor(float height_error_factor) {
    fbb_.AddElement<float>(AutoBoneSettings::VT_HEIGHT_ERROR_FACTOR, height_error_factor);
  }
  void add_position_error_factor(float position_error_factor) {
    fbb_.AddElement<float>(AutoBoneSettings::VT_POSITION_ERROR_FACTOR, position_error_factor);
  }
  void add_position_offset_error_factor(float position_offset_error_factor) {
    fbb_.AddElement<float>(AutoBoneSettings::VT_POSITION_OFFSET_ERROR_FACTOR, position_offset_error_factor);
  }
  void add_calc_init_error(bool calc_init_error) {
    fbb_.AddElement<uint8_t>(AutoBoneSettings::VT_CALC_INIT_ERROR, static_cast<uint8_t>(calc_init_error));
  }
  void add_target_hmd_height(float target_hmd_height) {
    fbb_.AddElement<float>(AutoBoneSettings::VT_TARGET_HMD_HEIGHT, target_hmd_height);
  }
  void add_target_full_height(float target_full_height) {
    fbb_.AddElement<float>(AutoBoneSettings::VT_TARGET_FULL_HEIGHT, target_full_height);
  }
  void add_randomize_frame_order(bool randomize_frame_order) {
    fbb_.AddElement<uint8_t>(AutoBoneSettings::VT_RANDOMIZE_FRAME_ORDER, static_cast<uint8_t>(randomize_frame_order));
  }
  void add_scale_each_step(bool scale_each_step) {
    fbb_.AddElement<uint8_t>(AutoBoneSettings::VT_SCALE_EACH_STEP, static_cast<uint8_t>(scale_each_step));
  }
  void add_sample_count(int32_t sample_count) {
    fbb_.AddElement<int32_t>(AutoBoneSettings::VT_SAMPLE_COUNT, sample_count);
  }
  void add_sample_rate_ms(int64_t sample_rate_ms) {
    fbb_.AddElement<int64_t>(AutoBoneSettings::VT_SAMPLE_RATE_MS, sample_rate_ms);
  }
  void add_save_recordings(bool save_recordings) {
    fbb_.AddElement<uint8_t>(AutoBoneSettings::VT_SAVE_RECORDINGS, static_cast<uint8_t>(save_recordings));
  }
  void add_use_skeleton_height(bool use_skeleton_height) {
    fbb_.AddElement<uint8_t>(AutoBoneSettings::VT_USE_SKELETON_HEIGHT, static_cast<uint8_t>(use_skeleton_height));
  }
  void add_rand_seed(int64_t rand_seed) {
    fbb_.AddElement<int64_t>(AutoBoneSettings::VT_RAND_SEED, rand_seed);
  }
  explicit AutoBoneSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AutoBoneSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoBoneSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoBoneSettings> CreateAutoBoneSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<int32_t> cursor_increment = flatbuffers::nullopt,
    flatbuffers::Optional<int32_t> min_data_distance = flatbuffers::nullopt,
    flatbuffers::Optional<int32_t> max_data_distance = flatbuffers::nullopt,
    flatbuffers::Optional<int32_t> num_epochs = flatbuffers::nullopt,
    flatbuffers::Optional<int32_t> print_every_num_epochs = flatbuffers::nullopt,
    flatbuffers::Optional<float> initial_adjust_rate = flatbuffers::nullopt,
    flatbuffers::Optional<float> adjust_rate_decay = flatbuffers::nullopt,
    flatbuffers::Optional<float> slide_error_factor = flatbuffers::nullopt,
    flatbuffers::Optional<float> offset_slide_error_factor = flatbuffers::nullopt,
    flatbuffers::Optional<float> foot_height_offset_error_factor = flatbuffers::nullopt,
    flatbuffers::Optional<float> body_proportion_error_factor = flatbuffers::nullopt,
    flatbuffers::Optional<float> height_error_factor = flatbuffers::nullopt,
    flatbuffers::Optional<float> position_error_factor = flatbuffers::nullopt,
    flatbuffers::Optional<float> position_offset_error_factor = flatbuffers::nullopt,
    flatbuffers::Optional<bool> calc_init_error = flatbuffers::nullopt,
    flatbuffers::Optional<float> target_hmd_height = flatbuffers::nullopt,
    flatbuffers::Optional<float> target_full_height = flatbuffers::nullopt,
    flatbuffers::Optional<bool> randomize_frame_order = flatbuffers::nullopt,
    flatbuffers::Optional<bool> scale_each_step = flatbuffers::nullopt,
    flatbuffers::Optional<int32_t> sample_count = flatbuffers::nullopt,
    flatbuffers::Optional<int64_t> sample_rate_ms = flatbuffers::nullopt,
    flatbuffers::Optional<bool> save_recordings = flatbuffers::nullopt,
    flatbuffers::Optional<bool> use_skeleton_height = flatbuffers::nullopt,
    flatbuffers::Optional<int64_t> rand_seed = flatbuffers::nullopt) {
  AutoBoneSettingsBuilder builder_(_fbb);
  if(rand_seed) { builder_.add_rand_seed(*rand_seed); }
  if(sample_rate_ms) { builder_.add_sample_rate_ms(*sample_rate_ms); }
  if(sample_count) { builder_.add_sample_count(*sample_count); }
  if(target_full_height) { builder_.add_target_full_height(*target_full_height); }
  if(target_hmd_height) { builder_.add_target_hmd_height(*target_hmd_height); }
  if(position_offset_error_factor) { builder_.add_position_offset_error_factor(*position_offset_error_factor); }
  if(position_error_factor) { builder_.add_position_error_factor(*position_error_factor); }
  if(height_error_factor) { builder_.add_height_error_factor(*height_error_factor); }
  if(body_proportion_error_factor) { builder_.add_body_proportion_error_factor(*body_proportion_error_factor); }
  if(foot_height_offset_error_factor) { builder_.add_foot_height_offset_error_factor(*foot_height_offset_error_factor); }
  if(offset_slide_error_factor) { builder_.add_offset_slide_error_factor(*offset_slide_error_factor); }
  if(slide_error_factor) { builder_.add_slide_error_factor(*slide_error_factor); }
  if(adjust_rate_decay) { builder_.add_adjust_rate_decay(*adjust_rate_decay); }
  if(initial_adjust_rate) { builder_.add_initial_adjust_rate(*initial_adjust_rate); }
  if(print_every_num_epochs) { builder_.add_print_every_num_epochs(*print_every_num_epochs); }
  if(num_epochs) { builder_.add_num_epochs(*num_epochs); }
  if(max_data_distance) { builder_.add_max_data_distance(*max_data_distance); }
  if(min_data_distance) { builder_.add_min_data_distance(*min_data_distance); }
  if(cursor_increment) { builder_.add_cursor_increment(*cursor_increment); }
  if(use_skeleton_height) { builder_.add_use_skeleton_height(*use_skeleton_height); }
  if(save_recordings) { builder_.add_save_recordings(*save_recordings); }
  if(scale_each_step) { builder_.add_scale_each_step(*scale_each_step); }
  if(randomize_frame_order) { builder_.add_randomize_frame_order(*randomize_frame_order); }
  if(calc_init_error) { builder_.add_calc_init_error(*calc_init_error); }
  return builder_.Finish();
}

struct HeightRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeightRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HeightRequestBuilder {
  typedef HeightRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HeightRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HeightRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeightRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeightRequest> CreateHeightRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HeightRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Returns the current HMD height and returns an estimated full height (user height)
struct HeightResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeightResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HMD_HEIGHT = 4,
    VT_ESTIMATED_FULL_HEIGHT = 6
  };
  float hmd_height() const {
    return GetField<float>(VT_HMD_HEIGHT, 0.0f);
  }
  float estimated_full_height() const {
    return GetField<float>(VT_ESTIMATED_FULL_HEIGHT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_HMD_HEIGHT, 4) &&
           VerifyField<float>(verifier, VT_ESTIMATED_FULL_HEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct HeightResponseBuilder {
  typedef HeightResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hmd_height(float hmd_height) {
    fbb_.AddElement<float>(HeightResponse::VT_HMD_HEIGHT, hmd_height, 0.0f);
  }
  void add_estimated_full_height(float estimated_full_height) {
    fbb_.AddElement<float>(HeightResponse::VT_ESTIMATED_FULL_HEIGHT, estimated_full_height, 0.0f);
  }
  explicit HeightResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HeightResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeightResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeightResponse> CreateHeightResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    float hmd_height = 0.0f,
    float estimated_full_height = 0.0f) {
  HeightResponseBuilder builder_(_fbb);
  builder_.add_estimated_full_height(estimated_full_height);
  builder_.add_hmd_height(hmd_height);
  return builder_.Finish();
}

/// Applies the estimated proportions
struct AutoBoneApplyRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoBoneApplyRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AutoBoneApplyRequestBuilder {
  typedef AutoBoneApplyRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AutoBoneApplyRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AutoBoneApplyRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoBoneApplyRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoBoneApplyRequest> CreateAutoBoneApplyRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AutoBoneApplyRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Stops the current recording, using it as far as it has been recorded
struct AutoBoneStopRecordingRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoBoneStopRecordingRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AutoBoneStopRecordingRequestBuilder {
  typedef AutoBoneStopRecordingRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AutoBoneStopRecordingRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AutoBoneStopRecordingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoBoneStopRecordingRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoBoneStopRecordingRequest> CreateAutoBoneStopRecordingRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AutoBoneStopRecordingRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Cancels the current recording, aborting the process and discarding the data
struct AutoBoneCancelRecordingRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoBoneCancelRecordingRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AutoBoneCancelRecordingRequestBuilder {
  typedef AutoBoneCancelRecordingRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AutoBoneCancelRecordingRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AutoBoneCancelRecordingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoBoneCancelRecordingRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoBoneCancelRecordingRequest> CreateAutoBoneCancelRecordingRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AutoBoneCancelRecordingRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Requests the current state of `OverlayDisplayModeResponse`.
struct OverlayDisplayModeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OverlayDisplayModeRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OverlayDisplayModeRequestBuilder {
  typedef OverlayDisplayModeRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OverlayDisplayModeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OverlayDisplayModeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OverlayDisplayModeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OverlayDisplayModeRequest> CreateOverlayDisplayModeRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OverlayDisplayModeRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Changes the state of the overlay's display mode.
struct OverlayDisplayModeChangeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OverlayDisplayModeChangeRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_VISIBLE = 4,
    VT_IS_MIRRORED = 6
  };
  flatbuffers::Optional<bool> is_visible() const {
    return GetOptional<uint8_t, bool>(VT_IS_VISIBLE);
  }
  flatbuffers::Optional<bool> is_mirrored() const {
    return GetOptional<uint8_t, bool>(VT_IS_MIRRORED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_VISIBLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_MIRRORED, 1) &&
           verifier.EndTable();
  }
};

struct OverlayDisplayModeChangeRequestBuilder {
  typedef OverlayDisplayModeChangeRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_visible(bool is_visible) {
    fbb_.AddElement<uint8_t>(OverlayDisplayModeChangeRequest::VT_IS_VISIBLE, static_cast<uint8_t>(is_visible));
  }
  void add_is_mirrored(bool is_mirrored) {
    fbb_.AddElement<uint8_t>(OverlayDisplayModeChangeRequest::VT_IS_MIRRORED, static_cast<uint8_t>(is_mirrored));
  }
  explicit OverlayDisplayModeChangeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OverlayDisplayModeChangeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OverlayDisplayModeChangeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OverlayDisplayModeChangeRequest> CreateOverlayDisplayModeChangeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<bool> is_visible = flatbuffers::nullopt,
    flatbuffers::Optional<bool> is_mirrored = flatbuffers::nullopt) {
  OverlayDisplayModeChangeRequestBuilder builder_(_fbb);
  if(is_mirrored) { builder_.add_is_mirrored(*is_mirrored); }
  if(is_visible) { builder_.add_is_visible(*is_visible); }
  return builder_.Finish();
}

/// The current state of the overlay's display mode.
struct OverlayDisplayModeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OverlayDisplayModeResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_VISIBLE = 4,
    VT_IS_MIRRORED = 6
  };
  bool is_visible() const {
    return GetField<uint8_t>(VT_IS_VISIBLE, 0) != 0;
  }
  bool is_mirrored() const {
    return GetField<uint8_t>(VT_IS_MIRRORED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_VISIBLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_MIRRORED, 1) &&
           verifier.EndTable();
  }
};

struct OverlayDisplayModeResponseBuilder {
  typedef OverlayDisplayModeResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_visible(bool is_visible) {
    fbb_.AddElement<uint8_t>(OverlayDisplayModeResponse::VT_IS_VISIBLE, static_cast<uint8_t>(is_visible), 0);
  }
  void add_is_mirrored(bool is_mirrored) {
    fbb_.AddElement<uint8_t>(OverlayDisplayModeResponse::VT_IS_MIRRORED, static_cast<uint8_t>(is_mirrored), 0);
  }
  explicit OverlayDisplayModeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OverlayDisplayModeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OverlayDisplayModeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<OverlayDisplayModeResponse> CreateOverlayDisplayModeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_visible = false,
    bool is_mirrored = false) {
  OverlayDisplayModeResponseBuilder builder_(_fbb);
  builder_.add_is_mirrored(is_mirrored);
  builder_.add_is_visible(is_visible);
  return builder_.Finish();
}

/// Allows to ask generic infos about the server,
/// like the local ip address, the version of the server, the java version,
/// the current working dir and other informations we might want to show in the gui
/// for information/debug purposes
struct ServerInfosRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerInfosRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ServerInfosRequestBuilder {
  typedef ServerInfosRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ServerInfosRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ServerInfosRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerInfosRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerInfosRequest> CreateServerInfosRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ServerInfosRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Holds the Server informations, this is a basic table holding various informations about the currently running server
/// like its local ip address (usefull for standalone users so they can specify the ip of the server more easilly) and any more
/// infos we might want to add in the future. (like java version, working dir, server version ....)
/// This only holds the local ip for now. But there will be other informations added as we chose to display them on the gui for instance
struct ServerInfosResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerInfosResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCALIP = 4
  };
  const flatbuffers::String *localIp() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCALIP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOCALIP) &&
           verifier.VerifyString(localIp()) &&
           verifier.EndTable();
  }
};

struct ServerInfosResponseBuilder {
  typedef ServerInfosResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_localIp(flatbuffers::Offset<flatbuffers::String> localIp) {
    fbb_.AddOffset(ServerInfosResponse::VT_LOCALIP, localIp);
  }
  explicit ServerInfosResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ServerInfosResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerInfosResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerInfosResponse> CreateServerInfosResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> localIp = 0) {
  ServerInfosResponseBuilder builder_(_fbb);
  builder_.add_localIp(localIp);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerInfosResponse> CreateServerInfosResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *localIp = nullptr) {
  auto localIp__ = localIp ? _fbb.CreateString(localIp) : 0;
  return solarxr_protocol::rpc::CreateServerInfosResponse(
      _fbb,
      localIp__);
}

/// Makes a temporary change to legtweaks. This is not saved to disk, and can be
/// cleared with `LegTweaksTmpClear`
struct LegTweaksTmpChange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LegTweaksTmpChangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLOOR_CLIP = 4,
    VT_SKATING_CORRECTION = 6,
    VT_TOE_SNAP = 8,
    VT_FOOT_PLANT = 10
  };
  flatbuffers::Optional<bool> floor_clip() const {
    return GetOptional<uint8_t, bool>(VT_FLOOR_CLIP);
  }
  flatbuffers::Optional<bool> skating_correction() const {
    return GetOptional<uint8_t, bool>(VT_SKATING_CORRECTION);
  }
  flatbuffers::Optional<bool> toe_snap() const {
    return GetOptional<uint8_t, bool>(VT_TOE_SNAP);
  }
  flatbuffers::Optional<bool> foot_plant() const {
    return GetOptional<uint8_t, bool>(VT_FOOT_PLANT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLOOR_CLIP, 1) &&
           VerifyField<uint8_t>(verifier, VT_SKATING_CORRECTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_TOE_SNAP, 1) &&
           VerifyField<uint8_t>(verifier, VT_FOOT_PLANT, 1) &&
           verifier.EndTable();
  }
};

struct LegTweaksTmpChangeBuilder {
  typedef LegTweaksTmpChange Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_floor_clip(bool floor_clip) {
    fbb_.AddElement<uint8_t>(LegTweaksTmpChange::VT_FLOOR_CLIP, static_cast<uint8_t>(floor_clip));
  }
  void add_skating_correction(bool skating_correction) {
    fbb_.AddElement<uint8_t>(LegTweaksTmpChange::VT_SKATING_CORRECTION, static_cast<uint8_t>(skating_correction));
  }
  void add_toe_snap(bool toe_snap) {
    fbb_.AddElement<uint8_t>(LegTweaksTmpChange::VT_TOE_SNAP, static_cast<uint8_t>(toe_snap));
  }
  void add_foot_plant(bool foot_plant) {
    fbb_.AddElement<uint8_t>(LegTweaksTmpChange::VT_FOOT_PLANT, static_cast<uint8_t>(foot_plant));
  }
  explicit LegTweaksTmpChangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LegTweaksTmpChange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LegTweaksTmpChange>(end);
    return o;
  }
};

inline flatbuffers::Offset<LegTweaksTmpChange> CreateLegTweaksTmpChange(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<bool> floor_clip = flatbuffers::nullopt,
    flatbuffers::Optional<bool> skating_correction = flatbuffers::nullopt,
    flatbuffers::Optional<bool> toe_snap = flatbuffers::nullopt,
    flatbuffers::Optional<bool> foot_plant = flatbuffers::nullopt) {
  LegTweaksTmpChangeBuilder builder_(_fbb);
  if(foot_plant) { builder_.add_foot_plant(*foot_plant); }
  if(toe_snap) { builder_.add_toe_snap(*toe_snap); }
  if(skating_correction) { builder_.add_skating_correction(*skating_correction); }
  if(floor_clip) { builder_.add_floor_clip(*floor_clip); }
  return builder_.Finish();
}

/// Clears the legtweaks temprorary state back to what the config has.
/// Setting a field to `true` will reset that field.
struct LegTweaksTmpClear FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LegTweaksTmpClearBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLOOR_CLIP = 4,
    VT_SKATING_CORRECTION = 6,
    VT_TOE_SNAP = 8,
    VT_FOOT_PLANT = 10
  };
  bool floor_clip() const {
    return GetField<uint8_t>(VT_FLOOR_CLIP, 0) != 0;
  }
  bool skating_correction() const {
    return GetField<uint8_t>(VT_SKATING_CORRECTION, 0) != 0;
  }
  bool toe_snap() const {
    return GetField<uint8_t>(VT_TOE_SNAP, 0) != 0;
  }
  bool foot_plant() const {
    return GetField<uint8_t>(VT_FOOT_PLANT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLOOR_CLIP, 1) &&
           VerifyField<uint8_t>(verifier, VT_SKATING_CORRECTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_TOE_SNAP, 1) &&
           VerifyField<uint8_t>(verifier, VT_FOOT_PLANT, 1) &&
           verifier.EndTable();
  }
};

struct LegTweaksTmpClearBuilder {
  typedef LegTweaksTmpClear Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_floor_clip(bool floor_clip) {
    fbb_.AddElement<uint8_t>(LegTweaksTmpClear::VT_FLOOR_CLIP, static_cast<uint8_t>(floor_clip), 0);
  }
  void add_skating_correction(bool skating_correction) {
    fbb_.AddElement<uint8_t>(LegTweaksTmpClear::VT_SKATING_CORRECTION, static_cast<uint8_t>(skating_correction), 0);
  }
  void add_toe_snap(bool toe_snap) {
    fbb_.AddElement<uint8_t>(LegTweaksTmpClear::VT_TOE_SNAP, static_cast<uint8_t>(toe_snap), 0);
  }
  void add_foot_plant(bool foot_plant) {
    fbb_.AddElement<uint8_t>(LegTweaksTmpClear::VT_FOOT_PLANT, static_cast<uint8_t>(foot_plant), 0);
  }
  explicit LegTweaksTmpClearBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LegTweaksTmpClear> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LegTweaksTmpClear>(end);
    return o;
  }
};

inline flatbuffers::Offset<LegTweaksTmpClear> CreateLegTweaksTmpClear(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool floor_clip = false,
    bool skating_correction = false,
    bool toe_snap = false,
    bool foot_plant = false) {
  LegTweaksTmpClearBuilder builder_(_fbb);
  builder_.add_foot_plant(foot_plant);
  builder_.add_toe_snap(toe_snap);
  builder_.add_skating_correction(skating_correction);
  builder_.add_floor_clip(floor_clip);
  return builder_.Finish();
}

/// Tracker requires full reset
struct StatusTrackerReset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusTrackerResetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACKER_ID = 4
  };
  const solarxr_protocol::datatypes::TrackerId *tracker_id() const {
    return GetPointer<const solarxr_protocol::datatypes::TrackerId *>(VT_TRACKER_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACKER_ID) &&
           verifier.VerifyTable(tracker_id()) &&
           verifier.EndTable();
  }
};

struct StatusTrackerResetBuilder {
  typedef StatusTrackerReset Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tracker_id(flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id) {
    fbb_.AddOffset(StatusTrackerReset::VT_TRACKER_ID, tracker_id);
  }
  explicit StatusTrackerResetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatusTrackerReset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusTrackerReset>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusTrackerReset> CreateStatusTrackerReset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id = 0) {
  StatusTrackerResetBuilder builder_(_fbb);
  builder_.add_tracker_id(tracker_id);
  return builder_.Finish();
}

/// Tracker has error state
struct StatusTrackerError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusTrackerErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACKER_ID = 4
  };
  const solarxr_protocol::datatypes::TrackerId *tracker_id() const {
    return GetPointer<const solarxr_protocol::datatypes::TrackerId *>(VT_TRACKER_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACKER_ID) &&
           verifier.VerifyTable(tracker_id()) &&
           verifier.EndTable();
  }
};

struct StatusTrackerErrorBuilder {
  typedef StatusTrackerError Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tracker_id(flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id) {
    fbb_.AddOffset(StatusTrackerError::VT_TRACKER_ID, tracker_id);
  }
  explicit StatusTrackerErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatusTrackerError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusTrackerError>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusTrackerError> CreateStatusTrackerError(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id = 0) {
  StatusTrackerErrorBuilder builder_(_fbb);
  builder_.add_tracker_id(tracker_id);
  return builder_.Finish();
}

/// SteamVR bridge is disconnected
struct StatusSteamVRDisconnected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusSteamVRDisconnectedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BRIDGE_SETTINGS_NAME = 4
  };
  /// Name of bridge in the server's config
  const flatbuffers::String *bridge_settings_name() const {
    return GetPointer<const flatbuffers::String *>(VT_BRIDGE_SETTINGS_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BRIDGE_SETTINGS_NAME) &&
           verifier.VerifyString(bridge_settings_name()) &&
           verifier.EndTable();
  }
};

struct StatusSteamVRDisconnectedBuilder {
  typedef StatusSteamVRDisconnected Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bridge_settings_name(flatbuffers::Offset<flatbuffers::String> bridge_settings_name) {
    fbb_.AddOffset(StatusSteamVRDisconnected::VT_BRIDGE_SETTINGS_NAME, bridge_settings_name);
  }
  explicit StatusSteamVRDisconnectedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatusSteamVRDisconnected> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusSteamVRDisconnected>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusSteamVRDisconnected> CreateStatusSteamVRDisconnected(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> bridge_settings_name = 0) {
  StatusSteamVRDisconnectedBuilder builder_(_fbb);
  builder_.add_bridge_settings_name(bridge_settings_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<StatusSteamVRDisconnected> CreateStatusSteamVRDisconnectedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *bridge_settings_name = nullptr) {
  auto bridge_settings_name__ = bridge_settings_name ? _fbb.CreateString(bridge_settings_name) : 0;
  return solarxr_protocol::rpc::CreateStatusSteamVRDisconnected(
      _fbb,
      bridge_settings_name__);
}

/// Request current statuses that we have
struct StatusSystemRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusSystemRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct StatusSystemRequestBuilder {
  typedef StatusSystemRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit StatusSystemRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatusSystemRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusSystemRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusSystemRequest> CreateStatusSystemRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StatusSystemRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Response containing all current valid statuses
struct StatusSystemResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusSystemResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURRENT_STATUSES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::StatusMessage>> *current_statuses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::StatusMessage>> *>(VT_CURRENT_STATUSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CURRENT_STATUSES) &&
           verifier.VerifyVector(current_statuses()) &&
           verifier.VerifyVectorOfTables(current_statuses()) &&
           verifier.EndTable();
  }
};

struct StatusSystemResponseBuilder {
  typedef StatusSystemResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_current_statuses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::StatusMessage>>> current_statuses) {
    fbb_.AddOffset(StatusSystemResponse::VT_CURRENT_STATUSES, current_statuses);
  }
  explicit StatusSystemResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatusSystemResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusSystemResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusSystemResponse> CreateStatusSystemResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::StatusMessage>>> current_statuses = 0) {
  StatusSystemResponseBuilder builder_(_fbb);
  builder_.add_current_statuses(current_statuses);
  return builder_.Finish();
}

inline flatbuffers::Offset<StatusSystemResponse> CreateStatusSystemResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::rpc::StatusMessage>> *current_statuses = nullptr) {
  auto current_statuses__ = current_statuses ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::rpc::StatusMessage>>(*current_statuses) : 0;
  return solarxr_protocol::rpc::CreateStatusSystemResponse(
      _fbb,
      current_statuses__);
}

/// When a new status appears, it's sent alone
struct StatusSystemUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusSystemUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEW_STATUS = 4
  };
  const solarxr_protocol::rpc::StatusMessage *new_status() const {
    return GetPointer<const solarxr_protocol::rpc::StatusMessage *>(VT_NEW_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NEW_STATUS) &&
           verifier.VerifyTable(new_status()) &&
           verifier.EndTable();
  }
};

struct StatusSystemUpdateBuilder {
  typedef StatusSystemUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_new_status(flatbuffers::Offset<solarxr_protocol::rpc::StatusMessage> new_status) {
    fbb_.AddOffset(StatusSystemUpdate::VT_NEW_STATUS, new_status);
  }
  explicit StatusSystemUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatusSystemUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusSystemUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusSystemUpdate> CreateStatusSystemUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::rpc::StatusMessage> new_status = 0) {
  StatusSystemUpdateBuilder builder_(_fbb);
  builder_.add_new_status(new_status);
  return builder_.Finish();
}

/// When an status is fixed and it's removed, it's ID is sent
struct StatusSystemFixed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusSystemFixedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIXED_STATUS_ID = 4
  };
  uint32_t fixed_status_id() const {
    return GetField<uint32_t>(VT_FIXED_STATUS_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FIXED_STATUS_ID, 4) &&
           verifier.EndTable();
  }
};

struct StatusSystemFixedBuilder {
  typedef StatusSystemFixed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fixed_status_id(uint32_t fixed_status_id) {
    fbb_.AddElement<uint32_t>(StatusSystemFixed::VT_FIXED_STATUS_ID, fixed_status_id, 0);
  }
  explicit StatusSystemFixedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatusSystemFixed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusSystemFixed>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusSystemFixed> CreateStatusSystemFixed(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t fixed_status_id = 0) {
  StatusSystemFixedBuilder builder_(_fbb);
  builder_.add_fixed_status_id(fixed_status_id);
  return builder_.Finish();
}

/// An status is some kind of warning sent by the server, it's mainly made for
/// showing problems with the server and need attention from the user.
struct StatusMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PRIORITIZED = 6,
    VT_DATA_TYPE = 8,
    VT_DATA = 10
  };
  /// The status ID
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  /// This should be prioritized in the GUI in some way if true
  bool prioritized() const {
    return GetField<uint8_t>(VT_PRIORITIZED, 0) != 0;
  }
  solarxr_protocol::rpc::StatusData data_type() const {
    return static_cast<solarxr_protocol::rpc::StatusData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const solarxr_protocol::rpc::StatusTrackerReset *data_as_StatusTrackerReset() const {
    return data_type() == solarxr_protocol::rpc::StatusData::StatusTrackerReset ? static_cast<const solarxr_protocol::rpc::StatusTrackerReset *>(data()) : nullptr;
  }
  const solarxr_protocol::rpc::StatusTrackerError *data_as_StatusTrackerError() const {
    return data_type() == solarxr_protocol::rpc::StatusData::StatusTrackerError ? static_cast<const solarxr_protocol::rpc::StatusTrackerError *>(data()) : nullptr;
  }
  const solarxr_protocol::rpc::StatusSteamVRDisconnected *data_as_StatusSteamVRDisconnected() const {
    return data_type() == solarxr_protocol::rpc::StatusData::StatusSteamVRDisconnected ? static_cast<const solarxr_protocol::rpc::StatusSteamVRDisconnected *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_PRIORITIZED, 1) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyStatusData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::rpc::StatusTrackerReset *StatusMessage::data_as<solarxr_protocol::rpc::StatusTrackerReset>() const {
  return data_as_StatusTrackerReset();
}

template<> inline const solarxr_protocol::rpc::StatusTrackerError *StatusMessage::data_as<solarxr_protocol::rpc::StatusTrackerError>() const {
  return data_as_StatusTrackerError();
}

template<> inline const solarxr_protocol::rpc::StatusSteamVRDisconnected *StatusMessage::data_as<solarxr_protocol::rpc::StatusSteamVRDisconnected>() const {
  return data_as_StatusSteamVRDisconnected();
}

struct StatusMessageBuilder {
  typedef StatusMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(StatusMessage::VT_ID, id, 0);
  }
  void add_prioritized(bool prioritized) {
    fbb_.AddElement<uint8_t>(StatusMessage::VT_PRIORITIZED, static_cast<uint8_t>(prioritized), 0);
  }
  void add_data_type(solarxr_protocol::rpc::StatusData data_type) {
    fbb_.AddElement<uint8_t>(StatusMessage::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(StatusMessage::VT_DATA, data);
  }
  explicit StatusMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatusMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusMessage> CreateStatusMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    bool prioritized = false,
    solarxr_protocol::rpc::StatusData data_type = solarxr_protocol::rpc::StatusData::NONE,
    flatbuffers::Offset<void> data = 0) {
  StatusMessageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_id(id);
  builder_.add_data_type(data_type);
  builder_.add_prioritized(prioritized);
  return builder_.Finish();
}

struct SetPauseTrackingRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetPauseTrackingRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAUSETRACKING = 4
  };
  /// Pauses skeleton tracking if true, resumes skeleton tracking if false.
  bool pauseTracking() const {
    return GetField<uint8_t>(VT_PAUSETRACKING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAUSETRACKING, 1) &&
           verifier.EndTable();
  }
};

struct SetPauseTrackingRequestBuilder {
  typedef SetPauseTrackingRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pauseTracking(bool pauseTracking) {
    fbb_.AddElement<uint8_t>(SetPauseTrackingRequest::VT_PAUSETRACKING, static_cast<uint8_t>(pauseTracking), 0);
  }
  explicit SetPauseTrackingRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SetPauseTrackingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetPauseTrackingRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetPauseTrackingRequest> CreateSetPauseTrackingRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool pauseTracking = false) {
  SetPauseTrackingRequestBuilder builder_(_fbb);
  builder_.add_pauseTracking(pauseTracking);
  return builder_.Finish();
}

/// Clears mounting reset data, defaulting to the manually set mounting orientations
struct ClearMountingResetRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClearMountingResetRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ClearMountingResetRequestBuilder {
  typedef ClearMountingResetRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ClearMountingResetRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClearMountingResetRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClearMountingResetRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClearMountingResetRequest> CreateClearMountingResetRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ClearMountingResetRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

}  // namespace rpc

namespace pub_sub {

/// A `TopicId` identifies an application-specific category of data. Because it
/// is application-specific, it is up to the application within the specified
/// organization to define its semantics/meaning.
///
/// For example, "bob" may have an "overlay" app with a "settings" topic for controlling
/// the overlay visibility and other settings, as well as a "video feed" topic for
/// allowing other applications to display video data in a wrist mounted window in VR.
struct TopicId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopicIdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORGANIZATION = 4,
    VT_APP_NAME = 6,
    VT_TOPIC = 8
  };
  /// The organization/developer that defines the meaning of this feature. Avoids name
  /// clashes. Should be something unique - same idea as java package identifier.
  const flatbuffers::String *organization() const {
    return GetPointer<const flatbuffers::String *>(VT_ORGANIZATION);
  }
  /// The name of the application/device. Should be unique within the organization.
  const flatbuffers::String *app_name() const {
    return GetPointer<const flatbuffers::String *>(VT_APP_NAME);
  }
  /// The name of the topic. Should be unique within the application.
  const flatbuffers::String *topic() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPIC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORGANIZATION) &&
           verifier.VerifyString(organization()) &&
           VerifyOffset(verifier, VT_APP_NAME) &&
           verifier.VerifyString(app_name()) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           verifier.VerifyString(topic()) &&
           verifier.EndTable();
  }
};

struct TopicIdBuilder {
  typedef TopicId Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_organization(flatbuffers::Offset<flatbuffers::String> organization) {
    fbb_.AddOffset(TopicId::VT_ORGANIZATION, organization);
  }
  void add_app_name(flatbuffers::Offset<flatbuffers::String> app_name) {
    fbb_.AddOffset(TopicId::VT_APP_NAME, app_name);
  }
  void add_topic(flatbuffers::Offset<flatbuffers::String> topic) {
    fbb_.AddOffset(TopicId::VT_TOPIC, topic);
  }
  explicit TopicIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopicId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicId>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicId> CreateTopicId(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> organization = 0,
    flatbuffers::Offset<flatbuffers::String> app_name = 0,
    flatbuffers::Offset<flatbuffers::String> topic = 0) {
  TopicIdBuilder builder_(_fbb);
  builder_.add_topic(topic);
  builder_.add_app_name(app_name);
  builder_.add_organization(organization);
  return builder_.Finish();
}

inline flatbuffers::Offset<TopicId> CreateTopicIdDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *organization = nullptr,
    const char *app_name = nullptr,
    const char *topic = nullptr) {
  auto organization__ = organization ? _fbb.CreateString(organization) : 0;
  auto app_name__ = app_name ? _fbb.CreateString(app_name) : 0;
  auto topic__ = topic ? _fbb.CreateString(topic) : 0;
  return solarxr_protocol::pub_sub::CreateTopicId(
      _fbb,
      organization__,
      app_name__,
      topic__);
}

/// A handle for the topic, allows referencing a topic without sending a huge
/// `TopicId`.
struct TopicHandle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopicHandleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID, 2) &&
           verifier.EndTable();
  }
};

struct TopicHandleBuilder {
  typedef TopicHandle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(TopicHandle::VT_ID, id, 0);
  }
  explicit TopicHandleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopicHandle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicHandle>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicHandle> CreateTopicHandle(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0) {
  TopicHandleBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

/// Response for `TopicHandleRequest` or `SubscriptionRequest`.
struct TopicMapping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopicMappingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_HANDLE = 6
  };
  const solarxr_protocol::pub_sub::TopicId *id() const {
    return GetPointer<const solarxr_protocol::pub_sub::TopicId *>(VT_ID);
  }
  const solarxr_protocol::pub_sub::TopicHandle *handle() const {
    return GetPointer<const solarxr_protocol::pub_sub::TopicHandle *>(VT_HANDLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_HANDLE) &&
           verifier.VerifyTable(handle()) &&
           verifier.EndTable();
  }
};

struct TopicMappingBuilder {
  typedef TopicMapping Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<solarxr_protocol::pub_sub::TopicId> id) {
    fbb_.AddOffset(TopicMapping::VT_ID, id);
  }
  void add_handle(flatbuffers::Offset<solarxr_protocol::pub_sub::TopicHandle> handle) {
    fbb_.AddOffset(TopicMapping::VT_HANDLE, handle);
  }
  explicit TopicMappingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopicMapping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicMapping>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicMapping> CreateTopicMapping(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::pub_sub::TopicId> id = 0,
    flatbuffers::Offset<solarxr_protocol::pub_sub::TopicHandle> handle = 0) {
  TopicMappingBuilder builder_(_fbb);
  builder_.add_handle(handle);
  builder_.add_id(id);
  return builder_.Finish();
}

/// Request to get the `FeatureHandle` from a `FeatureId`. This is useful for reducing
/// bandwidth, since `FeatureId` can be large.
struct TopicHandleRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopicHandleRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const solarxr_protocol::pub_sub::TopicId *id() const {
    return GetPointer<const solarxr_protocol::pub_sub::TopicId *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct TopicHandleRequestBuilder {
  typedef TopicHandleRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<solarxr_protocol::pub_sub::TopicId> id) {
    fbb_.AddOffset(TopicHandleRequest::VT_ID, id);
  }
  explicit TopicHandleRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopicHandleRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicHandleRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicHandleRequest> CreateTopicHandleRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::pub_sub::TopicId> id = 0) {
  TopicHandleRequestBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

/// Requests a subscription to `topic`. Replies with a `TopicMapping`.
struct SubscriptionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubscriptionRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_TYPE = 4,
    VT_TOPIC = 6
  };
  solarxr_protocol::pub_sub::Topic topic_type() const {
    return static_cast<solarxr_protocol::pub_sub::Topic>(GetField<uint8_t>(VT_TOPIC_TYPE, 0));
  }
  const void *topic() const {
    return GetPointer<const void *>(VT_TOPIC);
  }
  template<typename T> const T *topic_as() const;
  const solarxr_protocol::pub_sub::TopicHandle *topic_as_TopicHandle() const {
    return topic_type() == solarxr_protocol::pub_sub::Topic::TopicHandle ? static_cast<const solarxr_protocol::pub_sub::TopicHandle *>(topic()) : nullptr;
  }
  const solarxr_protocol::pub_sub::TopicId *topic_as_TopicId() const {
    return topic_type() == solarxr_protocol::pub_sub::Topic::TopicId ? static_cast<const solarxr_protocol::pub_sub::TopicId *>(topic()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TOPIC_TYPE, 1) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           VerifyTopic(verifier, topic(), topic_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::pub_sub::TopicHandle *SubscriptionRequest::topic_as<solarxr_protocol::pub_sub::TopicHandle>() const {
  return topic_as_TopicHandle();
}

template<> inline const solarxr_protocol::pub_sub::TopicId *SubscriptionRequest::topic_as<solarxr_protocol::pub_sub::TopicId>() const {
  return topic_as_TopicId();
}

struct SubscriptionRequestBuilder {
  typedef SubscriptionRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_type(solarxr_protocol::pub_sub::Topic topic_type) {
    fbb_.AddElement<uint8_t>(SubscriptionRequest::VT_TOPIC_TYPE, static_cast<uint8_t>(topic_type), 0);
  }
  void add_topic(flatbuffers::Offset<void> topic) {
    fbb_.AddOffset(SubscriptionRequest::VT_TOPIC, topic);
  }
  explicit SubscriptionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubscriptionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubscriptionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubscriptionRequest> CreateSubscriptionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::pub_sub::Topic topic_type = solarxr_protocol::pub_sub::Topic::NONE,
    flatbuffers::Offset<void> topic = 0) {
  SubscriptionRequestBuilder builder_(_fbb);
  builder_.add_topic(topic);
  builder_.add_topic_type(topic_type);
  return builder_.Finish();
}

struct PubSubHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PubSubHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_U_TYPE = 4,
    VT_U = 6
  };
  solarxr_protocol::pub_sub::PubSubUnion u_type() const {
    return static_cast<solarxr_protocol::pub_sub::PubSubUnion>(GetField<uint8_t>(VT_U_TYPE, 0));
  }
  const void *u() const {
    return GetPointer<const void *>(VT_U);
  }
  template<typename T> const T *u_as() const;
  const solarxr_protocol::pub_sub::Message *u_as_Message() const {
    return u_type() == solarxr_protocol::pub_sub::PubSubUnion::Message ? static_cast<const solarxr_protocol::pub_sub::Message *>(u()) : nullptr;
  }
  const solarxr_protocol::pub_sub::SubscriptionRequest *u_as_SubscriptionRequest() const {
    return u_type() == solarxr_protocol::pub_sub::PubSubUnion::SubscriptionRequest ? static_cast<const solarxr_protocol::pub_sub::SubscriptionRequest *>(u()) : nullptr;
  }
  const solarxr_protocol::pub_sub::TopicHandleRequest *u_as_TopicHandleRequest() const {
    return u_type() == solarxr_protocol::pub_sub::PubSubUnion::TopicHandleRequest ? static_cast<const solarxr_protocol::pub_sub::TopicHandleRequest *>(u()) : nullptr;
  }
  const solarxr_protocol::pub_sub::TopicMapping *u_as_TopicMapping() const {
    return u_type() == solarxr_protocol::pub_sub::PubSubUnion::TopicMapping ? static_cast<const solarxr_protocol::pub_sub::TopicMapping *>(u()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_U_TYPE, 1) &&
           VerifyOffset(verifier, VT_U) &&
           VerifyPubSubUnion(verifier, u(), u_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::pub_sub::Message *PubSubHeader::u_as<solarxr_protocol::pub_sub::Message>() const {
  return u_as_Message();
}

template<> inline const solarxr_protocol::pub_sub::SubscriptionRequest *PubSubHeader::u_as<solarxr_protocol::pub_sub::SubscriptionRequest>() const {
  return u_as_SubscriptionRequest();
}

template<> inline const solarxr_protocol::pub_sub::TopicHandleRequest *PubSubHeader::u_as<solarxr_protocol::pub_sub::TopicHandleRequest>() const {
  return u_as_TopicHandleRequest();
}

template<> inline const solarxr_protocol::pub_sub::TopicMapping *PubSubHeader::u_as<solarxr_protocol::pub_sub::TopicMapping>() const {
  return u_as_TopicMapping();
}

struct PubSubHeaderBuilder {
  typedef PubSubHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_u_type(solarxr_protocol::pub_sub::PubSubUnion u_type) {
    fbb_.AddElement<uint8_t>(PubSubHeader::VT_U_TYPE, static_cast<uint8_t>(u_type), 0);
  }
  void add_u(flatbuffers::Offset<void> u) {
    fbb_.AddOffset(PubSubHeader::VT_U, u);
  }
  explicit PubSubHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PubSubHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PubSubHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<PubSubHeader> CreatePubSubHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::pub_sub::PubSubUnion u_type = solarxr_protocol::pub_sub::PubSubUnion::NONE,
    flatbuffers::Offset<void> u = 0) {
  PubSubHeaderBuilder builder_(_fbb);
  builder_.add_u(u);
  builder_.add_u_type(u_type);
  return builder_.Finish();
}

/// Data that is sent from publishers to subscribers
struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_TYPE = 4,
    VT_TOPIC = 6,
    VT_PAYLOAD_TYPE = 8,
    VT_PAYLOAD = 10
  };
  solarxr_protocol::pub_sub::Topic topic_type() const {
    return static_cast<solarxr_protocol::pub_sub::Topic>(GetField<uint8_t>(VT_TOPIC_TYPE, 0));
  }
  const void *topic() const {
    return GetPointer<const void *>(VT_TOPIC);
  }
  template<typename T> const T *topic_as() const;
  const solarxr_protocol::pub_sub::TopicHandle *topic_as_TopicHandle() const {
    return topic_type() == solarxr_protocol::pub_sub::Topic::TopicHandle ? static_cast<const solarxr_protocol::pub_sub::TopicHandle *>(topic()) : nullptr;
  }
  const solarxr_protocol::pub_sub::TopicId *topic_as_TopicId() const {
    return topic_type() == solarxr_protocol::pub_sub::Topic::TopicId ? static_cast<const solarxr_protocol::pub_sub::TopicId *>(topic()) : nullptr;
  }
  solarxr_protocol::pub_sub::Payload payload_type() const {
    return static_cast<solarxr_protocol::pub_sub::Payload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const solarxr_protocol::datatypes::StringTable *payload_as_solarxr_protocol_datatypes_StringTable() const {
    return payload_type() == solarxr_protocol::pub_sub::Payload::solarxr_protocol_datatypes_StringTable ? static_cast<const solarxr_protocol::datatypes::StringTable *>(payload()) : nullptr;
  }
  const solarxr_protocol::datatypes::Bytes *payload_as_solarxr_protocol_datatypes_Bytes() const {
    return payload_type() == solarxr_protocol::pub_sub::Payload::solarxr_protocol_datatypes_Bytes ? static_cast<const solarxr_protocol::datatypes::Bytes *>(payload()) : nullptr;
  }
  const solarxr_protocol::pub_sub::KeyValues *payload_as_KeyValues() const {
    return payload_type() == solarxr_protocol::pub_sub::Payload::KeyValues ? static_cast<const solarxr_protocol::pub_sub::KeyValues *>(payload()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TOPIC_TYPE, 1) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           VerifyTopic(verifier, topic(), topic_type()) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyPayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::pub_sub::TopicHandle *Message::topic_as<solarxr_protocol::pub_sub::TopicHandle>() const {
  return topic_as_TopicHandle();
}

template<> inline const solarxr_protocol::pub_sub::TopicId *Message::topic_as<solarxr_protocol::pub_sub::TopicId>() const {
  return topic_as_TopicId();
}

template<> inline const solarxr_protocol::datatypes::StringTable *Message::payload_as<solarxr_protocol::datatypes::StringTable>() const {
  return payload_as_solarxr_protocol_datatypes_StringTable();
}

template<> inline const solarxr_protocol::datatypes::Bytes *Message::payload_as<solarxr_protocol::datatypes::Bytes>() const {
  return payload_as_solarxr_protocol_datatypes_Bytes();
}

template<> inline const solarxr_protocol::pub_sub::KeyValues *Message::payload_as<solarxr_protocol::pub_sub::KeyValues>() const {
  return payload_as_KeyValues();
}

struct MessageBuilder {
  typedef Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_type(solarxr_protocol::pub_sub::Topic topic_type) {
    fbb_.AddElement<uint8_t>(Message::VT_TOPIC_TYPE, static_cast<uint8_t>(topic_type), 0);
  }
  void add_topic(flatbuffers::Offset<void> topic) {
    fbb_.AddOffset(Message::VT_TOPIC, topic);
  }
  void add_payload_type(solarxr_protocol::pub_sub::Payload payload_type) {
    fbb_.AddElement<uint8_t>(Message::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(Message::VT_PAYLOAD, payload);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::pub_sub::Topic topic_type = solarxr_protocol::pub_sub::Topic::NONE,
    flatbuffers::Offset<void> topic = 0,
    solarxr_protocol::pub_sub::Payload payload_type = solarxr_protocol::pub_sub::Payload::NONE,
    flatbuffers::Offset<void> payload = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_topic(topic);
  builder_.add_payload_type(payload_type);
  builder_.add_topic_type(topic_type);
  return builder_.Finish();
}

struct KeyValues FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KeyValuesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS = 4,
    VT_VALUES = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_KEYS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           verifier.VerifyVectorOfStrings(keys()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfStrings(values()) &&
           verifier.EndTable();
  }
};

struct KeyValuesBuilder {
  typedef KeyValues Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> keys) {
    fbb_.AddOffset(KeyValues::VT_KEYS, keys);
  }
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> values) {
    fbb_.AddOffset(KeyValues::VT_VALUES, values);
  }
  explicit KeyValuesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<KeyValues> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValues>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyValues> CreateKeyValues(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> keys = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> values = 0) {
  KeyValuesBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_keys(keys);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyValues> CreateKeyValuesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *keys = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *values = nullptr) {
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*keys) : 0;
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*values) : 0;
  return solarxr_protocol::pub_sub::CreateKeyValues(
      _fbb,
      keys__,
      values__);
}

}  // namespace pub_sub

/// MessageBundle contains all of the messages for the data feed system and the
/// rpc system that will be sent in one buffer.
struct MessageBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_FEED_MSGS = 4,
    VT_RPC_MSGS = 6,
    VT_PUB_SUB_MSGS = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>> *data_feed_msgs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>> *>(VT_DATA_FEED_MSGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>> *rpc_msgs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>> *>(VT_RPC_MSGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::pub_sub::PubSubHeader>> *pub_sub_msgs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::pub_sub::PubSubHeader>> *>(VT_PUB_SUB_MSGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA_FEED_MSGS) &&
           verifier.VerifyVector(data_feed_msgs()) &&
           verifier.VerifyVectorOfTables(data_feed_msgs()) &&
           VerifyOffset(verifier, VT_RPC_MSGS) &&
           verifier.VerifyVector(rpc_msgs()) &&
           verifier.VerifyVectorOfTables(rpc_msgs()) &&
           VerifyOffset(verifier, VT_PUB_SUB_MSGS) &&
           verifier.VerifyVector(pub_sub_msgs()) &&
           verifier.VerifyVectorOfTables(pub_sub_msgs()) &&
           verifier.EndTable();
  }
};

struct MessageBundleBuilder {
  typedef MessageBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_feed_msgs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>>> data_feed_msgs) {
    fbb_.AddOffset(MessageBundle::VT_DATA_FEED_MSGS, data_feed_msgs);
  }
  void add_rpc_msgs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>>> rpc_msgs) {
    fbb_.AddOffset(MessageBundle::VT_RPC_MSGS, rpc_msgs);
  }
  void add_pub_sub_msgs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::pub_sub::PubSubHeader>>> pub_sub_msgs) {
    fbb_.AddOffset(MessageBundle::VT_PUB_SUB_MSGS, pub_sub_msgs);
  }
  explicit MessageBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MessageBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageBundle> CreateMessageBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>>> data_feed_msgs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>>> rpc_msgs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::pub_sub::PubSubHeader>>> pub_sub_msgs = 0) {
  MessageBundleBuilder builder_(_fbb);
  builder_.add_pub_sub_msgs(pub_sub_msgs);
  builder_.add_rpc_msgs(rpc_msgs);
  builder_.add_data_feed_msgs(data_feed_msgs);
  return builder_.Finish();
}

inline flatbuffers::Offset<MessageBundle> CreateMessageBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>> *data_feed_msgs = nullptr,
    const std::vector<flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>> *rpc_msgs = nullptr,
    const std::vector<flatbuffers::Offset<solarxr_protocol::pub_sub::PubSubHeader>> *pub_sub_msgs = nullptr) {
  auto data_feed_msgs__ = data_feed_msgs ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::data_feed::DataFeedMessageHeader>>(*data_feed_msgs) : 0;
  auto rpc_msgs__ = rpc_msgs ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::rpc::RpcMessageHeader>>(*rpc_msgs) : 0;
  auto pub_sub_msgs__ = pub_sub_msgs ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::pub_sub::PubSubHeader>>(*pub_sub_msgs) : 0;
  return solarxr_protocol::CreateMessageBundle(
      _fbb,
      data_feed_msgs__,
      rpc_msgs__,
      pub_sub_msgs__);
}

namespace datatypes {

namespace hardware_info {

}  // namespace hardware_info
}  // namespace datatypes

namespace data_feed {
namespace tracker {

}  // namespace tracker

namespace device_data {

}  // namespace device_data

}  // namespace data_feed

namespace rpc {
namespace settings {

}  // namespace settings

}  // namespace rpc

namespace pub_sub {

}  // namespace pub_sub

namespace data_feed {

inline bool VerifyDataFeedMessage(flatbuffers::Verifier &verifier, const void *obj, DataFeedMessage type) {
  switch (type) {
    case DataFeedMessage::NONE: {
      return true;
    }
    case DataFeedMessage::PollDataFeed: {
      auto ptr = reinterpret_cast<const solarxr_protocol::data_feed::PollDataFeed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataFeedMessage::StartDataFeed: {
      auto ptr = reinterpret_cast<const solarxr_protocol::data_feed::StartDataFeed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataFeedMessage::DataFeedUpdate: {
      auto ptr = reinterpret_cast<const solarxr_protocol::data_feed::DataFeedUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataFeedMessage::DataFeedConfig: {
      auto ptr = reinterpret_cast<const solarxr_protocol::data_feed::DataFeedConfig *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDataFeedMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<DataFeedMessage> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDataFeedMessage(
        verifier,  values->Get(i), types->GetEnum<DataFeedMessage>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace data_feed

namespace rpc {

inline bool VerifyRpcMessage(flatbuffers::Verifier &verifier, const void *obj, RpcMessage type) {
  switch (type) {
    case RpcMessage::NONE: {
      return true;
    }
    case RpcMessage::HeartbeatRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::HeartbeatRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::HeartbeatResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::HeartbeatResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::ResetRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::ResetRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::ResetResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::ResetResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AssignTrackerRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::AssignTrackerRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SettingsRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SettingsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SettingsResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SettingsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::ChangeSettingsRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::ChangeSettingsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::ClearDriftCompensationRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::ClearDriftCompensationRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::RecordBVHRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::RecordBVHRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::RecordBVHStatus: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::RecordBVHStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SkeletonConfigRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SkeletonConfigRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::ChangeSkeletonConfigRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::ChangeSkeletonConfigRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SkeletonResetAllRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SkeletonResetAllRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SkeletonConfigResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SkeletonConfigResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::OpenSerialRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::OpenSerialRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::CloseSerialRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::CloseSerialRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SetWifiRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SetWifiRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SerialUpdateResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SerialUpdateResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AutoBoneProcessRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::AutoBoneProcessRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AutoBoneProcessStatusResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::AutoBoneProcessStatusResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AutoBoneEpochResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::AutoBoneEpochResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::OverlayDisplayModeRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::OverlayDisplayModeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::OverlayDisplayModeChangeRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::OverlayDisplayModeChangeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::OverlayDisplayModeResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::OverlayDisplayModeResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SerialTrackerRebootRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SerialTrackerRebootRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SerialTrackerGetInfoRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SerialTrackerGetInfoRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SerialTrackerFactoryResetRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SerialTrackerFactoryResetRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SerialDevicesRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SerialDevicesRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SerialDevicesResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SerialDevicesResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::NewSerialDeviceResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::NewSerialDeviceResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::StartWifiProvisioningRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::StartWifiProvisioningRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::StopWifiProvisioningRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::StopWifiProvisioningRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::WifiProvisioningStatusResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::WifiProvisioningStatusResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::ServerInfosRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::ServerInfosRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::ServerInfosResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::ServerInfosResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::LegTweaksTmpChange: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::LegTweaksTmpChange *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::LegTweaksTmpClear: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::LegTweaksTmpClear *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::TapDetectionSetupNotification: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::TapDetectionSetupNotification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SetPauseTrackingRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::SetPauseTrackingRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::StatusSystemRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::StatusSystemRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::StatusSystemResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::StatusSystemResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::StatusSystemUpdate: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::StatusSystemUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::StatusSystemFixed: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::StatusSystemFixed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::ClearMountingResetRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::ClearMountingResetRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::HeightRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::HeightRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::HeightResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::HeightResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AutoBoneApplyRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::AutoBoneApplyRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AutoBoneStopRecordingRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::AutoBoneStopRecordingRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AutoBoneCancelRecordingRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::AutoBoneCancelRecordingRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRpcMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<RpcMessage> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRpcMessage(
        verifier,  values->Get(i), types->GetEnum<RpcMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyStatusData(flatbuffers::Verifier &verifier, const void *obj, StatusData type) {
  switch (type) {
    case StatusData::NONE: {
      return true;
    }
    case StatusData::StatusTrackerReset: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::StatusTrackerReset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StatusData::StatusTrackerError: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::StatusTrackerError *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StatusData::StatusSteamVRDisconnected: {
      auto ptr = reinterpret_cast<const solarxr_protocol::rpc::StatusSteamVRDisconnected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyStatusDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<StatusData> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyStatusData(
        verifier,  values->Get(i), types->GetEnum<StatusData>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace rpc

namespace pub_sub {

inline bool VerifyTopic(flatbuffers::Verifier &verifier, const void *obj, Topic type) {
  switch (type) {
    case Topic::NONE: {
      return true;
    }
    case Topic::TopicHandle: {
      auto ptr = reinterpret_cast<const solarxr_protocol::pub_sub::TopicHandle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Topic::TopicId: {
      auto ptr = reinterpret_cast<const solarxr_protocol::pub_sub::TopicId *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTopicVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Topic> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTopic(
        verifier,  values->Get(i), types->GetEnum<Topic>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyPubSubUnion(flatbuffers::Verifier &verifier, const void *obj, PubSubUnion type) {
  switch (type) {
    case PubSubUnion::NONE: {
      return true;
    }
    case PubSubUnion::Message: {
      auto ptr = reinterpret_cast<const solarxr_protocol::pub_sub::Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PubSubUnion::SubscriptionRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::pub_sub::SubscriptionRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PubSubUnion::TopicHandleRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::pub_sub::TopicHandleRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PubSubUnion::TopicMapping: {
      auto ptr = reinterpret_cast<const solarxr_protocol::pub_sub::TopicMapping *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPubSubUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<PubSubUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPubSubUnion(
        verifier,  values->Get(i), types->GetEnum<PubSubUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyPayload(flatbuffers::Verifier &verifier, const void *obj, Payload type) {
  switch (type) {
    case Payload::NONE: {
      return true;
    }
    case Payload::solarxr_protocol_datatypes_StringTable: {
      auto ptr = reinterpret_cast<const solarxr_protocol::datatypes::StringTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::solarxr_protocol_datatypes_Bytes: {
      auto ptr = reinterpret_cast<const solarxr_protocol::datatypes::Bytes *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::KeyValues: {
      auto ptr = reinterpret_cast<const solarxr_protocol::pub_sub::KeyValues *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Payload> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPayload(
        verifier,  values->Get(i), types->GetEnum<Payload>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace pub_sub
}  // namespace solarxr_protocol

#endif  // FLATBUFFERS_GENERATED_ALL_SOLARXR_PROTOCOL_H_
