// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ALL_SOLARXR_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_ALL_SOLARXR_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

namespace solarxr_protocol {
namespace datatypes {

struct HzF32;

struct TransactionId;

struct DeviceId;

struct TrackerId;
struct TrackerIdBuilder;

struct LogData;
struct LogDataBuilder;

struct Temperature;

struct Ipv4Address;

struct Bytes;
struct BytesBuilder;

struct StringTable;
struct StringTableBuilder;

namespace hardware_info {

struct HardwareAddress;

struct HardwareInfo;
struct HardwareInfoBuilder;

struct HardwareStatus;
struct HardwareStatusBuilder;

struct FirmwareStatusMask;
struct FirmwareStatusMaskBuilder;

}  // namespace hardware_info
}  // namespace datatypes

namespace device {
namespace pairing {

struct DiscoverRequest;
struct DiscoverRequestBuilder;

struct PairingInfo;
struct PairingInfoBuilder;

struct DeviceFeatureInfo;
struct DeviceFeatureInfoBuilder;

struct DeviceSensorInfo;
struct DeviceSensorInfoBuilder;

struct ImuFeatureInfo;
struct ImuFeatureInfoBuilder;

struct PairingRequest;
struct PairingRequestBuilder;

struct PairingResponse;
struct PairingResponseBuilder;

}  // namespace pairing
}  // namespace device

namespace datatypes {
namespace math {

struct Quat;

struct Vec3f;

}  // namespace math
}  // namespace datatypes

namespace device {
namespace packets {

struct DeviceStatus;
struct DeviceStatusBuilder;

struct ImuStatus;
struct ImuStatusBuilder;

struct ImuMovement;
struct ImuMovementBuilder;

}  // namespace packets

struct ServerBoundMessageHeader;
struct ServerBoundMessageHeaderBuilder;

struct DeviceBoundMessageHeader;
struct DeviceBoundMessageHeaderBuilder;

struct PingRequest;
struct PingRequestBuilder;

struct PingResponse;
struct PingResponseBuilder;

}  // namespace device

namespace application {
namespace data_feed {
namespace tracker {

struct TrackerData;
struct TrackerDataBuilder;

struct TrackerDataMask;
struct TrackerDataMaskBuilder;

struct TrackerInfo;
struct TrackerInfoBuilder;

}  // namespace tracker

namespace device_data {

struct DeviceDataMask;
struct DeviceDataMaskBuilder;

struct DeviceData;
struct DeviceDataBuilder;

}  // namespace device_data

struct Bone;
struct BoneBuilder;

struct DataFeedMessageHeader;
struct DataFeedMessageHeaderBuilder;

struct PollDataFeed;
struct PollDataFeedBuilder;

struct StartDataFeed;
struct StartDataFeedBuilder;

struct DataFeedUpdate;
struct DataFeedUpdateBuilder;

struct DataFeedConfig;
struct DataFeedConfigBuilder;

}  // namespace data_feed

namespace rpc {
namespace settings {

struct ModelToggles;
struct ModelTogglesBuilder;

struct ModelRatios;
struct ModelRatiosBuilder;

struct ModelSettings;
struct ModelSettingsBuilder;

}  // namespace settings

struct RpcMessageHeader;
struct RpcMessageHeaderBuilder;

struct HeartbeatRequest;
struct HeartbeatRequestBuilder;

struct HeartbeatResponse;
struct HeartbeatResponseBuilder;

struct ResetRequest;
struct ResetRequestBuilder;

struct ResetResponse;
struct ResetResponseBuilder;

struct AssignTrackerRequest;
struct AssignTrackerRequestBuilder;

struct SettingsRequest;
struct SettingsRequestBuilder;

struct SettingsResponse;
struct SettingsResponseBuilder;

struct ChangeSettingsRequest;
struct ChangeSettingsRequestBuilder;

struct SteamVRTrackersSetting;
struct SteamVRTrackersSettingBuilder;

struct FilteringSettings;
struct FilteringSettingsBuilder;

struct RecordBVHRequest;
struct RecordBVHRequestBuilder;

struct RecordBVHStatus;
struct RecordBVHStatusBuilder;

struct SkeletonPart;
struct SkeletonPartBuilder;

struct SkeletonConfigRequest;
struct SkeletonConfigRequestBuilder;

struct SkeletonConfigResponse;
struct SkeletonConfigResponseBuilder;

struct SkeletonResetAllRequest;
struct SkeletonResetAllRequestBuilder;

struct ChangeSkeletonConfigRequest;
struct ChangeSkeletonConfigRequestBuilder;

struct OpenSerialRequest;
struct OpenSerialRequestBuilder;

struct CloseSerialRequest;
struct CloseSerialRequestBuilder;

struct SetWifiRequest;
struct SetWifiRequestBuilder;

struct SerialUpdateResponse;
struct SerialUpdateResponseBuilder;

struct SerialTrackerRebootRequest;
struct SerialTrackerRebootRequestBuilder;

struct SerialTrackerGetInfoRequest;
struct SerialTrackerGetInfoRequestBuilder;

struct SerialTrackerFactoryResetRequest;
struct SerialTrackerFactoryResetRequestBuilder;

struct AutoBoneProcessRequest;
struct AutoBoneProcessRequestBuilder;

struct AutoBoneProcessStatusResponse;
struct AutoBoneProcessStatusResponseBuilder;

struct AutoBoneEpochResponse;
struct AutoBoneEpochResponseBuilder;

struct OverlayDisplayModeRequest;
struct OverlayDisplayModeRequestBuilder;

struct OverlayDisplayModeChangeRequest;
struct OverlayDisplayModeChangeRequestBuilder;

struct OverlayDisplayModeResponse;
struct OverlayDisplayModeResponseBuilder;

struct DetectedDevice;
struct DetectedDeviceBuilder;

struct DetectedDevicesRequest;
struct DetectedDevicesRequestBuilder;

struct PairDeviceRequest;
struct PairDeviceRequestBuilder;

}  // namespace rpc

namespace pub_sub {

struct TopicId;
struct TopicIdBuilder;

struct TopicHandle;
struct TopicHandleBuilder;

struct TopicMapping;
struct TopicMappingBuilder;

struct TopicHandleRequest;
struct TopicHandleRequestBuilder;

struct SubscriptionRequest;
struct SubscriptionRequestBuilder;

struct PubSubHeader;
struct PubSubHeaderBuilder;

struct Message;
struct MessageBuilder;

struct KeyValues;
struct KeyValuesBuilder;

}  // namespace pub_sub

struct MessageBundle;
struct MessageBundleBuilder;

}  // namespace application

namespace datatypes {

/// A list of error codes for error conditions on the device
enum class FirmwareErrorCode : uint8_t {
  Other = 0,
  Disconnected = 1,
  Occluded = 2,
  ImuError = 3,
  MIN = Other,
  MAX = ImuError
};

inline const FirmwareErrorCode (&EnumValuesFirmwareErrorCode())[4] {
  static const FirmwareErrorCode values[] = {
    FirmwareErrorCode::Other,
    FirmwareErrorCode::Disconnected,
    FirmwareErrorCode::Occluded,
    FirmwareErrorCode::ImuError
  };
  return values;
}

inline const char * const *EnumNamesFirmwareErrorCode() {
  static const char * const names[5] = {
    "Other",
    "Disconnected",
    "Occluded",
    "ImuError",
    nullptr
  };
  return names;
}

inline const char *EnumNameFirmwareErrorCode(FirmwareErrorCode e) {
  if (flatbuffers::IsOutRange(e, FirmwareErrorCode::Other, FirmwareErrorCode::ImuError)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFirmwareErrorCode()[index];
}

enum class ImuErrorCode : uint8_t {
  NONE = 0,
  I2C_ERROR = 1,
  TIMEOUT = 2,
  MIN = NONE,
  MAX = TIMEOUT
};

inline const ImuErrorCode (&EnumValuesImuErrorCode())[3] {
  static const ImuErrorCode values[] = {
    ImuErrorCode::NONE,
    ImuErrorCode::I2C_ERROR,
    ImuErrorCode::TIMEOUT
  };
  return values;
}

inline const char * const *EnumNamesImuErrorCode() {
  static const char * const names[4] = {
    "NONE",
    "I2C_ERROR",
    "TIMEOUT",
    nullptr
  };
  return names;
}

inline const char *EnumNameImuErrorCode(ImuErrorCode e) {
  if (flatbuffers::IsOutRange(e, ImuErrorCode::NONE, ImuErrorCode::TIMEOUT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesImuErrorCode()[index];
}

/// Used for filtering tracker rotations in software
enum class FilteringType : uint8_t {
  NONE = 0,
  SMOOTHING = 1,
  PREDICTION = 2,
  MIN = NONE,
  MAX = PREDICTION
};

inline const FilteringType (&EnumValuesFilteringType())[3] {
  static const FilteringType values[] = {
    FilteringType::NONE,
    FilteringType::SMOOTHING,
    FilteringType::PREDICTION
  };
  return values;
}

inline const char * const *EnumNamesFilteringType() {
  static const char * const names[4] = {
    "NONE",
    "SMOOTHING",
    "PREDICTION",
    nullptr
  };
  return names;
}

inline const char *EnumNameFilteringType(FilteringType e) {
  if (flatbuffers::IsOutRange(e, FilteringType::NONE, FilteringType::PREDICTION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFilteringType()[index];
}

/// Possible tracker roles
/// They're not perfect match for SteamVR tracker roles,
/// because we support more possible roles. Host can
/// chose how to map it to their supported role.
enum class TrackerRole : uint8_t {
  NONE = 0,
  WAIST = 1,
  LEFT_FOOT = 2,
  RIGHT_FOOT = 3,
  CHEST = 4,
  LEFT_KNEE = 5,
  RIGHT_KNEE = 6,
  LEFT_ELBOW = 7,
  RIGHT_ELBOW = 8,
  LEFT_SHOULDER = 9,
  RIGHT_SHOULDER = 10,
  LEFT_HAND = 11,
  RIGHT_HAND = 12,
  LEFT_CONTROLLER = 13,
  RIGHT_CONTROLLER = 14,
  HEAD = 15,
  NECK = 16,
  CAMERA = 17,
  KEYBOARD = 18,
  HMD = 19,
  BEACON = 20,
  GENERIC_CONTROLLER = 21,
  MIN = NONE,
  MAX = GENERIC_CONTROLLER
};

inline const TrackerRole (&EnumValuesTrackerRole())[22] {
  static const TrackerRole values[] = {
    TrackerRole::NONE,
    TrackerRole::WAIST,
    TrackerRole::LEFT_FOOT,
    TrackerRole::RIGHT_FOOT,
    TrackerRole::CHEST,
    TrackerRole::LEFT_KNEE,
    TrackerRole::RIGHT_KNEE,
    TrackerRole::LEFT_ELBOW,
    TrackerRole::RIGHT_ELBOW,
    TrackerRole::LEFT_SHOULDER,
    TrackerRole::RIGHT_SHOULDER,
    TrackerRole::LEFT_HAND,
    TrackerRole::RIGHT_HAND,
    TrackerRole::LEFT_CONTROLLER,
    TrackerRole::RIGHT_CONTROLLER,
    TrackerRole::HEAD,
    TrackerRole::NECK,
    TrackerRole::CAMERA,
    TrackerRole::KEYBOARD,
    TrackerRole::HMD,
    TrackerRole::BEACON,
    TrackerRole::GENERIC_CONTROLLER
  };
  return values;
}

inline const char * const *EnumNamesTrackerRole() {
  static const char * const names[23] = {
    "NONE",
    "WAIST",
    "LEFT_FOOT",
    "RIGHT_FOOT",
    "CHEST",
    "LEFT_KNEE",
    "RIGHT_KNEE",
    "LEFT_ELBOW",
    "RIGHT_ELBOW",
    "LEFT_SHOULDER",
    "RIGHT_SHOULDER",
    "LEFT_HAND",
    "RIGHT_HAND",
    "LEFT_CONTROLLER",
    "RIGHT_CONTROLLER",
    "HEAD",
    "NECK",
    "CAMERA",
    "KEYBOARD",
    "HMD",
    "BEACON",
    "GENERIC_CONTROLLER",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrackerRole(TrackerRole e) {
  if (flatbuffers::IsOutRange(e, TrackerRole::NONE, TrackerRole::GENERIC_CONTROLLER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrackerRole()[index];
}

/// Different parts of the body. Roughly maps to each possible bone in the skeleton.
/// These are *NOT* the trackers.
enum class BodyPart : uint8_t {
  NONE = 0,
  HEAD = 1,
  NECK = 2,
  CHEST = 3,
  WAIST = 4,
  HIP = 5,
  LEFT_UPPER_LEG = 6,
  RIGHT_UPPER_LEG = 7,
  LEFT_LOWER_LEG = 8,
  RIGHT_LOWER_LEG = 9,
  LEFT_FOOT = 10,
  RIGHT_FOOT = 11,
  LEFT_CONTROLLER = 12,
  RIGHT_CONTROLLER = 13,
  LEFT_LOWER_ARM = 14,
  RIGHT_LOWER_ARM = 15,
  LEFT_UPPER_ARM = 16,
  RIGHT_UPPER_ARM = 17,
  LEFT_HAND = 18,
  RIGHT_HAND = 19,
  LEFT_SHOULDER = 20,
  RIGHT_SHOULDER = 21,
  MIN = NONE,
  MAX = RIGHT_SHOULDER
};

inline const BodyPart (&EnumValuesBodyPart())[22] {
  static const BodyPart values[] = {
    BodyPart::NONE,
    BodyPart::HEAD,
    BodyPart::NECK,
    BodyPart::CHEST,
    BodyPart::WAIST,
    BodyPart::HIP,
    BodyPart::LEFT_UPPER_LEG,
    BodyPart::RIGHT_UPPER_LEG,
    BodyPart::LEFT_LOWER_LEG,
    BodyPart::RIGHT_LOWER_LEG,
    BodyPart::LEFT_FOOT,
    BodyPart::RIGHT_FOOT,
    BodyPart::LEFT_CONTROLLER,
    BodyPart::RIGHT_CONTROLLER,
    BodyPart::LEFT_LOWER_ARM,
    BodyPart::RIGHT_LOWER_ARM,
    BodyPart::LEFT_UPPER_ARM,
    BodyPart::RIGHT_UPPER_ARM,
    BodyPart::LEFT_HAND,
    BodyPart::RIGHT_HAND,
    BodyPart::LEFT_SHOULDER,
    BodyPart::RIGHT_SHOULDER
  };
  return values;
}

inline const char * const *EnumNamesBodyPart() {
  static const char * const names[23] = {
    "NONE",
    "HEAD",
    "NECK",
    "CHEST",
    "WAIST",
    "HIP",
    "LEFT_UPPER_LEG",
    "RIGHT_UPPER_LEG",
    "LEFT_LOWER_LEG",
    "RIGHT_LOWER_LEG",
    "LEFT_FOOT",
    "RIGHT_FOOT",
    "LEFT_CONTROLLER",
    "RIGHT_CONTROLLER",
    "LEFT_LOWER_ARM",
    "RIGHT_LOWER_ARM",
    "LEFT_UPPER_ARM",
    "RIGHT_UPPER_ARM",
    "LEFT_HAND",
    "RIGHT_HAND",
    "LEFT_SHOULDER",
    "RIGHT_SHOULDER",
    nullptr
  };
  return names;
}

inline const char *EnumNameBodyPart(BodyPart e) {
  if (flatbuffers::IsOutRange(e, BodyPart::NONE, BodyPart::RIGHT_SHOULDER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBodyPart()[index];
}

enum class TrackerStatus : uint8_t {
  NONE = 0,
  DISCONNECTED = 1,
  OK = 2,
  BUSY = 3,
  ERROR = 4,
  OCCLUDED = 5,
  MIN = NONE,
  MAX = OCCLUDED
};

inline const TrackerStatus (&EnumValuesTrackerStatus())[6] {
  static const TrackerStatus values[] = {
    TrackerStatus::NONE,
    TrackerStatus::DISCONNECTED,
    TrackerStatus::OK,
    TrackerStatus::BUSY,
    TrackerStatus::ERROR,
    TrackerStatus::OCCLUDED
  };
  return values;
}

inline const char * const *EnumNamesTrackerStatus() {
  static const char * const names[7] = {
    "NONE",
    "DISCONNECTED",
    "OK",
    "BUSY",
    "ERROR",
    "OCCLUDED",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrackerStatus(TrackerStatus e) {
  if (flatbuffers::IsOutRange(e, TrackerStatus::NONE, TrackerStatus::OCCLUDED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrackerStatus()[index];
}

namespace hardware_info {

enum class McuType : uint16_t {
  Other = 0,
  ESP8266 = 1,
  ESP32_S2 = 2,
  ESP32_S3 = 3,
  ESP32_C3 = 4,
  MIN = Other,
  MAX = ESP32_C3
};

inline const McuType (&EnumValuesMcuType())[5] {
  static const McuType values[] = {
    McuType::Other,
    McuType::ESP8266,
    McuType::ESP32_S2,
    McuType::ESP32_S3,
    McuType::ESP32_C3
  };
  return values;
}

inline const char * const *EnumNamesMcuType() {
  static const char * const names[6] = {
    "Other",
    "ESP8266",
    "ESP32_S2",
    "ESP32_S3",
    "ESP32_C3",
    nullptr
  };
  return names;
}

inline const char *EnumNameMcuType(McuType e) {
  if (flatbuffers::IsOutRange(e, McuType::Other, McuType::ESP32_C3)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMcuType()[index];
}

enum class ImuType : uint16_t {
  Other = 0,
  BNO085 = 1,
  BNO080 = 2,
  MPU6050 = 3,
  MPU9250 = 4,
  MPU6500 = 5,
  MIN = Other,
  MAX = MPU6500
};

inline const ImuType (&EnumValuesImuType())[6] {
  static const ImuType values[] = {
    ImuType::Other,
    ImuType::BNO085,
    ImuType::BNO080,
    ImuType::MPU6050,
    ImuType::MPU9250,
    ImuType::MPU6500
  };
  return values;
}

inline const char * const *EnumNamesImuType() {
  static const char * const names[7] = {
    "Other",
    "BNO085",
    "BNO080",
    "MPU6050",
    "MPU9250",
    "MPU6500",
    nullptr
  };
  return names;
}

inline const char *EnumNameImuType(ImuType e) {
  if (flatbuffers::IsOutRange(e, ImuType::Other, ImuType::MPU6500)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesImuType()[index];
}

}  // namespace hardware_info
}  // namespace datatypes

namespace device {
namespace pairing {

enum class PairingResponseError : uint8_t {
  NONE = 0,
  ALREADY_PAIRED = 1,
  MIN = NONE,
  MAX = ALREADY_PAIRED
};

inline const PairingResponseError (&EnumValuesPairingResponseError())[2] {
  static const PairingResponseError values[] = {
    PairingResponseError::NONE,
    PairingResponseError::ALREADY_PAIRED
  };
  return values;
}

inline const char * const *EnumNamesPairingResponseError() {
  static const char * const names[3] = {
    "NONE",
    "ALREADY_PAIRED",
    nullptr
  };
  return names;
}

inline const char *EnumNamePairingResponseError(PairingResponseError e) {
  if (flatbuffers::IsOutRange(e, PairingResponseError::NONE, PairingResponseError::ALREADY_PAIRED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPairingResponseError()[index];
}

}  // namespace pairing

enum class ServerBoundMessage : uint8_t {
  NONE = 0,
  solarxr_protocol_device_pairing_PairingInfo = 1,
  solarxr_protocol_device_pairing_PairingResponse = 2,
  PingResponse = 3,
  solarxr_protocol_device_packets_DeviceStatus = 4,
  solarxr_protocol_device_packets_ImuStatus = 5,
  solarxr_protocol_device_packets_ImuMovement = 6,
  MIN = NONE,
  MAX = solarxr_protocol_device_packets_ImuMovement
};

inline const ServerBoundMessage (&EnumValuesServerBoundMessage())[7] {
  static const ServerBoundMessage values[] = {
    ServerBoundMessage::NONE,
    ServerBoundMessage::solarxr_protocol_device_pairing_PairingInfo,
    ServerBoundMessage::solarxr_protocol_device_pairing_PairingResponse,
    ServerBoundMessage::PingResponse,
    ServerBoundMessage::solarxr_protocol_device_packets_DeviceStatus,
    ServerBoundMessage::solarxr_protocol_device_packets_ImuStatus,
    ServerBoundMessage::solarxr_protocol_device_packets_ImuMovement
  };
  return values;
}

inline const char * const *EnumNamesServerBoundMessage() {
  static const char * const names[8] = {
    "NONE",
    "solarxr_protocol_device_pairing_PairingInfo",
    "solarxr_protocol_device_pairing_PairingResponse",
    "PingResponse",
    "solarxr_protocol_device_packets_DeviceStatus",
    "solarxr_protocol_device_packets_ImuStatus",
    "solarxr_protocol_device_packets_ImuMovement",
    nullptr
  };
  return names;
}

inline const char *EnumNameServerBoundMessage(ServerBoundMessage e) {
  if (flatbuffers::IsOutRange(e, ServerBoundMessage::NONE, ServerBoundMessage::solarxr_protocol_device_packets_ImuMovement)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesServerBoundMessage()[index];
}

template<typename T> struct ServerBoundMessageTraits {
  static const ServerBoundMessage enum_value = ServerBoundMessage::NONE;
};

template<> struct ServerBoundMessageTraits<solarxr_protocol::device::pairing::PairingInfo> {
  static const ServerBoundMessage enum_value = ServerBoundMessage::solarxr_protocol_device_pairing_PairingInfo;
};

template<> struct ServerBoundMessageTraits<solarxr_protocol::device::pairing::PairingResponse> {
  static const ServerBoundMessage enum_value = ServerBoundMessage::solarxr_protocol_device_pairing_PairingResponse;
};

template<> struct ServerBoundMessageTraits<solarxr_protocol::device::PingResponse> {
  static const ServerBoundMessage enum_value = ServerBoundMessage::PingResponse;
};

template<> struct ServerBoundMessageTraits<solarxr_protocol::device::packets::DeviceStatus> {
  static const ServerBoundMessage enum_value = ServerBoundMessage::solarxr_protocol_device_packets_DeviceStatus;
};

template<> struct ServerBoundMessageTraits<solarxr_protocol::device::packets::ImuStatus> {
  static const ServerBoundMessage enum_value = ServerBoundMessage::solarxr_protocol_device_packets_ImuStatus;
};

template<> struct ServerBoundMessageTraits<solarxr_protocol::device::packets::ImuMovement> {
  static const ServerBoundMessage enum_value = ServerBoundMessage::solarxr_protocol_device_packets_ImuMovement;
};

bool VerifyServerBoundMessage(flatbuffers::Verifier &verifier, const void *obj, ServerBoundMessage type);
bool VerifyServerBoundMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<ServerBoundMessage> *types);

enum class DeviceBoundMessage : uint8_t {
  NONE = 0,
  solarxr_protocol_device_pairing_DiscoverRequest = 1,
  solarxr_protocol_device_pairing_PairingRequest = 2,
  PingRequest = 3,
  MIN = NONE,
  MAX = PingRequest
};

inline const DeviceBoundMessage (&EnumValuesDeviceBoundMessage())[4] {
  static const DeviceBoundMessage values[] = {
    DeviceBoundMessage::NONE,
    DeviceBoundMessage::solarxr_protocol_device_pairing_DiscoverRequest,
    DeviceBoundMessage::solarxr_protocol_device_pairing_PairingRequest,
    DeviceBoundMessage::PingRequest
  };
  return values;
}

inline const char * const *EnumNamesDeviceBoundMessage() {
  static const char * const names[5] = {
    "NONE",
    "solarxr_protocol_device_pairing_DiscoverRequest",
    "solarxr_protocol_device_pairing_PairingRequest",
    "PingRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeviceBoundMessage(DeviceBoundMessage e) {
  if (flatbuffers::IsOutRange(e, DeviceBoundMessage::NONE, DeviceBoundMessage::PingRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDeviceBoundMessage()[index];
}

template<typename T> struct DeviceBoundMessageTraits {
  static const DeviceBoundMessage enum_value = DeviceBoundMessage::NONE;
};

template<> struct DeviceBoundMessageTraits<solarxr_protocol::device::pairing::DiscoverRequest> {
  static const DeviceBoundMessage enum_value = DeviceBoundMessage::solarxr_protocol_device_pairing_DiscoverRequest;
};

template<> struct DeviceBoundMessageTraits<solarxr_protocol::device::pairing::PairingRequest> {
  static const DeviceBoundMessage enum_value = DeviceBoundMessage::solarxr_protocol_device_pairing_PairingRequest;
};

template<> struct DeviceBoundMessageTraits<solarxr_protocol::device::PingRequest> {
  static const DeviceBoundMessage enum_value = DeviceBoundMessage::PingRequest;
};

bool VerifyDeviceBoundMessage(flatbuffers::Verifier &verifier, const void *obj, DeviceBoundMessage type);
bool VerifyDeviceBoundMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<DeviceBoundMessage> *types);

}  // namespace device

namespace application {
namespace data_feed {

enum class DataFeedMessage : uint8_t {
  NONE = 0,
  PollDataFeed = 1,
  StartDataFeed = 2,
  DataFeedUpdate = 3,
  DataFeedConfig = 4,
  MIN = NONE,
  MAX = DataFeedConfig
};

inline const DataFeedMessage (&EnumValuesDataFeedMessage())[5] {
  static const DataFeedMessage values[] = {
    DataFeedMessage::NONE,
    DataFeedMessage::PollDataFeed,
    DataFeedMessage::StartDataFeed,
    DataFeedMessage::DataFeedUpdate,
    DataFeedMessage::DataFeedConfig
  };
  return values;
}

inline const char * const *EnumNamesDataFeedMessage() {
  static const char * const names[6] = {
    "NONE",
    "PollDataFeed",
    "StartDataFeed",
    "DataFeedUpdate",
    "DataFeedConfig",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataFeedMessage(DataFeedMessage e) {
  if (flatbuffers::IsOutRange(e, DataFeedMessage::NONE, DataFeedMessage::DataFeedConfig)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataFeedMessage()[index];
}

template<typename T> struct DataFeedMessageTraits {
  static const DataFeedMessage enum_value = DataFeedMessage::NONE;
};

template<> struct DataFeedMessageTraits<solarxr_protocol::application::data_feed::PollDataFeed> {
  static const DataFeedMessage enum_value = DataFeedMessage::PollDataFeed;
};

template<> struct DataFeedMessageTraits<solarxr_protocol::application::data_feed::StartDataFeed> {
  static const DataFeedMessage enum_value = DataFeedMessage::StartDataFeed;
};

template<> struct DataFeedMessageTraits<solarxr_protocol::application::data_feed::DataFeedUpdate> {
  static const DataFeedMessage enum_value = DataFeedMessage::DataFeedUpdate;
};

template<> struct DataFeedMessageTraits<solarxr_protocol::application::data_feed::DataFeedConfig> {
  static const DataFeedMessage enum_value = DataFeedMessage::DataFeedConfig;
};

bool VerifyDataFeedMessage(flatbuffers::Verifier &verifier, const void *obj, DataFeedMessage type);
bool VerifyDataFeedMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<DataFeedMessage> *types);

}  // namespace data_feed

namespace rpc {

enum class RpcMessage : uint8_t {
  NONE = 0,
  HeartbeatRequest = 1,
  HeartbeatResponse = 2,
  ResetRequest = 3,
  AssignTrackerRequest = 4,
  SettingsRequest = 5,
  SettingsResponse = 6,
  ChangeSettingsRequest = 7,
  RecordBVHRequest = 8,
  RecordBVHStatus = 9,
  SkeletonConfigRequest = 10,
  ChangeSkeletonConfigRequest = 11,
  SkeletonResetAllRequest = 12,
  SkeletonConfigResponse = 13,
  OpenSerialRequest = 14,
  CloseSerialRequest = 15,
  SetWifiRequest = 16,
  SerialUpdateResponse = 17,
  AutoBoneProcessRequest = 18,
  AutoBoneProcessStatusResponse = 19,
  AutoBoneEpochResponse = 20,
  OverlayDisplayModeRequest = 21,
  OverlayDisplayModeChangeRequest = 22,
  OverlayDisplayModeResponse = 23,
  SerialTrackerRebootRequest = 24,
  SerialTrackerGetInfoRequest = 25,
  SerialTrackerFactoryResetRequest = 26,
  DetectedDevicesRequest = 27,
  PairDeviceRequest = 28,
  MIN = NONE,
  MAX = PairDeviceRequest
};

inline const RpcMessage (&EnumValuesRpcMessage())[29] {
  static const RpcMessage values[] = {
    RpcMessage::NONE,
    RpcMessage::HeartbeatRequest,
    RpcMessage::HeartbeatResponse,
    RpcMessage::ResetRequest,
    RpcMessage::AssignTrackerRequest,
    RpcMessage::SettingsRequest,
    RpcMessage::SettingsResponse,
    RpcMessage::ChangeSettingsRequest,
    RpcMessage::RecordBVHRequest,
    RpcMessage::RecordBVHStatus,
    RpcMessage::SkeletonConfigRequest,
    RpcMessage::ChangeSkeletonConfigRequest,
    RpcMessage::SkeletonResetAllRequest,
    RpcMessage::SkeletonConfigResponse,
    RpcMessage::OpenSerialRequest,
    RpcMessage::CloseSerialRequest,
    RpcMessage::SetWifiRequest,
    RpcMessage::SerialUpdateResponse,
    RpcMessage::AutoBoneProcessRequest,
    RpcMessage::AutoBoneProcessStatusResponse,
    RpcMessage::AutoBoneEpochResponse,
    RpcMessage::OverlayDisplayModeRequest,
    RpcMessage::OverlayDisplayModeChangeRequest,
    RpcMessage::OverlayDisplayModeResponse,
    RpcMessage::SerialTrackerRebootRequest,
    RpcMessage::SerialTrackerGetInfoRequest,
    RpcMessage::SerialTrackerFactoryResetRequest,
    RpcMessage::DetectedDevicesRequest,
    RpcMessage::PairDeviceRequest
  };
  return values;
}

inline const char * const *EnumNamesRpcMessage() {
  static const char * const names[30] = {
    "NONE",
    "HeartbeatRequest",
    "HeartbeatResponse",
    "ResetRequest",
    "AssignTrackerRequest",
    "SettingsRequest",
    "SettingsResponse",
    "ChangeSettingsRequest",
    "RecordBVHRequest",
    "RecordBVHStatus",
    "SkeletonConfigRequest",
    "ChangeSkeletonConfigRequest",
    "SkeletonResetAllRequest",
    "SkeletonConfigResponse",
    "OpenSerialRequest",
    "CloseSerialRequest",
    "SetWifiRequest",
    "SerialUpdateResponse",
    "AutoBoneProcessRequest",
    "AutoBoneProcessStatusResponse",
    "AutoBoneEpochResponse",
    "OverlayDisplayModeRequest",
    "OverlayDisplayModeChangeRequest",
    "OverlayDisplayModeResponse",
    "SerialTrackerRebootRequest",
    "SerialTrackerGetInfoRequest",
    "SerialTrackerFactoryResetRequest",
    "DetectedDevicesRequest",
    "PairDeviceRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameRpcMessage(RpcMessage e) {
  if (flatbuffers::IsOutRange(e, RpcMessage::NONE, RpcMessage::PairDeviceRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRpcMessage()[index];
}

template<typename T> struct RpcMessageTraits {
  static const RpcMessage enum_value = RpcMessage::NONE;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::HeartbeatRequest> {
  static const RpcMessage enum_value = RpcMessage::HeartbeatRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::HeartbeatResponse> {
  static const RpcMessage enum_value = RpcMessage::HeartbeatResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::ResetRequest> {
  static const RpcMessage enum_value = RpcMessage::ResetRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::AssignTrackerRequest> {
  static const RpcMessage enum_value = RpcMessage::AssignTrackerRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::SettingsRequest> {
  static const RpcMessage enum_value = RpcMessage::SettingsRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::SettingsResponse> {
  static const RpcMessage enum_value = RpcMessage::SettingsResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::ChangeSettingsRequest> {
  static const RpcMessage enum_value = RpcMessage::ChangeSettingsRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::RecordBVHRequest> {
  static const RpcMessage enum_value = RpcMessage::RecordBVHRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::RecordBVHStatus> {
  static const RpcMessage enum_value = RpcMessage::RecordBVHStatus;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::SkeletonConfigRequest> {
  static const RpcMessage enum_value = RpcMessage::SkeletonConfigRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::ChangeSkeletonConfigRequest> {
  static const RpcMessage enum_value = RpcMessage::ChangeSkeletonConfigRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::SkeletonResetAllRequest> {
  static const RpcMessage enum_value = RpcMessage::SkeletonResetAllRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::SkeletonConfigResponse> {
  static const RpcMessage enum_value = RpcMessage::SkeletonConfigResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::OpenSerialRequest> {
  static const RpcMessage enum_value = RpcMessage::OpenSerialRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::CloseSerialRequest> {
  static const RpcMessage enum_value = RpcMessage::CloseSerialRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::SetWifiRequest> {
  static const RpcMessage enum_value = RpcMessage::SetWifiRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::SerialUpdateResponse> {
  static const RpcMessage enum_value = RpcMessage::SerialUpdateResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::AutoBoneProcessRequest> {
  static const RpcMessage enum_value = RpcMessage::AutoBoneProcessRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::AutoBoneProcessStatusResponse> {
  static const RpcMessage enum_value = RpcMessage::AutoBoneProcessStatusResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::AutoBoneEpochResponse> {
  static const RpcMessage enum_value = RpcMessage::AutoBoneEpochResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::OverlayDisplayModeRequest> {
  static const RpcMessage enum_value = RpcMessage::OverlayDisplayModeRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::OverlayDisplayModeChangeRequest> {
  static const RpcMessage enum_value = RpcMessage::OverlayDisplayModeChangeRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::OverlayDisplayModeResponse> {
  static const RpcMessage enum_value = RpcMessage::OverlayDisplayModeResponse;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::SerialTrackerRebootRequest> {
  static const RpcMessage enum_value = RpcMessage::SerialTrackerRebootRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::SerialTrackerGetInfoRequest> {
  static const RpcMessage enum_value = RpcMessage::SerialTrackerGetInfoRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::SerialTrackerFactoryResetRequest> {
  static const RpcMessage enum_value = RpcMessage::SerialTrackerFactoryResetRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::DetectedDevicesRequest> {
  static const RpcMessage enum_value = RpcMessage::DetectedDevicesRequest;
};

template<> struct RpcMessageTraits<solarxr_protocol::application::rpc::PairDeviceRequest> {
  static const RpcMessage enum_value = RpcMessage::PairDeviceRequest;
};

bool VerifyRpcMessage(flatbuffers::Verifier &verifier, const void *obj, RpcMessage type);
bool VerifyRpcMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<RpcMessage> *types);

enum class ResetType : uint8_t {
  Quick = 0,
  Full = 1,
  Recalibrate = 2,
  /// Second pose for calibrating mounting rotation
  Mounting = 3,
  MIN = Quick,
  MAX = Mounting
};

inline const ResetType (&EnumValuesResetType())[4] {
  static const ResetType values[] = {
    ResetType::Quick,
    ResetType::Full,
    ResetType::Recalibrate,
    ResetType::Mounting
  };
  return values;
}

inline const char * const *EnumNamesResetType() {
  static const char * const names[5] = {
    "Quick",
    "Full",
    "Recalibrate",
    "Mounting",
    nullptr
  };
  return names;
}

inline const char *EnumNameResetType(ResetType e) {
  if (flatbuffers::IsOutRange(e, ResetType::Quick, ResetType::Mounting)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResetType()[index];
}

enum class SkeletonBone : uint8_t {
  NONE = 0,
  HEAD = 1,
  NECK = 2,
  TORSO = 3,
  CHEST = 4,
  WAIST = 5,
  HIP_OFFSET = 6,
  HIPS_WIDTH = 7,
  LEGS_LENGTH = 8,
  KNEE_HEIGHT = 9,
  FOOT_LENGTH = 10,
  FOOT_SHIFT = 11,
  SKELETON_OFFSET = 12,
  CONTROLLER_DISTANCE_Z = 13,
  CONTROLLER_DISTANCE_Y = 14,
  FOREARM_LENGTH = 15,
  SHOULDERS_DISTANCE = 16,
  SHOULDERS_WIDTH = 17,
  UPPER_ARM_LENGTH = 18,
  ELBOW_OFFSET = 19,
  MIN = NONE,
  MAX = ELBOW_OFFSET
};

inline const SkeletonBone (&EnumValuesSkeletonBone())[20] {
  static const SkeletonBone values[] = {
    SkeletonBone::NONE,
    SkeletonBone::HEAD,
    SkeletonBone::NECK,
    SkeletonBone::TORSO,
    SkeletonBone::CHEST,
    SkeletonBone::WAIST,
    SkeletonBone::HIP_OFFSET,
    SkeletonBone::HIPS_WIDTH,
    SkeletonBone::LEGS_LENGTH,
    SkeletonBone::KNEE_HEIGHT,
    SkeletonBone::FOOT_LENGTH,
    SkeletonBone::FOOT_SHIFT,
    SkeletonBone::SKELETON_OFFSET,
    SkeletonBone::CONTROLLER_DISTANCE_Z,
    SkeletonBone::CONTROLLER_DISTANCE_Y,
    SkeletonBone::FOREARM_LENGTH,
    SkeletonBone::SHOULDERS_DISTANCE,
    SkeletonBone::SHOULDERS_WIDTH,
    SkeletonBone::UPPER_ARM_LENGTH,
    SkeletonBone::ELBOW_OFFSET
  };
  return values;
}

inline const char * const *EnumNamesSkeletonBone() {
  static const char * const names[21] = {
    "NONE",
    "HEAD",
    "NECK",
    "TORSO",
    "CHEST",
    "WAIST",
    "HIP_OFFSET",
    "HIPS_WIDTH",
    "LEGS_LENGTH",
    "KNEE_HEIGHT",
    "FOOT_LENGTH",
    "FOOT_SHIFT",
    "SKELETON_OFFSET",
    "CONTROLLER_DISTANCE_Z",
    "CONTROLLER_DISTANCE_Y",
    "FOREARM_LENGTH",
    "SHOULDERS_DISTANCE",
    "SHOULDERS_WIDTH",
    "UPPER_ARM_LENGTH",
    "ELBOW_OFFSET",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkeletonBone(SkeletonBone e) {
  if (flatbuffers::IsOutRange(e, SkeletonBone::NONE, SkeletonBone::ELBOW_OFFSET)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSkeletonBone()[index];
}

enum class AutoBoneProcessType : uint8_t {
  NONE = 0,
  RECORD = 1,
  SAVE = 2,
  PROCESS = 3,
  APPLY = 4,
  MIN = NONE,
  MAX = APPLY
};

inline const AutoBoneProcessType (&EnumValuesAutoBoneProcessType())[5] {
  static const AutoBoneProcessType values[] = {
    AutoBoneProcessType::NONE,
    AutoBoneProcessType::RECORD,
    AutoBoneProcessType::SAVE,
    AutoBoneProcessType::PROCESS,
    AutoBoneProcessType::APPLY
  };
  return values;
}

inline const char * const *EnumNamesAutoBoneProcessType() {
  static const char * const names[6] = {
    "NONE",
    "RECORD",
    "SAVE",
    "PROCESS",
    "APPLY",
    nullptr
  };
  return names;
}

inline const char *EnumNameAutoBoneProcessType(AutoBoneProcessType e) {
  if (flatbuffers::IsOutRange(e, AutoBoneProcessType::NONE, AutoBoneProcessType::APPLY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAutoBoneProcessType()[index];
}

}  // namespace rpc

namespace pub_sub {

enum class Topic : uint8_t {
  NONE = 0,
  TopicHandle = 1,
  TopicId = 2,
  MIN = NONE,
  MAX = TopicId
};

inline const Topic (&EnumValuesTopic())[3] {
  static const Topic values[] = {
    Topic::NONE,
    Topic::TopicHandle,
    Topic::TopicId
  };
  return values;
}

inline const char * const *EnumNamesTopic() {
  static const char * const names[4] = {
    "NONE",
    "TopicHandle",
    "TopicId",
    nullptr
  };
  return names;
}

inline const char *EnumNameTopic(Topic e) {
  if (flatbuffers::IsOutRange(e, Topic::NONE, Topic::TopicId)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTopic()[index];
}

template<typename T> struct TopicTraits {
  static const Topic enum_value = Topic::NONE;
};

template<> struct TopicTraits<solarxr_protocol::application::pub_sub::TopicHandle> {
  static const Topic enum_value = Topic::TopicHandle;
};

template<> struct TopicTraits<solarxr_protocol::application::pub_sub::TopicId> {
  static const Topic enum_value = Topic::TopicId;
};

bool VerifyTopic(flatbuffers::Verifier &verifier, const void *obj, Topic type);
bool VerifyTopicVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Topic> *types);

enum class PubSubUnion : uint8_t {
  NONE = 0,
  Message = 1,
  SubscriptionRequest = 2,
  TopicHandleRequest = 3,
  TopicMapping = 4,
  MIN = NONE,
  MAX = TopicMapping
};

inline const PubSubUnion (&EnumValuesPubSubUnion())[5] {
  static const PubSubUnion values[] = {
    PubSubUnion::NONE,
    PubSubUnion::Message,
    PubSubUnion::SubscriptionRequest,
    PubSubUnion::TopicHandleRequest,
    PubSubUnion::TopicMapping
  };
  return values;
}

inline const char * const *EnumNamesPubSubUnion() {
  static const char * const names[6] = {
    "NONE",
    "Message",
    "SubscriptionRequest",
    "TopicHandleRequest",
    "TopicMapping",
    nullptr
  };
  return names;
}

inline const char *EnumNamePubSubUnion(PubSubUnion e) {
  if (flatbuffers::IsOutRange(e, PubSubUnion::NONE, PubSubUnion::TopicMapping)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPubSubUnion()[index];
}

template<typename T> struct PubSubUnionTraits {
  static const PubSubUnion enum_value = PubSubUnion::NONE;
};

template<> struct PubSubUnionTraits<solarxr_protocol::application::pub_sub::Message> {
  static const PubSubUnion enum_value = PubSubUnion::Message;
};

template<> struct PubSubUnionTraits<solarxr_protocol::application::pub_sub::SubscriptionRequest> {
  static const PubSubUnion enum_value = PubSubUnion::SubscriptionRequest;
};

template<> struct PubSubUnionTraits<solarxr_protocol::application::pub_sub::TopicHandleRequest> {
  static const PubSubUnion enum_value = PubSubUnion::TopicHandleRequest;
};

template<> struct PubSubUnionTraits<solarxr_protocol::application::pub_sub::TopicMapping> {
  static const PubSubUnion enum_value = PubSubUnion::TopicMapping;
};

bool VerifyPubSubUnion(flatbuffers::Verifier &verifier, const void *obj, PubSubUnion type);
bool VerifyPubSubUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<PubSubUnion> *types);

enum class Payload : uint8_t {
  NONE = 0,
  solarxr_protocol_datatypes_StringTable = 1,
  solarxr_protocol_datatypes_Bytes = 2,
  KeyValues = 3,
  MIN = NONE,
  MAX = KeyValues
};

inline const Payload (&EnumValuesPayload())[4] {
  static const Payload values[] = {
    Payload::NONE,
    Payload::solarxr_protocol_datatypes_StringTable,
    Payload::solarxr_protocol_datatypes_Bytes,
    Payload::KeyValues
  };
  return values;
}

inline const char * const *EnumNamesPayload() {
  static const char * const names[5] = {
    "NONE",
    "solarxr_protocol_datatypes_StringTable",
    "solarxr_protocol_datatypes_Bytes",
    "KeyValues",
    nullptr
  };
  return names;
}

inline const char *EnumNamePayload(Payload e) {
  if (flatbuffers::IsOutRange(e, Payload::NONE, Payload::KeyValues)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPayload()[index];
}

template<typename T> struct PayloadTraits {
  static const Payload enum_value = Payload::NONE;
};

template<> struct PayloadTraits<solarxr_protocol::datatypes::StringTable> {
  static const Payload enum_value = Payload::solarxr_protocol_datatypes_StringTable;
};

template<> struct PayloadTraits<solarxr_protocol::datatypes::Bytes> {
  static const Payload enum_value = Payload::solarxr_protocol_datatypes_Bytes;
};

template<> struct PayloadTraits<solarxr_protocol::application::pub_sub::KeyValues> {
  static const Payload enum_value = Payload::KeyValues;
};

bool VerifyPayload(flatbuffers::Verifier &verifier, const void *obj, Payload type);
bool VerifyPayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Payload> *types);

}  // namespace pub_sub
}  // namespace application

namespace datatypes {

/// Frequency as 32 bit float
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) HzF32 FLATBUFFERS_FINAL_CLASS {
 private:
  float f_;

 public:
  HzF32()
      : f_(0) {
  }
  HzF32(float _f)
      : f_(flatbuffers::EndianScalar(_f)) {
  }
  float f() const {
    return flatbuffers::EndianScalar(f_);
  }
};
FLATBUFFERS_STRUCT_END(HzF32, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TransactionId FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;

 public:
  TransactionId()
      : id_(0) {
  }
  TransactionId(uint32_t _id)
      : id_(flatbuffers::EndianScalar(_id)) {
  }
  /// This is expected to overflow, networking logic should handle this case.
  uint32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
};
FLATBUFFERS_STRUCT_END(TransactionId, 4);

/// A unique ID for the device. IDs are not guaranteed to be the same after
/// the connection is terminated.
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) DeviceId FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t id_;

 public:
  DeviceId()
      : id_(0) {
  }
  DeviceId(uint8_t _id)
      : id_(flatbuffers::EndianScalar(_id)) {
  }
  uint8_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
};
FLATBUFFERS_STRUCT_END(DeviceId, 1);

/// Temperature in degrees celsius
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Temperature FLATBUFFERS_FINAL_CLASS {
 private:
  float temp_;

 public:
  Temperature()
      : temp_(0) {
  }
  Temperature(float _temp)
      : temp_(flatbuffers::EndianScalar(_temp)) {
  }
  float temp() const {
    return flatbuffers::EndianScalar(temp_);
  }
};
FLATBUFFERS_STRUCT_END(Temperature, 4);

/// The 4 bytes of an ip address are stored in 32 bits in big endian order.
/// We will switch over to fixed size arrays when they are supported better.
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Ipv4Address FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t addr_;

 public:
  Ipv4Address()
      : addr_(0) {
  }
  Ipv4Address(uint32_t _addr)
      : addr_(flatbuffers::EndianScalar(_addr)) {
  }
  uint32_t addr() const {
    return flatbuffers::EndianScalar(addr_);
  }
};
FLATBUFFERS_STRUCT_END(Ipv4Address, 4);

namespace hardware_info {

/// A MAC address or a bluetooth address, or some other uniquely identifying address
/// associated with the endpoint that we are communicating with. If it doesn't take
/// up the full set of bytes, it is aligned towards the least significant bits.
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) HardwareAddress FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t addr_;

 public:
  HardwareAddress()
      : addr_(0) {
  }
  HardwareAddress(uint64_t _addr)
      : addr_(flatbuffers::EndianScalar(_addr)) {
  }
  uint64_t addr() const {
    return flatbuffers::EndianScalar(addr_);
  }
};
FLATBUFFERS_STRUCT_END(HardwareAddress, 8);

}  // namespace hardware_info

namespace math {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Quat FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Quat()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Quat(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Quat, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3f()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3f(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3f, 12);

}  // namespace math

struct TrackerId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackerIdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICE_ID = 4,
    VT_TRACKER_NUM = 6
  };
  /// The device the tracker is associated with. If there is no hardware device it is
  /// associated with, this should be `null`.
  const solarxr_protocol::datatypes::DeviceId *device_id() const {
    return GetStruct<const solarxr_protocol::datatypes::DeviceId *>(VT_DEVICE_ID);
  }
  /// There are possibly multiple trackers per device. This identifies which one.
  uint8_t tracker_num() const {
    return GetField<uint8_t>(VT_TRACKER_NUM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<solarxr_protocol::datatypes::DeviceId>(verifier, VT_DEVICE_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_TRACKER_NUM, 1) &&
           verifier.EndTable();
  }
};

struct TrackerIdBuilder {
  typedef TrackerId Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_device_id(const solarxr_protocol::datatypes::DeviceId *device_id) {
    fbb_.AddStruct(TrackerId::VT_DEVICE_ID, device_id);
  }
  void add_tracker_num(uint8_t tracker_num) {
    fbb_.AddElement<uint8_t>(TrackerId::VT_TRACKER_NUM, tracker_num, 0);
  }
  explicit TrackerIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrackerId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackerId>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackerId> CreateTrackerId(
    flatbuffers::FlatBufferBuilder &_fbb,
    const solarxr_protocol::datatypes::DeviceId *device_id = nullptr,
    uint8_t tracker_num = 0) {
  TrackerIdBuilder builder_(_fbb);
  builder_.add_device_id(device_id);
  builder_.add_tracker_num(tracker_num);
  return builder_.Finish();
}

/// General purpose logging datatype
struct LogData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct LogDataBuilder {
  typedef LogData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(LogData::VT_MESSAGE, message);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(LogData::VT_DATA, data);
  }
  explicit LogDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogData>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogData> CreateLogData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  LogDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogData> CreateLogDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return solarxr_protocol::datatypes::CreateLogData(
      _fbb,
      message__,
      data__);
}

struct Bytes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BytesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_B = 4
  };
  const flatbuffers::Vector<uint8_t> *b() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_B);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_B) &&
           verifier.VerifyVector(b()) &&
           verifier.EndTable();
  }
};

struct BytesBuilder {
  typedef Bytes Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_b(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> b) {
    fbb_.AddOffset(Bytes::VT_B, b);
  }
  explicit BytesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Bytes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bytes>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bytes> CreateBytes(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> b = 0) {
  BytesBuilder builder_(_fbb);
  builder_.add_b(b);
  return builder_.Finish();
}

inline flatbuffers::Offset<Bytes> CreateBytesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *b = nullptr) {
  auto b__ = b ? _fbb.CreateVector<uint8_t>(*b) : 0;
  return solarxr_protocol::datatypes::CreateBytes(
      _fbb,
      b__);
}

struct StringTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_S = 4
  };
  const flatbuffers::String *s() const {
    return GetPointer<const flatbuffers::String *>(VT_S);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyString(s()) &&
           verifier.EndTable();
  }
};

struct StringTableBuilder {
  typedef StringTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_s(flatbuffers::Offset<flatbuffers::String> s) {
    fbb_.AddOffset(StringTable::VT_S, s);
  }
  explicit StringTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StringTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringTable> CreateStringTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> s = 0) {
  StringTableBuilder builder_(_fbb);
  builder_.add_s(s);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringTable> CreateStringTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *s = nullptr) {
  auto s__ = s ? _fbb.CreateString(s) : 0;
  return solarxr_protocol::datatypes::CreateStringTable(
      _fbb,
      s__);
}

namespace hardware_info {

/// Mostly static info about the device's hardware/firmware.
struct HardwareInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HardwareInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MCU_ID = 4,
    VT_DISPLAY_NAME = 6,
    VT_MODEL = 8,
    VT_MANUFACTURER = 10,
    VT_HARDWARE_REVISION = 12,
    VT_FIRMWARE_VERSION = 14,
    VT_HARDWARE_ADDRESS = 16,
    VT_IP_ADDRESS = 18
  };
  solarxr_protocol::datatypes::hardware_info::McuType mcu_id() const {
    return static_cast<solarxr_protocol::datatypes::hardware_info::McuType>(GetField<uint16_t>(VT_MCU_ID, 0));
  }
  /// A human-friendly name to display as the name of the device.
  const flatbuffers::String *display_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  /// A human-friendly string for the device model.
  const flatbuffers::String *model() const {
    return GetPointer<const flatbuffers::String *>(VT_MODEL);
  }
  /// A human-friendly string for the manufacturer of the device.
  const flatbuffers::String *manufacturer() const {
    return GetPointer<const flatbuffers::String *>(VT_MANUFACTURER);
  }
  /// The hardware version of the device. For example, pcb version.
  const flatbuffers::String *hardware_revision() const {
    return GetPointer<const flatbuffers::String *>(VT_HARDWARE_REVISION);
  }
  /// The version of the slimevr firmware that the device is running.
  const flatbuffers::String *firmware_version() const {
    return GetPointer<const flatbuffers::String *>(VT_FIRMWARE_VERSION);
  }
  const solarxr_protocol::datatypes::hardware_info::HardwareAddress *hardware_address() const {
    return GetStruct<const solarxr_protocol::datatypes::hardware_info::HardwareAddress *>(VT_HARDWARE_ADDRESS);
  }
  const solarxr_protocol::datatypes::Ipv4Address *ip_address() const {
    return GetStruct<const solarxr_protocol::datatypes::Ipv4Address *>(VT_IP_ADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MCU_ID, 2) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyOffset(verifier, VT_MODEL) &&
           verifier.VerifyString(model()) &&
           VerifyOffset(verifier, VT_MANUFACTURER) &&
           verifier.VerifyString(manufacturer()) &&
           VerifyOffset(verifier, VT_HARDWARE_REVISION) &&
           verifier.VerifyString(hardware_revision()) &&
           VerifyOffset(verifier, VT_FIRMWARE_VERSION) &&
           verifier.VerifyString(firmware_version()) &&
           VerifyField<solarxr_protocol::datatypes::hardware_info::HardwareAddress>(verifier, VT_HARDWARE_ADDRESS, 8) &&
           VerifyField<solarxr_protocol::datatypes::Ipv4Address>(verifier, VT_IP_ADDRESS, 4) &&
           verifier.EndTable();
  }
};

struct HardwareInfoBuilder {
  typedef HardwareInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mcu_id(solarxr_protocol::datatypes::hardware_info::McuType mcu_id) {
    fbb_.AddElement<uint16_t>(HardwareInfo::VT_MCU_ID, static_cast<uint16_t>(mcu_id), 0);
  }
  void add_display_name(flatbuffers::Offset<flatbuffers::String> display_name) {
    fbb_.AddOffset(HardwareInfo::VT_DISPLAY_NAME, display_name);
  }
  void add_model(flatbuffers::Offset<flatbuffers::String> model) {
    fbb_.AddOffset(HardwareInfo::VT_MODEL, model);
  }
  void add_manufacturer(flatbuffers::Offset<flatbuffers::String> manufacturer) {
    fbb_.AddOffset(HardwareInfo::VT_MANUFACTURER, manufacturer);
  }
  void add_hardware_revision(flatbuffers::Offset<flatbuffers::String> hardware_revision) {
    fbb_.AddOffset(HardwareInfo::VT_HARDWARE_REVISION, hardware_revision);
  }
  void add_firmware_version(flatbuffers::Offset<flatbuffers::String> firmware_version) {
    fbb_.AddOffset(HardwareInfo::VT_FIRMWARE_VERSION, firmware_version);
  }
  void add_hardware_address(const solarxr_protocol::datatypes::hardware_info::HardwareAddress *hardware_address) {
    fbb_.AddStruct(HardwareInfo::VT_HARDWARE_ADDRESS, hardware_address);
  }
  void add_ip_address(const solarxr_protocol::datatypes::Ipv4Address *ip_address) {
    fbb_.AddStruct(HardwareInfo::VT_IP_ADDRESS, ip_address);
  }
  explicit HardwareInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HardwareInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardwareInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardwareInfo> CreateHardwareInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::hardware_info::McuType mcu_id = solarxr_protocol::datatypes::hardware_info::McuType::Other,
    flatbuffers::Offset<flatbuffers::String> display_name = 0,
    flatbuffers::Offset<flatbuffers::String> model = 0,
    flatbuffers::Offset<flatbuffers::String> manufacturer = 0,
    flatbuffers::Offset<flatbuffers::String> hardware_revision = 0,
    flatbuffers::Offset<flatbuffers::String> firmware_version = 0,
    const solarxr_protocol::datatypes::hardware_info::HardwareAddress *hardware_address = nullptr,
    const solarxr_protocol::datatypes::Ipv4Address *ip_address = nullptr) {
  HardwareInfoBuilder builder_(_fbb);
  builder_.add_ip_address(ip_address);
  builder_.add_hardware_address(hardware_address);
  builder_.add_firmware_version(firmware_version);
  builder_.add_hardware_revision(hardware_revision);
  builder_.add_manufacturer(manufacturer);
  builder_.add_model(model);
  builder_.add_display_name(display_name);
  builder_.add_mcu_id(mcu_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<HardwareInfo> CreateHardwareInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::hardware_info::McuType mcu_id = solarxr_protocol::datatypes::hardware_info::McuType::Other,
    const char *display_name = nullptr,
    const char *model = nullptr,
    const char *manufacturer = nullptr,
    const char *hardware_revision = nullptr,
    const char *firmware_version = nullptr,
    const solarxr_protocol::datatypes::hardware_info::HardwareAddress *hardware_address = nullptr,
    const solarxr_protocol::datatypes::Ipv4Address *ip_address = nullptr) {
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  auto model__ = model ? _fbb.CreateString(model) : 0;
  auto manufacturer__ = manufacturer ? _fbb.CreateString(manufacturer) : 0;
  auto hardware_revision__ = hardware_revision ? _fbb.CreateString(hardware_revision) : 0;
  auto firmware_version__ = firmware_version ? _fbb.CreateString(firmware_version) : 0;
  return solarxr_protocol::datatypes::hardware_info::CreateHardwareInfo(
      _fbb,
      mcu_id,
      display_name__,
      model__,
      manufacturer__,
      hardware_revision__,
      firmware_version__,
      hardware_address,
      ip_address);
}

/// Mostly-dynamic status info about a tracked device's firmware
struct HardwareStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HardwareStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_STATUS = 4,
    VT_TPS = 6,
    VT_PING = 8,
    VT_RSSI = 10,
    VT_MCU_TEMP = 12,
    VT_BATTERY_VOLTAGE = 14,
    VT_BATTERY_PCT_ESTIMATE = 16,
    VT_LOG_DATA = 18
  };
  flatbuffers::Optional<solarxr_protocol::datatypes::FirmwareErrorCode> error_status() const {
    return GetOptional<uint8_t, solarxr_protocol::datatypes::FirmwareErrorCode>(VT_ERROR_STATUS);
  }
  flatbuffers::Optional<uint8_t> tps() const {
    return GetOptional<uint8_t, uint8_t>(VT_TPS);
  }
  flatbuffers::Optional<uint16_t> ping() const {
    return GetOptional<uint16_t, uint16_t>(VT_PING);
  }
  /// Received Signal Strength Indicator" between device and wifi adapter in dBm
  flatbuffers::Optional<int16_t> rssi() const {
    return GetOptional<int16_t, int16_t>(VT_RSSI);
  }
  /// Temperature in degrees celsius
  flatbuffers::Optional<float> mcu_temp() const {
    return GetOptional<float, float>(VT_MCU_TEMP);
  }
  flatbuffers::Optional<float> battery_voltage() const {
    return GetOptional<float, float>(VT_BATTERY_VOLTAGE);
  }
  flatbuffers::Optional<uint8_t> battery_pct_estimate() const {
    return GetOptional<uint8_t, uint8_t>(VT_BATTERY_PCT_ESTIMATE);
  }
  const solarxr_protocol::datatypes::LogData *log_data() const {
    return GetPointer<const solarxr_protocol::datatypes::LogData *>(VT_LOG_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ERROR_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_TPS, 1) &&
           VerifyField<uint16_t>(verifier, VT_PING, 2) &&
           VerifyField<int16_t>(verifier, VT_RSSI, 2) &&
           VerifyField<float>(verifier, VT_MCU_TEMP, 4) &&
           VerifyField<float>(verifier, VT_BATTERY_VOLTAGE, 4) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_PCT_ESTIMATE, 1) &&
           VerifyOffset(verifier, VT_LOG_DATA) &&
           verifier.VerifyTable(log_data()) &&
           verifier.EndTable();
  }
};

struct HardwareStatusBuilder {
  typedef HardwareStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_status(solarxr_protocol::datatypes::FirmwareErrorCode error_status) {
    fbb_.AddElement<uint8_t>(HardwareStatus::VT_ERROR_STATUS, static_cast<uint8_t>(error_status));
  }
  void add_tps(uint8_t tps) {
    fbb_.AddElement<uint8_t>(HardwareStatus::VT_TPS, tps);
  }
  void add_ping(uint16_t ping) {
    fbb_.AddElement<uint16_t>(HardwareStatus::VT_PING, ping);
  }
  void add_rssi(int16_t rssi) {
    fbb_.AddElement<int16_t>(HardwareStatus::VT_RSSI, rssi);
  }
  void add_mcu_temp(float mcu_temp) {
    fbb_.AddElement<float>(HardwareStatus::VT_MCU_TEMP, mcu_temp);
  }
  void add_battery_voltage(float battery_voltage) {
    fbb_.AddElement<float>(HardwareStatus::VT_BATTERY_VOLTAGE, battery_voltage);
  }
  void add_battery_pct_estimate(uint8_t battery_pct_estimate) {
    fbb_.AddElement<uint8_t>(HardwareStatus::VT_BATTERY_PCT_ESTIMATE, battery_pct_estimate);
  }
  void add_log_data(flatbuffers::Offset<solarxr_protocol::datatypes::LogData> log_data) {
    fbb_.AddOffset(HardwareStatus::VT_LOG_DATA, log_data);
  }
  explicit HardwareStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HardwareStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardwareStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardwareStatus> CreateHardwareStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<solarxr_protocol::datatypes::FirmwareErrorCode> error_status = flatbuffers::nullopt,
    flatbuffers::Optional<uint8_t> tps = flatbuffers::nullopt,
    flatbuffers::Optional<uint16_t> ping = flatbuffers::nullopt,
    flatbuffers::Optional<int16_t> rssi = flatbuffers::nullopt,
    flatbuffers::Optional<float> mcu_temp = flatbuffers::nullopt,
    flatbuffers::Optional<float> battery_voltage = flatbuffers::nullopt,
    flatbuffers::Optional<uint8_t> battery_pct_estimate = flatbuffers::nullopt,
    flatbuffers::Offset<solarxr_protocol::datatypes::LogData> log_data = 0) {
  HardwareStatusBuilder builder_(_fbb);
  builder_.add_log_data(log_data);
  if(battery_voltage) { builder_.add_battery_voltage(*battery_voltage); }
  if(mcu_temp) { builder_.add_mcu_temp(*mcu_temp); }
  if(rssi) { builder_.add_rssi(*rssi); }
  if(ping) { builder_.add_ping(*ping); }
  if(battery_pct_estimate) { builder_.add_battery_pct_estimate(*battery_pct_estimate); }
  if(tps) { builder_.add_tps(*tps); }
  if(error_status) { builder_.add_error_status(*error_status); }
  return builder_.Finish();
}

/// A mask of the data in `FirmwareStatus`
struct FirmwareStatusMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FirmwareStatusMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_STATUS = 4,
    VT_TPS = 6,
    VT_PING = 8,
    VT_RSSI = 10,
    VT_MCU_TEMP = 12,
    VT_BATTERY_VOLTAGE = 14,
    VT_BATTERY_PCT_ESTIMATE = 16
  };
  bool error_status() const {
    return GetField<uint8_t>(VT_ERROR_STATUS, 0) != 0;
  }
  bool tps() const {
    return GetField<uint8_t>(VT_TPS, 0) != 0;
  }
  bool ping() const {
    return GetField<uint8_t>(VT_PING, 0) != 0;
  }
  bool rssi() const {
    return GetField<uint8_t>(VT_RSSI, 0) != 0;
  }
  bool mcu_temp() const {
    return GetField<uint8_t>(VT_MCU_TEMP, 0) != 0;
  }
  bool battery_voltage() const {
    return GetField<uint8_t>(VT_BATTERY_VOLTAGE, 0) != 0;
  }
  bool battery_pct_estimate() const {
    return GetField<uint8_t>(VT_BATTERY_PCT_ESTIMATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ERROR_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_TPS, 1) &&
           VerifyField<uint8_t>(verifier, VT_PING, 1) &&
           VerifyField<uint8_t>(verifier, VT_RSSI, 1) &&
           VerifyField<uint8_t>(verifier, VT_MCU_TEMP, 1) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_VOLTAGE, 1) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_PCT_ESTIMATE, 1) &&
           verifier.EndTable();
  }
};

struct FirmwareStatusMaskBuilder {
  typedef FirmwareStatusMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_status(bool error_status) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_ERROR_STATUS, static_cast<uint8_t>(error_status), 0);
  }
  void add_tps(bool tps) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_TPS, static_cast<uint8_t>(tps), 0);
  }
  void add_ping(bool ping) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_PING, static_cast<uint8_t>(ping), 0);
  }
  void add_rssi(bool rssi) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_RSSI, static_cast<uint8_t>(rssi), 0);
  }
  void add_mcu_temp(bool mcu_temp) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_MCU_TEMP, static_cast<uint8_t>(mcu_temp), 0);
  }
  void add_battery_voltage(bool battery_voltage) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_BATTERY_VOLTAGE, static_cast<uint8_t>(battery_voltage), 0);
  }
  void add_battery_pct_estimate(bool battery_pct_estimate) {
    fbb_.AddElement<uint8_t>(FirmwareStatusMask::VT_BATTERY_PCT_ESTIMATE, static_cast<uint8_t>(battery_pct_estimate), 0);
  }
  explicit FirmwareStatusMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FirmwareStatusMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FirmwareStatusMask>(end);
    return o;
  }
};

inline flatbuffers::Offset<FirmwareStatusMask> CreateFirmwareStatusMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool error_status = false,
    bool tps = false,
    bool ping = false,
    bool rssi = false,
    bool mcu_temp = false,
    bool battery_voltage = false,
    bool battery_pct_estimate = false) {
  FirmwareStatusMaskBuilder builder_(_fbb);
  builder_.add_battery_pct_estimate(battery_pct_estimate);
  builder_.add_battery_voltage(battery_voltage);
  builder_.add_mcu_temp(mcu_temp);
  builder_.add_rssi(rssi);
  builder_.add_ping(ping);
  builder_.add_tps(tps);
  builder_.add_error_status(error_status);
  return builder_.Finish();
}

}  // namespace hardware_info
}  // namespace datatypes

namespace device {
namespace pairing {

/// Broadcast by the server to discover devices on startup.
/// The devices will respond with the `PairingInfo` packet.
struct DiscoverRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DiscoverRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DiscoverRequestBuilder {
  typedef DiscoverRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DiscoverRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DiscoverRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DiscoverRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DiscoverRequest> CreateDiscoverRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DiscoverRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Broadcast by the device on startup to tell servers what this device supports,
/// and if it's already paired (i.e. if the server should show the popup).
struct PairingInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PairingInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAIRED_TO = 4,
    VT_DISPLAY_NAME = 6,
    VT_MODEL = 8,
    VT_MANUFACTURER = 10,
    VT_FIRMWARE_VERSION = 12,
    VT_MCU_TYPE = 14,
    VT_FEATURES = 16,
    VT_SENSORS = 18
  };
  /// If this tracker isn't paired to any server, this field should be `0`.
  uint32_t paired_to() const {
    return GetField<uint32_t>(VT_PAIRED_TO, 0);
  }
  const flatbuffers::String *display_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  const flatbuffers::String *model() const {
    return GetPointer<const flatbuffers::String *>(VT_MODEL);
  }
  const flatbuffers::String *manufacturer() const {
    return GetPointer<const flatbuffers::String *>(VT_MANUFACTURER);
  }
  const flatbuffers::String *firmware_version() const {
    return GetPointer<const flatbuffers::String *>(VT_FIRMWARE_VERSION);
  }
  solarxr_protocol::datatypes::hardware_info::McuType mcu_type() const {
    return static_cast<solarxr_protocol::datatypes::hardware_info::McuType>(GetField<uint16_t>(VT_MCU_TYPE, 0));
  }
  const solarxr_protocol::device::pairing::DeviceFeatureInfo *features() const {
    return GetPointer<const solarxr_protocol::device::pairing::DeviceFeatureInfo *>(VT_FEATURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::device::pairing::DeviceSensorInfo>> *sensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::device::pairing::DeviceSensorInfo>> *>(VT_SENSORS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PAIRED_TO, 4) &&
           VerifyOffsetRequired(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyOffsetRequired(verifier, VT_MODEL) &&
           verifier.VerifyString(model()) &&
           VerifyOffsetRequired(verifier, VT_MANUFACTURER) &&
           verifier.VerifyString(manufacturer()) &&
           VerifyOffsetRequired(verifier, VT_FIRMWARE_VERSION) &&
           verifier.VerifyString(firmware_version()) &&
           VerifyField<uint16_t>(verifier, VT_MCU_TYPE, 2) &&
           VerifyOffsetRequired(verifier, VT_FEATURES) &&
           verifier.VerifyTable(features()) &&
           VerifyOffsetRequired(verifier, VT_SENSORS) &&
           verifier.VerifyVector(sensors()) &&
           verifier.VerifyVectorOfTables(sensors()) &&
           verifier.EndTable();
  }
};

struct PairingInfoBuilder {
  typedef PairingInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_paired_to(uint32_t paired_to) {
    fbb_.AddElement<uint32_t>(PairingInfo::VT_PAIRED_TO, paired_to, 0);
  }
  void add_display_name(flatbuffers::Offset<flatbuffers::String> display_name) {
    fbb_.AddOffset(PairingInfo::VT_DISPLAY_NAME, display_name);
  }
  void add_model(flatbuffers::Offset<flatbuffers::String> model) {
    fbb_.AddOffset(PairingInfo::VT_MODEL, model);
  }
  void add_manufacturer(flatbuffers::Offset<flatbuffers::String> manufacturer) {
    fbb_.AddOffset(PairingInfo::VT_MANUFACTURER, manufacturer);
  }
  void add_firmware_version(flatbuffers::Offset<flatbuffers::String> firmware_version) {
    fbb_.AddOffset(PairingInfo::VT_FIRMWARE_VERSION, firmware_version);
  }
  void add_mcu_type(solarxr_protocol::datatypes::hardware_info::McuType mcu_type) {
    fbb_.AddElement<uint16_t>(PairingInfo::VT_MCU_TYPE, static_cast<uint16_t>(mcu_type), 0);
  }
  void add_features(flatbuffers::Offset<solarxr_protocol::device::pairing::DeviceFeatureInfo> features) {
    fbb_.AddOffset(PairingInfo::VT_FEATURES, features);
  }
  void add_sensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::device::pairing::DeviceSensorInfo>>> sensors) {
    fbb_.AddOffset(PairingInfo::VT_SENSORS, sensors);
  }
  explicit PairingInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PairingInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PairingInfo>(end);
    fbb_.Required(o, PairingInfo::VT_DISPLAY_NAME);
    fbb_.Required(o, PairingInfo::VT_MODEL);
    fbb_.Required(o, PairingInfo::VT_MANUFACTURER);
    fbb_.Required(o, PairingInfo::VT_FIRMWARE_VERSION);
    fbb_.Required(o, PairingInfo::VT_FEATURES);
    fbb_.Required(o, PairingInfo::VT_SENSORS);
    return o;
  }
};

inline flatbuffers::Offset<PairingInfo> CreatePairingInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t paired_to = 0,
    flatbuffers::Offset<flatbuffers::String> display_name = 0,
    flatbuffers::Offset<flatbuffers::String> model = 0,
    flatbuffers::Offset<flatbuffers::String> manufacturer = 0,
    flatbuffers::Offset<flatbuffers::String> firmware_version = 0,
    solarxr_protocol::datatypes::hardware_info::McuType mcu_type = solarxr_protocol::datatypes::hardware_info::McuType::Other,
    flatbuffers::Offset<solarxr_protocol::device::pairing::DeviceFeatureInfo> features = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::device::pairing::DeviceSensorInfo>>> sensors = 0) {
  PairingInfoBuilder builder_(_fbb);
  builder_.add_sensors(sensors);
  builder_.add_features(features);
  builder_.add_firmware_version(firmware_version);
  builder_.add_manufacturer(manufacturer);
  builder_.add_model(model);
  builder_.add_display_name(display_name);
  builder_.add_paired_to(paired_to);
  builder_.add_mcu_type(mcu_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<PairingInfo> CreatePairingInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t paired_to = 0,
    const char *display_name = nullptr,
    const char *model = nullptr,
    const char *manufacturer = nullptr,
    const char *firmware_version = nullptr,
    solarxr_protocol::datatypes::hardware_info::McuType mcu_type = solarxr_protocol::datatypes::hardware_info::McuType::Other,
    flatbuffers::Offset<solarxr_protocol::device::pairing::DeviceFeatureInfo> features = 0,
    const std::vector<flatbuffers::Offset<solarxr_protocol::device::pairing::DeviceSensorInfo>> *sensors = nullptr) {
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  auto model__ = model ? _fbb.CreateString(model) : 0;
  auto manufacturer__ = manufacturer ? _fbb.CreateString(manufacturer) : 0;
  auto firmware_version__ = firmware_version ? _fbb.CreateString(firmware_version) : 0;
  auto sensors__ = sensors ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::device::pairing::DeviceSensorInfo>>(*sensors) : 0;
  return solarxr_protocol::device::pairing::CreatePairingInfo(
      _fbb,
      paired_to,
      display_name__,
      model__,
      manufacturer__,
      firmware_version__,
      mcu_type,
      features,
      sensors__);
}

struct DeviceFeatureInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceFeatureInfoBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DeviceFeatureInfoBuilder {
  typedef DeviceFeatureInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DeviceFeatureInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceFeatureInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceFeatureInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceFeatureInfo> CreateDeviceFeatureInfo(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DeviceFeatureInfoBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DeviceSensorInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceSensorInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_FEATURES = 8
  };
  /// If the ID is contained twice in the array,
  /// only the first one will be used and the others will be ignred.
  uint8_t id() const {
    return GetField<uint8_t>(VT_ID, 0);
  }
  solarxr_protocol::datatypes::hardware_info::ImuType type() const {
    return static_cast<solarxr_protocol::datatypes::hardware_info::ImuType>(GetField<uint16_t>(VT_TYPE, 0));
  }
  const solarxr_protocol::device::pairing::ImuFeatureInfo *features() const {
    return GetPointer<const solarxr_protocol::device::pairing::ImuFeatureInfo *>(VT_FEATURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ID, 1) &&
           VerifyField<uint16_t>(verifier, VT_TYPE, 2) &&
           VerifyOffsetRequired(verifier, VT_FEATURES) &&
           verifier.VerifyTable(features()) &&
           verifier.EndTable();
  }
};

struct DeviceSensorInfoBuilder {
  typedef DeviceSensorInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint8_t id) {
    fbb_.AddElement<uint8_t>(DeviceSensorInfo::VT_ID, id, 0);
  }
  void add_type(solarxr_protocol::datatypes::hardware_info::ImuType type) {
    fbb_.AddElement<uint16_t>(DeviceSensorInfo::VT_TYPE, static_cast<uint16_t>(type), 0);
  }
  void add_features(flatbuffers::Offset<solarxr_protocol::device::pairing::ImuFeatureInfo> features) {
    fbb_.AddOffset(DeviceSensorInfo::VT_FEATURES, features);
  }
  explicit DeviceSensorInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceSensorInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceSensorInfo>(end);
    fbb_.Required(o, DeviceSensorInfo::VT_FEATURES);
    return o;
  }
};

inline flatbuffers::Offset<DeviceSensorInfo> CreateDeviceSensorInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t id = 0,
    solarxr_protocol::datatypes::hardware_info::ImuType type = solarxr_protocol::datatypes::hardware_info::ImuType::Other,
    flatbuffers::Offset<solarxr_protocol::device::pairing::ImuFeatureInfo> features = 0) {
  DeviceSensorInfoBuilder builder_(_fbb);
  builder_.add_features(features);
  builder_.add_type(type);
  builder_.add_id(id);
  return builder_.Finish();
}

struct ImuFeatureInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ImuFeatureInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GYROSCOPE_CALIBRATION = 4,
    VT_ACCELEROMETER_CALIBRATION = 6,
    VT_MAGNETOMETER_CALIBRATION = 8
  };
  bool gyroscope_calibration() const {
    return GetField<uint8_t>(VT_GYROSCOPE_CALIBRATION, 0) != 0;
  }
  bool accelerometer_calibration() const {
    return GetField<uint8_t>(VT_ACCELEROMETER_CALIBRATION, 0) != 0;
  }
  bool magnetometer_calibration() const {
    return GetField<uint8_t>(VT_MAGNETOMETER_CALIBRATION, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_GYROSCOPE_CALIBRATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_ACCELEROMETER_CALIBRATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_MAGNETOMETER_CALIBRATION, 1) &&
           verifier.EndTable();
  }
};

struct ImuFeatureInfoBuilder {
  typedef ImuFeatureInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gyroscope_calibration(bool gyroscope_calibration) {
    fbb_.AddElement<uint8_t>(ImuFeatureInfo::VT_GYROSCOPE_CALIBRATION, static_cast<uint8_t>(gyroscope_calibration), 0);
  }
  void add_accelerometer_calibration(bool accelerometer_calibration) {
    fbb_.AddElement<uint8_t>(ImuFeatureInfo::VT_ACCELEROMETER_CALIBRATION, static_cast<uint8_t>(accelerometer_calibration), 0);
  }
  void add_magnetometer_calibration(bool magnetometer_calibration) {
    fbb_.AddElement<uint8_t>(ImuFeatureInfo::VT_MAGNETOMETER_CALIBRATION, static_cast<uint8_t>(magnetometer_calibration), 0);
  }
  explicit ImuFeatureInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ImuFeatureInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ImuFeatureInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ImuFeatureInfo> CreateImuFeatureInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool gyroscope_calibration = false,
    bool accelerometer_calibration = false,
    bool magnetometer_calibration = false) {
  ImuFeatureInfoBuilder builder_(_fbb);
  builder_.add_magnetometer_calibration(magnetometer_calibration);
  builder_.add_accelerometer_calibration(accelerometer_calibration);
  builder_.add_gyroscope_calibration(gyroscope_calibration);
  return builder_.Finish();
}

/// Sent by a server, trying to connect to a device
/// which then the device will respond to with the `PairingResponse` packet.
struct PairingRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PairingRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVER_ID = 4
  };
  /// Should not be `0`, will get ignored by the tracker otherwise.
  uint32_t server_id() const {
    return GetField<uint32_t>(VT_SERVER_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SERVER_ID, 4) &&
           verifier.EndTable();
  }
};

struct PairingRequestBuilder {
  typedef PairingRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_server_id(uint32_t server_id) {
    fbb_.AddElement<uint32_t>(PairingRequest::VT_SERVER_ID, server_id, 0);
  }
  explicit PairingRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PairingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PairingRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PairingRequest> CreatePairingRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t server_id = 0) {
  PairingRequestBuilder builder_(_fbb);
  builder_.add_server_id(server_id);
  return builder_.Finish();
}

struct PairingResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PairingResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4
  };
  solarxr_protocol::device::pairing::PairingResponseError error() const {
    return static_cast<solarxr_protocol::device::pairing::PairingResponseError>(GetField<uint8_t>(VT_ERROR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ERROR, 1) &&
           verifier.EndTable();
  }
};

struct PairingResponseBuilder {
  typedef PairingResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(solarxr_protocol::device::pairing::PairingResponseError error) {
    fbb_.AddElement<uint8_t>(PairingResponse::VT_ERROR, static_cast<uint8_t>(error), 0);
  }
  explicit PairingResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PairingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PairingResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PairingResponse> CreatePairingResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::device::pairing::PairingResponseError error = solarxr_protocol::device::pairing::PairingResponseError::NONE) {
  PairingResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

}  // namespace pairing

namespace packets {

struct DeviceStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BATTERY_PERCENTAGE = 4,
    VT_RSSI = 6
  };
  uint8_t battery_percentage() const {
    return GetField<uint8_t>(VT_BATTERY_PERCENTAGE, 0);
  }
  int16_t rssi() const {
    return GetField<int16_t>(VT_RSSI, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_PERCENTAGE, 1) &&
           VerifyField<int16_t>(verifier, VT_RSSI, 2) &&
           verifier.EndTable();
  }
};

struct DeviceStatusBuilder {
  typedef DeviceStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_battery_percentage(uint8_t battery_percentage) {
    fbb_.AddElement<uint8_t>(DeviceStatus::VT_BATTERY_PERCENTAGE, battery_percentage, 0);
  }
  void add_rssi(int16_t rssi) {
    fbb_.AddElement<int16_t>(DeviceStatus::VT_RSSI, rssi, 0);
  }
  explicit DeviceStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceStatus> CreateDeviceStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t battery_percentage = 0,
    int16_t rssi = 0) {
  DeviceStatusBuilder builder_(_fbb);
  builder_.add_rssi(rssi);
  builder_.add_battery_percentage(battery_percentage);
  return builder_.Finish();
}

struct ImuStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ImuStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_IMU_TYPE = 6,
    VT_POLL_RATE = 8,
    VT_TEMPERATURE = 10,
    VT_ERROR_STATUS = 12,
    VT_MAGNETOMETER_ACCURACY = 14
  };
  uint8_t id() const {
    return GetField<uint8_t>(VT_ID, 0);
  }
  solarxr_protocol::datatypes::hardware_info::ImuType imu_type() const {
    return static_cast<solarxr_protocol::datatypes::hardware_info::ImuType>(GetField<uint16_t>(VT_IMU_TYPE, 0));
  }
  const solarxr_protocol::datatypes::HzF32 *poll_rate() const {
    return GetStruct<const solarxr_protocol::datatypes::HzF32 *>(VT_POLL_RATE);
  }
  const solarxr_protocol::datatypes::Temperature *temperature() const {
    return GetStruct<const solarxr_protocol::datatypes::Temperature *>(VT_TEMPERATURE);
  }
  flatbuffers::Optional<solarxr_protocol::datatypes::ImuErrorCode> error_status() const {
    return GetOptional<uint8_t, solarxr_protocol::datatypes::ImuErrorCode>(VT_ERROR_STATUS);
  }
  float magnetometer_accuracy() const {
    return GetField<float>(VT_MAGNETOMETER_ACCURACY, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ID, 1) &&
           VerifyField<uint16_t>(verifier, VT_IMU_TYPE, 2) &&
           VerifyField<solarxr_protocol::datatypes::HzF32>(verifier, VT_POLL_RATE, 4) &&
           VerifyField<solarxr_protocol::datatypes::Temperature>(verifier, VT_TEMPERATURE, 4) &&
           VerifyField<uint8_t>(verifier, VT_ERROR_STATUS, 1) &&
           VerifyField<float>(verifier, VT_MAGNETOMETER_ACCURACY, 4) &&
           verifier.EndTable();
  }
};

struct ImuStatusBuilder {
  typedef ImuStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint8_t id) {
    fbb_.AddElement<uint8_t>(ImuStatus::VT_ID, id, 0);
  }
  void add_imu_type(solarxr_protocol::datatypes::hardware_info::ImuType imu_type) {
    fbb_.AddElement<uint16_t>(ImuStatus::VT_IMU_TYPE, static_cast<uint16_t>(imu_type), 0);
  }
  void add_poll_rate(const solarxr_protocol::datatypes::HzF32 *poll_rate) {
    fbb_.AddStruct(ImuStatus::VT_POLL_RATE, poll_rate);
  }
  void add_temperature(const solarxr_protocol::datatypes::Temperature *temperature) {
    fbb_.AddStruct(ImuStatus::VT_TEMPERATURE, temperature);
  }
  void add_error_status(solarxr_protocol::datatypes::ImuErrorCode error_status) {
    fbb_.AddElement<uint8_t>(ImuStatus::VT_ERROR_STATUS, static_cast<uint8_t>(error_status));
  }
  void add_magnetometer_accuracy(float magnetometer_accuracy) {
    fbb_.AddElement<float>(ImuStatus::VT_MAGNETOMETER_ACCURACY, magnetometer_accuracy, 0.0f);
  }
  explicit ImuStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ImuStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ImuStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<ImuStatus> CreateImuStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t id = 0,
    solarxr_protocol::datatypes::hardware_info::ImuType imu_type = solarxr_protocol::datatypes::hardware_info::ImuType::Other,
    const solarxr_protocol::datatypes::HzF32 *poll_rate = nullptr,
    const solarxr_protocol::datatypes::Temperature *temperature = nullptr,
    flatbuffers::Optional<solarxr_protocol::datatypes::ImuErrorCode> error_status = flatbuffers::nullopt,
    float magnetometer_accuracy = 0.0f) {
  ImuStatusBuilder builder_(_fbb);
  builder_.add_magnetometer_accuracy(magnetometer_accuracy);
  builder_.add_temperature(temperature);
  builder_.add_poll_rate(poll_rate);
  builder_.add_imu_type(imu_type);
  if(error_status) { builder_.add_error_status(*error_status); }
  builder_.add_id(id);
  return builder_.Finish();
}

struct ImuMovement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ImuMovementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ROTATION = 6,
    VT_ACCELERATION = 8
  };
  uint8_t id() const {
    return GetField<uint8_t>(VT_ID, 0);
  }
  const solarxr_protocol::datatypes::math::Quat *rotation() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_ROTATION);
  }
  const solarxr_protocol::datatypes::math::Vec3f *acceleration() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Vec3f *>(VT_ACCELERATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ID, 1) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_ROTATION, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Vec3f>(verifier, VT_ACCELERATION, 4) &&
           verifier.EndTable();
  }
};

struct ImuMovementBuilder {
  typedef ImuMovement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint8_t id) {
    fbb_.AddElement<uint8_t>(ImuMovement::VT_ID, id, 0);
  }
  void add_rotation(const solarxr_protocol::datatypes::math::Quat *rotation) {
    fbb_.AddStruct(ImuMovement::VT_ROTATION, rotation);
  }
  void add_acceleration(const solarxr_protocol::datatypes::math::Vec3f *acceleration) {
    fbb_.AddStruct(ImuMovement::VT_ACCELERATION, acceleration);
  }
  explicit ImuMovementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ImuMovement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ImuMovement>(end);
    return o;
  }
};

inline flatbuffers::Offset<ImuMovement> CreateImuMovement(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t id = 0,
    const solarxr_protocol::datatypes::math::Quat *rotation = nullptr,
    const solarxr_protocol::datatypes::math::Vec3f *acceleration = nullptr) {
  ImuMovementBuilder builder_(_fbb);
  builder_.add_acceleration(acceleration);
  builder_.add_rotation(rotation);
  builder_.add_id(id);
  return builder_.Finish();
}

}  // namespace packets

struct ServerBoundMessageHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerBoundMessageHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAC_ADDRESS = 4,
    VT_REQ_REP_TYPE = 6,
    VT_REQ_REP = 8
  };
  const solarxr_protocol::datatypes::hardware_info::HardwareAddress *mac_address() const {
    return GetStruct<const solarxr_protocol::datatypes::hardware_info::HardwareAddress *>(VT_MAC_ADDRESS);
  }
  solarxr_protocol::device::ServerBoundMessage req_rep_type() const {
    return static_cast<solarxr_protocol::device::ServerBoundMessage>(GetField<uint8_t>(VT_REQ_REP_TYPE, 0));
  }
  const void *req_rep() const {
    return GetPointer<const void *>(VT_REQ_REP);
  }
  template<typename T> const T *req_rep_as() const;
  const solarxr_protocol::device::pairing::PairingInfo *req_rep_as_solarxr_protocol_device_pairing_PairingInfo() const {
    return req_rep_type() == solarxr_protocol::device::ServerBoundMessage::solarxr_protocol_device_pairing_PairingInfo ? static_cast<const solarxr_protocol::device::pairing::PairingInfo *>(req_rep()) : nullptr;
  }
  const solarxr_protocol::device::pairing::PairingResponse *req_rep_as_solarxr_protocol_device_pairing_PairingResponse() const {
    return req_rep_type() == solarxr_protocol::device::ServerBoundMessage::solarxr_protocol_device_pairing_PairingResponse ? static_cast<const solarxr_protocol::device::pairing::PairingResponse *>(req_rep()) : nullptr;
  }
  const solarxr_protocol::device::PingResponse *req_rep_as_PingResponse() const {
    return req_rep_type() == solarxr_protocol::device::ServerBoundMessage::PingResponse ? static_cast<const solarxr_protocol::device::PingResponse *>(req_rep()) : nullptr;
  }
  const solarxr_protocol::device::packets::DeviceStatus *req_rep_as_solarxr_protocol_device_packets_DeviceStatus() const {
    return req_rep_type() == solarxr_protocol::device::ServerBoundMessage::solarxr_protocol_device_packets_DeviceStatus ? static_cast<const solarxr_protocol::device::packets::DeviceStatus *>(req_rep()) : nullptr;
  }
  const solarxr_protocol::device::packets::ImuStatus *req_rep_as_solarxr_protocol_device_packets_ImuStatus() const {
    return req_rep_type() == solarxr_protocol::device::ServerBoundMessage::solarxr_protocol_device_packets_ImuStatus ? static_cast<const solarxr_protocol::device::packets::ImuStatus *>(req_rep()) : nullptr;
  }
  const solarxr_protocol::device::packets::ImuMovement *req_rep_as_solarxr_protocol_device_packets_ImuMovement() const {
    return req_rep_type() == solarxr_protocol::device::ServerBoundMessage::solarxr_protocol_device_packets_ImuMovement ? static_cast<const solarxr_protocol::device::packets::ImuMovement *>(req_rep()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<solarxr_protocol::datatypes::hardware_info::HardwareAddress>(verifier, VT_MAC_ADDRESS, 8) &&
           VerifyField<uint8_t>(verifier, VT_REQ_REP_TYPE, 1) &&
           VerifyOffset(verifier, VT_REQ_REP) &&
           VerifyServerBoundMessage(verifier, req_rep(), req_rep_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::device::pairing::PairingInfo *ServerBoundMessageHeader::req_rep_as<solarxr_protocol::device::pairing::PairingInfo>() const {
  return req_rep_as_solarxr_protocol_device_pairing_PairingInfo();
}

template<> inline const solarxr_protocol::device::pairing::PairingResponse *ServerBoundMessageHeader::req_rep_as<solarxr_protocol::device::pairing::PairingResponse>() const {
  return req_rep_as_solarxr_protocol_device_pairing_PairingResponse();
}

template<> inline const solarxr_protocol::device::PingResponse *ServerBoundMessageHeader::req_rep_as<solarxr_protocol::device::PingResponse>() const {
  return req_rep_as_PingResponse();
}

template<> inline const solarxr_protocol::device::packets::DeviceStatus *ServerBoundMessageHeader::req_rep_as<solarxr_protocol::device::packets::DeviceStatus>() const {
  return req_rep_as_solarxr_protocol_device_packets_DeviceStatus();
}

template<> inline const solarxr_protocol::device::packets::ImuStatus *ServerBoundMessageHeader::req_rep_as<solarxr_protocol::device::packets::ImuStatus>() const {
  return req_rep_as_solarxr_protocol_device_packets_ImuStatus();
}

template<> inline const solarxr_protocol::device::packets::ImuMovement *ServerBoundMessageHeader::req_rep_as<solarxr_protocol::device::packets::ImuMovement>() const {
  return req_rep_as_solarxr_protocol_device_packets_ImuMovement();
}

struct ServerBoundMessageHeaderBuilder {
  typedef ServerBoundMessageHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mac_address(const solarxr_protocol::datatypes::hardware_info::HardwareAddress *mac_address) {
    fbb_.AddStruct(ServerBoundMessageHeader::VT_MAC_ADDRESS, mac_address);
  }
  void add_req_rep_type(solarxr_protocol::device::ServerBoundMessage req_rep_type) {
    fbb_.AddElement<uint8_t>(ServerBoundMessageHeader::VT_REQ_REP_TYPE, static_cast<uint8_t>(req_rep_type), 0);
  }
  void add_req_rep(flatbuffers::Offset<void> req_rep) {
    fbb_.AddOffset(ServerBoundMessageHeader::VT_REQ_REP, req_rep);
  }
  explicit ServerBoundMessageHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ServerBoundMessageHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerBoundMessageHeader>(end);
    fbb_.Required(o, ServerBoundMessageHeader::VT_MAC_ADDRESS);
    return o;
  }
};

inline flatbuffers::Offset<ServerBoundMessageHeader> CreateServerBoundMessageHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    const solarxr_protocol::datatypes::hardware_info::HardwareAddress *mac_address = nullptr,
    solarxr_protocol::device::ServerBoundMessage req_rep_type = solarxr_protocol::device::ServerBoundMessage::NONE,
    flatbuffers::Offset<void> req_rep = 0) {
  ServerBoundMessageHeaderBuilder builder_(_fbb);
  builder_.add_req_rep(req_rep);
  builder_.add_mac_address(mac_address);
  builder_.add_req_rep_type(req_rep_type);
  return builder_.Finish();
}

struct DeviceBoundMessageHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceBoundMessageHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQ_REP_TYPE = 4,
    VT_REQ_REP = 6
  };
  solarxr_protocol::device::DeviceBoundMessage req_rep_type() const {
    return static_cast<solarxr_protocol::device::DeviceBoundMessage>(GetField<uint8_t>(VT_REQ_REP_TYPE, 0));
  }
  const void *req_rep() const {
    return GetPointer<const void *>(VT_REQ_REP);
  }
  template<typename T> const T *req_rep_as() const;
  const solarxr_protocol::device::pairing::DiscoverRequest *req_rep_as_solarxr_protocol_device_pairing_DiscoverRequest() const {
    return req_rep_type() == solarxr_protocol::device::DeviceBoundMessage::solarxr_protocol_device_pairing_DiscoverRequest ? static_cast<const solarxr_protocol::device::pairing::DiscoverRequest *>(req_rep()) : nullptr;
  }
  const solarxr_protocol::device::pairing::PairingRequest *req_rep_as_solarxr_protocol_device_pairing_PairingRequest() const {
    return req_rep_type() == solarxr_protocol::device::DeviceBoundMessage::solarxr_protocol_device_pairing_PairingRequest ? static_cast<const solarxr_protocol::device::pairing::PairingRequest *>(req_rep()) : nullptr;
  }
  const solarxr_protocol::device::PingRequest *req_rep_as_PingRequest() const {
    return req_rep_type() == solarxr_protocol::device::DeviceBoundMessage::PingRequest ? static_cast<const solarxr_protocol::device::PingRequest *>(req_rep()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REQ_REP_TYPE, 1) &&
           VerifyOffset(verifier, VT_REQ_REP) &&
           VerifyDeviceBoundMessage(verifier, req_rep(), req_rep_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::device::pairing::DiscoverRequest *DeviceBoundMessageHeader::req_rep_as<solarxr_protocol::device::pairing::DiscoverRequest>() const {
  return req_rep_as_solarxr_protocol_device_pairing_DiscoverRequest();
}

template<> inline const solarxr_protocol::device::pairing::PairingRequest *DeviceBoundMessageHeader::req_rep_as<solarxr_protocol::device::pairing::PairingRequest>() const {
  return req_rep_as_solarxr_protocol_device_pairing_PairingRequest();
}

template<> inline const solarxr_protocol::device::PingRequest *DeviceBoundMessageHeader::req_rep_as<solarxr_protocol::device::PingRequest>() const {
  return req_rep_as_PingRequest();
}

struct DeviceBoundMessageHeaderBuilder {
  typedef DeviceBoundMessageHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_req_rep_type(solarxr_protocol::device::DeviceBoundMessage req_rep_type) {
    fbb_.AddElement<uint8_t>(DeviceBoundMessageHeader::VT_REQ_REP_TYPE, static_cast<uint8_t>(req_rep_type), 0);
  }
  void add_req_rep(flatbuffers::Offset<void> req_rep) {
    fbb_.AddOffset(DeviceBoundMessageHeader::VT_REQ_REP, req_rep);
  }
  explicit DeviceBoundMessageHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceBoundMessageHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceBoundMessageHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceBoundMessageHeader> CreateDeviceBoundMessageHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::device::DeviceBoundMessage req_rep_type = solarxr_protocol::device::DeviceBoundMessage::NONE,
    flatbuffers::Offset<void> req_rep = 0) {
  DeviceBoundMessageHeaderBuilder builder_(_fbb);
  builder_.add_req_rep(req_rep);
  builder_.add_req_rep_type(req_rep_type);
  return builder_.Finish();
}

/// The `PingRequest` gets sent from the server to the device
/// which then will respond to that ping with the `PingResponse` packet.
///
/// Can be used to measure RTT between the server and device.
struct PingRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PingRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PingRequestBuilder {
  typedef PingRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PingRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PingRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PingRequest> CreatePingRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PingRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PingResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PingResponseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PingResponseBuilder {
  typedef PingResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PingResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PingResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<PingResponse> CreatePingResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PingResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

}  // namespace device

namespace application {
namespace data_feed {
namespace tracker {

/// Describes all possible information about a tracker. A tracker is anything that
/// provides kinematic data about a particular body part.
///
/// Trackers may be synthetic/computed or instead part of an actual hardware device.
/// There can be multiple trackers per hardware device.
struct TrackerData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackerDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACKER_ID = 4,
    VT_INFO = 6,
    VT_STATUS = 8,
    VT_ROTATION = 10,
    VT_POSITION = 12,
    VT_RAW_ROT_VEL = 14,
    VT_RAW_TRANS_ACCEL = 16,
    VT_TEMP = 18
  };
  const solarxr_protocol::datatypes::TrackerId *tracker_id() const {
    return GetPointer<const solarxr_protocol::datatypes::TrackerId *>(VT_TRACKER_ID);
  }
  const solarxr_protocol::application::data_feed::tracker::TrackerInfo *info() const {
    return GetPointer<const solarxr_protocol::application::data_feed::tracker::TrackerInfo *>(VT_INFO);
  }
  solarxr_protocol::datatypes::TrackerStatus status() const {
    return static_cast<solarxr_protocol::datatypes::TrackerStatus>(GetField<uint8_t>(VT_STATUS, 0));
  }
  const solarxr_protocol::datatypes::math::Quat *rotation() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_ROTATION);
  }
  /// Position, in meters
  const solarxr_protocol::datatypes::math::Vec3f *position() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Vec3f *>(VT_POSITION);
  }
  /// Raw rotational velocity, in euler angles
  const solarxr_protocol::datatypes::math::Vec3f *raw_rot_vel() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Vec3f *>(VT_RAW_ROT_VEL);
  }
  /// Raw translational acceleration, in m/s^2
  const solarxr_protocol::datatypes::math::Vec3f *raw_trans_accel() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Vec3f *>(VT_RAW_TRANS_ACCEL);
  }
  /// Temperature in degrees celsius
  const solarxr_protocol::datatypes::Temperature *temp() const {
    return GetStruct<const solarxr_protocol::datatypes::Temperature *>(VT_TEMP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACKER_ID) &&
           verifier.VerifyTable(tracker_id()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_ROTATION, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Vec3f>(verifier, VT_POSITION, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Vec3f>(verifier, VT_RAW_ROT_VEL, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Vec3f>(verifier, VT_RAW_TRANS_ACCEL, 4) &&
           VerifyField<solarxr_protocol::datatypes::Temperature>(verifier, VT_TEMP, 4) &&
           verifier.EndTable();
  }
};

struct TrackerDataBuilder {
  typedef TrackerData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tracker_id(flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id) {
    fbb_.AddOffset(TrackerData::VT_TRACKER_ID, tracker_id);
  }
  void add_info(flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerInfo> info) {
    fbb_.AddOffset(TrackerData::VT_INFO, info);
  }
  void add_status(solarxr_protocol::datatypes::TrackerStatus status) {
    fbb_.AddElement<uint8_t>(TrackerData::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_rotation(const solarxr_protocol::datatypes::math::Quat *rotation) {
    fbb_.AddStruct(TrackerData::VT_ROTATION, rotation);
  }
  void add_position(const solarxr_protocol::datatypes::math::Vec3f *position) {
    fbb_.AddStruct(TrackerData::VT_POSITION, position);
  }
  void add_raw_rot_vel(const solarxr_protocol::datatypes::math::Vec3f *raw_rot_vel) {
    fbb_.AddStruct(TrackerData::VT_RAW_ROT_VEL, raw_rot_vel);
  }
  void add_raw_trans_accel(const solarxr_protocol::datatypes::math::Vec3f *raw_trans_accel) {
    fbb_.AddStruct(TrackerData::VT_RAW_TRANS_ACCEL, raw_trans_accel);
  }
  void add_temp(const solarxr_protocol::datatypes::Temperature *temp) {
    fbb_.AddStruct(TrackerData::VT_TEMP, temp);
  }
  explicit TrackerDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrackerData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackerData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackerData> CreateTrackerData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id = 0,
    flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerInfo> info = 0,
    solarxr_protocol::datatypes::TrackerStatus status = solarxr_protocol::datatypes::TrackerStatus::NONE,
    const solarxr_protocol::datatypes::math::Quat *rotation = nullptr,
    const solarxr_protocol::datatypes::math::Vec3f *position = nullptr,
    const solarxr_protocol::datatypes::math::Vec3f *raw_rot_vel = nullptr,
    const solarxr_protocol::datatypes::math::Vec3f *raw_trans_accel = nullptr,
    const solarxr_protocol::datatypes::Temperature *temp = nullptr) {
  TrackerDataBuilder builder_(_fbb);
  builder_.add_temp(temp);
  builder_.add_raw_trans_accel(raw_trans_accel);
  builder_.add_raw_rot_vel(raw_rot_vel);
  builder_.add_position(position);
  builder_.add_rotation(rotation);
  builder_.add_info(info);
  builder_.add_tracker_id(tracker_id);
  builder_.add_status(status);
  return builder_.Finish();
}

/// A mask of the different components in `TrackerComponent`
struct TrackerDataMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackerDataMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_STATUS = 6,
    VT_ROTATION = 8,
    VT_POSITION = 10,
    VT_RAW_ROT_VEL = 12,
    VT_RAW_TRANS_ACCEL = 14,
    VT_TEMP = 16
  };
  bool info() const {
    return GetField<uint8_t>(VT_INFO, 0) != 0;
  }
  bool status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  bool rotation() const {
    return GetField<uint8_t>(VT_ROTATION, 0) != 0;
  }
  bool position() const {
    return GetField<uint8_t>(VT_POSITION, 0) != 0;
  }
  bool raw_rot_vel() const {
    return GetField<uint8_t>(VT_RAW_ROT_VEL, 0) != 0;
  }
  bool raw_trans_accel() const {
    return GetField<uint8_t>(VT_RAW_TRANS_ACCEL, 0) != 0;
  }
  bool temp() const {
    return GetField<uint8_t>(VT_TEMP, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INFO, 1) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_ROTATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_POSITION, 1) &&
           VerifyField<uint8_t>(verifier, VT_RAW_ROT_VEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_RAW_TRANS_ACCEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_TEMP, 1) &&
           verifier.EndTable();
  }
};

struct TrackerDataMaskBuilder {
  typedef TrackerDataMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_info(bool info) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_INFO, static_cast<uint8_t>(info), 0);
  }
  void add_status(bool status) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_rotation(bool rotation) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_ROTATION, static_cast<uint8_t>(rotation), 0);
  }
  void add_position(bool position) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_POSITION, static_cast<uint8_t>(position), 0);
  }
  void add_raw_rot_vel(bool raw_rot_vel) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_RAW_ROT_VEL, static_cast<uint8_t>(raw_rot_vel), 0);
  }
  void add_raw_trans_accel(bool raw_trans_accel) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_RAW_TRANS_ACCEL, static_cast<uint8_t>(raw_trans_accel), 0);
  }
  void add_temp(bool temp) {
    fbb_.AddElement<uint8_t>(TrackerDataMask::VT_TEMP, static_cast<uint8_t>(temp), 0);
  }
  explicit TrackerDataMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrackerDataMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackerDataMask>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackerDataMask> CreateTrackerDataMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool info = false,
    bool status = false,
    bool rotation = false,
    bool position = false,
    bool raw_rot_vel = false,
    bool raw_trans_accel = false,
    bool temp = false) {
  TrackerDataMaskBuilder builder_(_fbb);
  builder_.add_temp(temp);
  builder_.add_raw_trans_accel(raw_trans_accel);
  builder_.add_raw_rot_vel(raw_rot_vel);
  builder_.add_position(position);
  builder_.add_rotation(rotation);
  builder_.add_status(status);
  builder_.add_info(info);
  return builder_.Finish();
}

/// Static description of a tracker
struct TrackerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMU_TYPE = 4,
    VT_BODY_PART = 6,
    VT_POLL_RATE = 8,
    VT_MOUNTING_ORIENTATION = 10,
    VT_EDITABLE = 12,
    VT_COMPUTED = 14,
    VT_DISPLAY_NAME = 16,
    VT_CUSTOM_NAME = 18
  };
  solarxr_protocol::datatypes::hardware_info::ImuType imu_type() const {
    return static_cast<solarxr_protocol::datatypes::hardware_info::ImuType>(GetField<uint16_t>(VT_IMU_TYPE, 0));
  }
  /// The user-assigned role of the tracker.
  solarxr_protocol::datatypes::BodyPart body_part() const {
    return static_cast<solarxr_protocol::datatypes::BodyPart>(GetField<uint8_t>(VT_BODY_PART, 0));
  }
  /// average samples per second
  const solarxr_protocol::datatypes::HzF32 *poll_rate() const {
    return GetStruct<const solarxr_protocol::datatypes::HzF32 *>(VT_POLL_RATE);
  }
  /// The orientation of the tracker when mounted on the body
  const solarxr_protocol::datatypes::math::Quat *mounting_orientation() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_MOUNTING_ORIENTATION);
  }
  bool editable() const {
    return GetField<uint8_t>(VT_EDITABLE, 0) != 0;
  }
  bool computed() const {
    return GetField<uint8_t>(VT_COMPUTED, 0) != 0;
  }
  /// A human-friendly name to display as the name of the tracker.
  const flatbuffers::String *display_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  /// name to display as the name of the tracker set by the user
  const flatbuffers::String *custom_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CUSTOM_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_IMU_TYPE, 2) &&
           VerifyField<uint8_t>(verifier, VT_BODY_PART, 1) &&
           VerifyField<solarxr_protocol::datatypes::HzF32>(verifier, VT_POLL_RATE, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_MOUNTING_ORIENTATION, 4) &&
           VerifyField<uint8_t>(verifier, VT_EDITABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_COMPUTED, 1) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyOffset(verifier, VT_CUSTOM_NAME) &&
           verifier.VerifyString(custom_name()) &&
           verifier.EndTable();
  }
};

struct TrackerInfoBuilder {
  typedef TrackerInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_imu_type(solarxr_protocol::datatypes::hardware_info::ImuType imu_type) {
    fbb_.AddElement<uint16_t>(TrackerInfo::VT_IMU_TYPE, static_cast<uint16_t>(imu_type), 0);
  }
  void add_body_part(solarxr_protocol::datatypes::BodyPart body_part) {
    fbb_.AddElement<uint8_t>(TrackerInfo::VT_BODY_PART, static_cast<uint8_t>(body_part), 0);
  }
  void add_poll_rate(const solarxr_protocol::datatypes::HzF32 *poll_rate) {
    fbb_.AddStruct(TrackerInfo::VT_POLL_RATE, poll_rate);
  }
  void add_mounting_orientation(const solarxr_protocol::datatypes::math::Quat *mounting_orientation) {
    fbb_.AddStruct(TrackerInfo::VT_MOUNTING_ORIENTATION, mounting_orientation);
  }
  void add_editable(bool editable) {
    fbb_.AddElement<uint8_t>(TrackerInfo::VT_EDITABLE, static_cast<uint8_t>(editable), 0);
  }
  void add_computed(bool computed) {
    fbb_.AddElement<uint8_t>(TrackerInfo::VT_COMPUTED, static_cast<uint8_t>(computed), 0);
  }
  void add_display_name(flatbuffers::Offset<flatbuffers::String> display_name) {
    fbb_.AddOffset(TrackerInfo::VT_DISPLAY_NAME, display_name);
  }
  void add_custom_name(flatbuffers::Offset<flatbuffers::String> custom_name) {
    fbb_.AddOffset(TrackerInfo::VT_CUSTOM_NAME, custom_name);
  }
  explicit TrackerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrackerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackerInfo> CreateTrackerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::hardware_info::ImuType imu_type = solarxr_protocol::datatypes::hardware_info::ImuType::Other,
    solarxr_protocol::datatypes::BodyPart body_part = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::HzF32 *poll_rate = nullptr,
    const solarxr_protocol::datatypes::math::Quat *mounting_orientation = nullptr,
    bool editable = false,
    bool computed = false,
    flatbuffers::Offset<flatbuffers::String> display_name = 0,
    flatbuffers::Offset<flatbuffers::String> custom_name = 0) {
  TrackerInfoBuilder builder_(_fbb);
  builder_.add_custom_name(custom_name);
  builder_.add_display_name(display_name);
  builder_.add_mounting_orientation(mounting_orientation);
  builder_.add_poll_rate(poll_rate);
  builder_.add_imu_type(imu_type);
  builder_.add_computed(computed);
  builder_.add_editable(editable);
  builder_.add_body_part(body_part);
  return builder_.Finish();
}

inline flatbuffers::Offset<TrackerInfo> CreateTrackerInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::hardware_info::ImuType imu_type = solarxr_protocol::datatypes::hardware_info::ImuType::Other,
    solarxr_protocol::datatypes::BodyPart body_part = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::HzF32 *poll_rate = nullptr,
    const solarxr_protocol::datatypes::math::Quat *mounting_orientation = nullptr,
    bool editable = false,
    bool computed = false,
    const char *display_name = nullptr,
    const char *custom_name = nullptr) {
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  auto custom_name__ = custom_name ? _fbb.CreateString(custom_name) : 0;
  return solarxr_protocol::application::data_feed::tracker::CreateTrackerInfo(
      _fbb,
      imu_type,
      body_part,
      poll_rate,
      mounting_orientation,
      editable,
      computed,
      display_name__,
      custom_name__);
}

}  // namespace tracker

namespace device_data {

/// A mask of values to be reported in subsequent DeviceStatus. Values set to `false`
/// or `null` will not reported. By default, all fields are false/null.
///
/// If you set a value to `true`, it is not guaranteed that the sender actually has
/// such a value to send. In this case, they will probably send `null`, and the receiver
/// has the choice to disconnect due to missing data.
struct DeviceDataMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceDataMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACKER_DATA = 4,
    VT_DEVICE_DATA = 6
  };
  /// Which tracker data should be sent in this data feed
  const solarxr_protocol::application::data_feed::tracker::TrackerDataMask *tracker_data() const {
    return GetPointer<const solarxr_protocol::application::data_feed::tracker::TrackerDataMask *>(VT_TRACKER_DATA);
  }
  /// true if device data should be sent in this data feed
  bool device_data() const {
    return GetField<uint8_t>(VT_DEVICE_DATA, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACKER_DATA) &&
           verifier.VerifyTable(tracker_data()) &&
           VerifyField<uint8_t>(verifier, VT_DEVICE_DATA, 1) &&
           verifier.EndTable();
  }
};

struct DeviceDataMaskBuilder {
  typedef DeviceDataMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tracker_data(flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerDataMask> tracker_data) {
    fbb_.AddOffset(DeviceDataMask::VT_TRACKER_DATA, tracker_data);
  }
  void add_device_data(bool device_data) {
    fbb_.AddElement<uint8_t>(DeviceDataMask::VT_DEVICE_DATA, static_cast<uint8_t>(device_data), 0);
  }
  explicit DeviceDataMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceDataMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceDataMask>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceDataMask> CreateDeviceDataMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerDataMask> tracker_data = 0,
    bool device_data = false) {
  DeviceDataMaskBuilder builder_(_fbb);
  builder_.add_tracker_data(tracker_data);
  builder_.add_device_data(device_data);
  return builder_.Finish();
}

/// Describes all possible information about a hardware device. For example, a
/// vive tracker is a  single hardware device, and a slime tracker with two
/// extensions is a single hardware device but two trackers.
struct DeviceData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeviceDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CUSTOM_NAME = 6,
    VT_HARDWARE_INFO = 8,
    VT_HARDWARE_STATUS = 10,
    VT_TRACKERS = 12
  };
  const solarxr_protocol::datatypes::DeviceId *id() const {
    return GetStruct<const solarxr_protocol::datatypes::DeviceId *>(VT_ID);
  }
  /// The dynamically changeable name of the device. This might be set by the
  /// user to help them remember which tracker is which.
  const flatbuffers::String *custom_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CUSTOM_NAME);
  }
  /// Mostly-static info about the device hardware
  const solarxr_protocol::datatypes::hardware_info::HardwareInfo *hardware_info() const {
    return GetPointer<const solarxr_protocol::datatypes::hardware_info::HardwareInfo *>(VT_HARDWARE_INFO);
  }
  /// General info about the status of the device
  const solarxr_protocol::datatypes::hardware_info::HardwareStatus *hardware_status() const {
    return GetPointer<const solarxr_protocol::datatypes::hardware_info::HardwareStatus *>(VT_HARDWARE_STATUS);
  }
  /// Info about all trackers attached to this device
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerData>> *trackers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerData>> *>(VT_TRACKERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<solarxr_protocol::datatypes::DeviceId>(verifier, VT_ID, 1) &&
           VerifyOffset(verifier, VT_CUSTOM_NAME) &&
           verifier.VerifyString(custom_name()) &&
           VerifyOffset(verifier, VT_HARDWARE_INFO) &&
           verifier.VerifyTable(hardware_info()) &&
           VerifyOffset(verifier, VT_HARDWARE_STATUS) &&
           verifier.VerifyTable(hardware_status()) &&
           VerifyOffset(verifier, VT_TRACKERS) &&
           verifier.VerifyVector(trackers()) &&
           verifier.VerifyVectorOfTables(trackers()) &&
           verifier.EndTable();
  }
};

struct DeviceDataBuilder {
  typedef DeviceData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(const solarxr_protocol::datatypes::DeviceId *id) {
    fbb_.AddStruct(DeviceData::VT_ID, id);
  }
  void add_custom_name(flatbuffers::Offset<flatbuffers::String> custom_name) {
    fbb_.AddOffset(DeviceData::VT_CUSTOM_NAME, custom_name);
  }
  void add_hardware_info(flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareInfo> hardware_info) {
    fbb_.AddOffset(DeviceData::VT_HARDWARE_INFO, hardware_info);
  }
  void add_hardware_status(flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareStatus> hardware_status) {
    fbb_.AddOffset(DeviceData::VT_HARDWARE_STATUS, hardware_status);
  }
  void add_trackers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerData>>> trackers) {
    fbb_.AddOffset(DeviceData::VT_TRACKERS, trackers);
  }
  explicit DeviceDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeviceData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceData> CreateDeviceData(
    flatbuffers::FlatBufferBuilder &_fbb,
    const solarxr_protocol::datatypes::DeviceId *id = nullptr,
    flatbuffers::Offset<flatbuffers::String> custom_name = 0,
    flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareInfo> hardware_info = 0,
    flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareStatus> hardware_status = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerData>>> trackers = 0) {
  DeviceDataBuilder builder_(_fbb);
  builder_.add_trackers(trackers);
  builder_.add_hardware_status(hardware_status);
  builder_.add_hardware_info(hardware_info);
  builder_.add_custom_name(custom_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceData> CreateDeviceDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const solarxr_protocol::datatypes::DeviceId *id = nullptr,
    const char *custom_name = nullptr,
    flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareInfo> hardware_info = 0,
    flatbuffers::Offset<solarxr_protocol::datatypes::hardware_info::HardwareStatus> hardware_status = 0,
    const std::vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerData>> *trackers = nullptr) {
  auto custom_name__ = custom_name ? _fbb.CreateString(custom_name) : 0;
  auto trackers__ = trackers ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerData>>(*trackers) : 0;
  return solarxr_protocol::application::data_feed::device_data::CreateDeviceData(
      _fbb,
      id,
      custom_name__,
      hardware_info,
      hardware_status,
      trackers__);
}

}  // namespace device_data

struct Bone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoneBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BODY_PART = 4,
    VT_ROTATION_G = 6,
    VT_BONE_LENGTH = 8,
    VT_HEAD_POSITION_G = 10
  };
  solarxr_protocol::datatypes::BodyPart body_part() const {
    return static_cast<solarxr_protocol::datatypes::BodyPart>(GetField<uint8_t>(VT_BODY_PART, 0));
  }
  /// The global rotation of the bone.
  ///
  /// Note that the identity rotation is where a bone's tail is towards -y (assuming
  /// the head of the bone is the origin)
  const solarxr_protocol::datatypes::math::Quat *rotation_g() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_ROTATION_G);
  }
  float bone_length() const {
    return GetField<float>(VT_BONE_LENGTH, 0.0f);
  }
  /// The global position of the head of this bone.
  ///
  /// The head of a bone is joint/node of the bone touching the parent bone. The
  /// parent is defined as the bone closer to the HMD.
  const solarxr_protocol::datatypes::math::Vec3f *head_position_g() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Vec3f *>(VT_HEAD_POSITION_G);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BODY_PART, 1) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_ROTATION_G, 4) &&
           VerifyField<float>(verifier, VT_BONE_LENGTH, 4) &&
           VerifyField<solarxr_protocol::datatypes::math::Vec3f>(verifier, VT_HEAD_POSITION_G, 4) &&
           verifier.EndTable();
  }
};

struct BoneBuilder {
  typedef Bone Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_body_part(solarxr_protocol::datatypes::BodyPart body_part) {
    fbb_.AddElement<uint8_t>(Bone::VT_BODY_PART, static_cast<uint8_t>(body_part), 0);
  }
  void add_rotation_g(const solarxr_protocol::datatypes::math::Quat *rotation_g) {
    fbb_.AddStruct(Bone::VT_ROTATION_G, rotation_g);
  }
  void add_bone_length(float bone_length) {
    fbb_.AddElement<float>(Bone::VT_BONE_LENGTH, bone_length, 0.0f);
  }
  void add_head_position_g(const solarxr_protocol::datatypes::math::Vec3f *head_position_g) {
    fbb_.AddStruct(Bone::VT_HEAD_POSITION_G, head_position_g);
  }
  explicit BoneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Bone> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bone>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bone> CreateBone(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::BodyPart body_part = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::math::Quat *rotation_g = nullptr,
    float bone_length = 0.0f,
    const solarxr_protocol::datatypes::math::Vec3f *head_position_g = nullptr) {
  BoneBuilder builder_(_fbb);
  builder_.add_head_position_g(head_position_g);
  builder_.add_bone_length(bone_length);
  builder_.add_rotation_g(rotation_g);
  builder_.add_body_part(body_part);
  return builder_.Finish();
}

struct DataFeedMessageHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataFeedMessageHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  solarxr_protocol::application::data_feed::DataFeedMessage message_type() const {
    return static_cast<solarxr_protocol::application::data_feed::DataFeedMessage>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const solarxr_protocol::application::data_feed::PollDataFeed *message_as_PollDataFeed() const {
    return message_type() == solarxr_protocol::application::data_feed::DataFeedMessage::PollDataFeed ? static_cast<const solarxr_protocol::application::data_feed::PollDataFeed *>(message()) : nullptr;
  }
  const solarxr_protocol::application::data_feed::StartDataFeed *message_as_StartDataFeed() const {
    return message_type() == solarxr_protocol::application::data_feed::DataFeedMessage::StartDataFeed ? static_cast<const solarxr_protocol::application::data_feed::StartDataFeed *>(message()) : nullptr;
  }
  const solarxr_protocol::application::data_feed::DataFeedUpdate *message_as_DataFeedUpdate() const {
    return message_type() == solarxr_protocol::application::data_feed::DataFeedMessage::DataFeedUpdate ? static_cast<const solarxr_protocol::application::data_feed::DataFeedUpdate *>(message()) : nullptr;
  }
  const solarxr_protocol::application::data_feed::DataFeedConfig *message_as_DataFeedConfig() const {
    return message_type() == solarxr_protocol::application::data_feed::DataFeedMessage::DataFeedConfig ? static_cast<const solarxr_protocol::application::data_feed::DataFeedConfig *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyDataFeedMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::application::data_feed::PollDataFeed *DataFeedMessageHeader::message_as<solarxr_protocol::application::data_feed::PollDataFeed>() const {
  return message_as_PollDataFeed();
}

template<> inline const solarxr_protocol::application::data_feed::StartDataFeed *DataFeedMessageHeader::message_as<solarxr_protocol::application::data_feed::StartDataFeed>() const {
  return message_as_StartDataFeed();
}

template<> inline const solarxr_protocol::application::data_feed::DataFeedUpdate *DataFeedMessageHeader::message_as<solarxr_protocol::application::data_feed::DataFeedUpdate>() const {
  return message_as_DataFeedUpdate();
}

template<> inline const solarxr_protocol::application::data_feed::DataFeedConfig *DataFeedMessageHeader::message_as<solarxr_protocol::application::data_feed::DataFeedConfig>() const {
  return message_as_DataFeedConfig();
}

struct DataFeedMessageHeaderBuilder {
  typedef DataFeedMessageHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(solarxr_protocol::application::data_feed::DataFeedMessage message_type) {
    fbb_.AddElement<uint8_t>(DataFeedMessageHeader::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(DataFeedMessageHeader::VT_MESSAGE, message);
  }
  explicit DataFeedMessageHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataFeedMessageHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFeedMessageHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFeedMessageHeader> CreateDataFeedMessageHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::application::data_feed::DataFeedMessage message_type = solarxr_protocol::application::data_feed::DataFeedMessage::NONE,
    flatbuffers::Offset<void> message = 0) {
  DataFeedMessageHeaderBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

/// Requests for a single `Update` to be sent. This is helpful when getting
/// initial info about the device.
struct PollDataFeed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PollDataFeedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIG = 4
  };
  const solarxr_protocol::application::data_feed::DataFeedConfig *config() const {
    return GetPointer<const solarxr_protocol::application::data_feed::DataFeedConfig *>(VT_CONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           verifier.EndTable();
  }
};

struct PollDataFeedBuilder {
  typedef PollDataFeed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_config(flatbuffers::Offset<solarxr_protocol::application::data_feed::DataFeedConfig> config) {
    fbb_.AddOffset(PollDataFeed::VT_CONFIG, config);
  }
  explicit PollDataFeedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PollDataFeed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PollDataFeed>(end);
    return o;
  }
};

inline flatbuffers::Offset<PollDataFeed> CreatePollDataFeed(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::application::data_feed::DataFeedConfig> config = 0) {
  PollDataFeedBuilder builder_(_fbb);
  builder_.add_config(config);
  return builder_.Finish();
}

/// Requests for the other party to send `data_feeds`.
/// For example, GUI requests for position data to be sent from server.
///
/// When sending a new `StartFeed`, the old data feeds should stop being sent.
/// We still support multiple data feeds at the same time, because `data_feeds`
/// is a list.
///
/// Multiple data feeds are useful to get data at different frequencies.
struct StartDataFeed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StartDataFeedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_FEEDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::DataFeedConfig>> *data_feeds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::DataFeedConfig>> *>(VT_DATA_FEEDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA_FEEDS) &&
           verifier.VerifyVector(data_feeds()) &&
           verifier.VerifyVectorOfTables(data_feeds()) &&
           verifier.EndTable();
  }
};

struct StartDataFeedBuilder {
  typedef StartDataFeed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_feeds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::DataFeedConfig>>> data_feeds) {
    fbb_.AddOffset(StartDataFeed::VT_DATA_FEEDS, data_feeds);
  }
  explicit StartDataFeedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StartDataFeed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartDataFeed>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartDataFeed> CreateStartDataFeed(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::DataFeedConfig>>> data_feeds = 0) {
  StartDataFeedBuilder builder_(_fbb);
  builder_.add_data_feeds(data_feeds);
  return builder_.Finish();
}

inline flatbuffers::Offset<StartDataFeed> CreateStartDataFeedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::DataFeedConfig>> *data_feeds = nullptr) {
  auto data_feeds__ = data_feeds ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::application::data_feed::DataFeedConfig>>(*data_feeds) : 0;
  return solarxr_protocol::application::data_feed::CreateStartDataFeed(
      _fbb,
      data_feeds__);
}

/// All of the data components related to a single data feed. A data feed is comprised
/// of device data, and tracker data.
///
/// A data feed might send data only when it changes/updates, and we should make no
/// assumptions that the data is actually delivered. If you want to guarantee
/// delivery and avoid dropped observations of data (such as a user-initiated
/// button press), it is better to use the RPC system.
struct DataFeedUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataFeedUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICES = 4,
    VT_SYNTHETIC_TRACKERS = 6,
    VT_BONES = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::device_data::DeviceData>> *devices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::device_data::DeviceData>> *>(VT_DEVICES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerData>> *synthetic_trackers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerData>> *>(VT_SYNTHETIC_TRACKERS);
  }
  /// This must represent a set, where there is no more than one bone for a `BodyPart`.
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::Bone>> *bones() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::Bone>> *>(VT_BONES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICES) &&
           verifier.VerifyVector(devices()) &&
           verifier.VerifyVectorOfTables(devices()) &&
           VerifyOffset(verifier, VT_SYNTHETIC_TRACKERS) &&
           verifier.VerifyVector(synthetic_trackers()) &&
           verifier.VerifyVectorOfTables(synthetic_trackers()) &&
           VerifyOffset(verifier, VT_BONES) &&
           verifier.VerifyVector(bones()) &&
           verifier.VerifyVectorOfTables(bones()) &&
           verifier.EndTable();
  }
};

struct DataFeedUpdateBuilder {
  typedef DataFeedUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_devices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::device_data::DeviceData>>> devices) {
    fbb_.AddOffset(DataFeedUpdate::VT_DEVICES, devices);
  }
  void add_synthetic_trackers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerData>>> synthetic_trackers) {
    fbb_.AddOffset(DataFeedUpdate::VT_SYNTHETIC_TRACKERS, synthetic_trackers);
  }
  void add_bones(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::Bone>>> bones) {
    fbb_.AddOffset(DataFeedUpdate::VT_BONES, bones);
  }
  explicit DataFeedUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataFeedUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFeedUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFeedUpdate> CreateDataFeedUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::device_data::DeviceData>>> devices = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerData>>> synthetic_trackers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::Bone>>> bones = 0) {
  DataFeedUpdateBuilder builder_(_fbb);
  builder_.add_bones(bones);
  builder_.add_synthetic_trackers(synthetic_trackers);
  builder_.add_devices(devices);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataFeedUpdate> CreateDataFeedUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::device_data::DeviceData>> *devices = nullptr,
    const std::vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerData>> *synthetic_trackers = nullptr,
    const std::vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::Bone>> *bones = nullptr) {
  auto devices__ = devices ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::application::data_feed::device_data::DeviceData>>(*devices) : 0;
  auto synthetic_trackers__ = synthetic_trackers ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerData>>(*synthetic_trackers) : 0;
  auto bones__ = bones ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::application::data_feed::Bone>>(*bones) : 0;
  return solarxr_protocol::application::data_feed::CreateDataFeedUpdate(
      _fbb,
      devices__,
      synthetic_trackers__,
      bones__);
}

/// All information related to the configuration of a data feed. This may be sent
/// as part of a `StartFeed`.
struct DataFeedConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataFeedConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINIMUM_TIME_SINCE_LAST = 4,
    VT_DATA_MASK = 6,
    VT_SYNTHETIC_TRACKERS_MASK = 8,
    VT_BONE_MASK = 10
  };
  /// Minimum delay in milliseconds between new data updates. This value will be
  /// ignored when used for a `PollDataFeed`.
  uint16_t minimum_time_since_last() const {
    return GetField<uint16_t>(VT_MINIMUM_TIME_SINCE_LAST, 0);
  }
  const solarxr_protocol::application::data_feed::device_data::DeviceDataMask *data_mask() const {
    return GetPointer<const solarxr_protocol::application::data_feed::device_data::DeviceDataMask *>(VT_DATA_MASK);
  }
  const solarxr_protocol::application::data_feed::tracker::TrackerDataMask *synthetic_trackers_mask() const {
    return GetPointer<const solarxr_protocol::application::data_feed::tracker::TrackerDataMask *>(VT_SYNTHETIC_TRACKERS_MASK);
  }
  bool bone_mask() const {
    return GetField<uint8_t>(VT_BONE_MASK, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MINIMUM_TIME_SINCE_LAST, 2) &&
           VerifyOffset(verifier, VT_DATA_MASK) &&
           verifier.VerifyTable(data_mask()) &&
           VerifyOffset(verifier, VT_SYNTHETIC_TRACKERS_MASK) &&
           verifier.VerifyTable(synthetic_trackers_mask()) &&
           VerifyField<uint8_t>(verifier, VT_BONE_MASK, 1) &&
           verifier.EndTable();
  }
};

struct DataFeedConfigBuilder {
  typedef DataFeedConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_minimum_time_since_last(uint16_t minimum_time_since_last) {
    fbb_.AddElement<uint16_t>(DataFeedConfig::VT_MINIMUM_TIME_SINCE_LAST, minimum_time_since_last, 0);
  }
  void add_data_mask(flatbuffers::Offset<solarxr_protocol::application::data_feed::device_data::DeviceDataMask> data_mask) {
    fbb_.AddOffset(DataFeedConfig::VT_DATA_MASK, data_mask);
  }
  void add_synthetic_trackers_mask(flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerDataMask> synthetic_trackers_mask) {
    fbb_.AddOffset(DataFeedConfig::VT_SYNTHETIC_TRACKERS_MASK, synthetic_trackers_mask);
  }
  void add_bone_mask(bool bone_mask) {
    fbb_.AddElement<uint8_t>(DataFeedConfig::VT_BONE_MASK, static_cast<uint8_t>(bone_mask), 0);
  }
  explicit DataFeedConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataFeedConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFeedConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFeedConfig> CreateDataFeedConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t minimum_time_since_last = 0,
    flatbuffers::Offset<solarxr_protocol::application::data_feed::device_data::DeviceDataMask> data_mask = 0,
    flatbuffers::Offset<solarxr_protocol::application::data_feed::tracker::TrackerDataMask> synthetic_trackers_mask = 0,
    bool bone_mask = false) {
  DataFeedConfigBuilder builder_(_fbb);
  builder_.add_synthetic_trackers_mask(synthetic_trackers_mask);
  builder_.add_data_mask(data_mask);
  builder_.add_minimum_time_since_last(minimum_time_since_last);
  builder_.add_bone_mask(bone_mask);
  return builder_.Finish();
}

}  // namespace data_feed

namespace rpc {
namespace settings {

/// Settings for the skeletal model that are toggles.
struct ModelToggles FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelTogglesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXTENDED_SPINE = 4,
    VT_EXTENDED_PELVIS = 6,
    VT_EXTENDED_KNEE = 8,
    VT_FORCE_ARMS_FROM_HMD = 10,
    VT_FLOOR_CLIP = 12,
    VT_SKATING_CORRECTION = 14
  };
  flatbuffers::Optional<bool> extended_spine() const {
    return GetOptional<uint8_t, bool>(VT_EXTENDED_SPINE);
  }
  flatbuffers::Optional<bool> extended_pelvis() const {
    return GetOptional<uint8_t, bool>(VT_EXTENDED_PELVIS);
  }
  flatbuffers::Optional<bool> extended_knee() const {
    return GetOptional<uint8_t, bool>(VT_EXTENDED_KNEE);
  }
  flatbuffers::Optional<bool> force_arms_from_hmd() const {
    return GetOptional<uint8_t, bool>(VT_FORCE_ARMS_FROM_HMD);
  }
  flatbuffers::Optional<bool> floor_clip() const {
    return GetOptional<uint8_t, bool>(VT_FLOOR_CLIP);
  }
  flatbuffers::Optional<bool> skating_correction() const {
    return GetOptional<uint8_t, bool>(VT_SKATING_CORRECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXTENDED_SPINE, 1) &&
           VerifyField<uint8_t>(verifier, VT_EXTENDED_PELVIS, 1) &&
           VerifyField<uint8_t>(verifier, VT_EXTENDED_KNEE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FORCE_ARMS_FROM_HMD, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLOOR_CLIP, 1) &&
           VerifyField<uint8_t>(verifier, VT_SKATING_CORRECTION, 1) &&
           verifier.EndTable();
  }
};

struct ModelTogglesBuilder {
  typedef ModelToggles Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_extended_spine(bool extended_spine) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_EXTENDED_SPINE, static_cast<uint8_t>(extended_spine));
  }
  void add_extended_pelvis(bool extended_pelvis) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_EXTENDED_PELVIS, static_cast<uint8_t>(extended_pelvis));
  }
  void add_extended_knee(bool extended_knee) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_EXTENDED_KNEE, static_cast<uint8_t>(extended_knee));
  }
  void add_force_arms_from_hmd(bool force_arms_from_hmd) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_FORCE_ARMS_FROM_HMD, static_cast<uint8_t>(force_arms_from_hmd));
  }
  void add_floor_clip(bool floor_clip) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_FLOOR_CLIP, static_cast<uint8_t>(floor_clip));
  }
  void add_skating_correction(bool skating_correction) {
    fbb_.AddElement<uint8_t>(ModelToggles::VT_SKATING_CORRECTION, static_cast<uint8_t>(skating_correction));
  }
  explicit ModelTogglesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ModelToggles> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelToggles>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelToggles> CreateModelToggles(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<bool> extended_spine = flatbuffers::nullopt,
    flatbuffers::Optional<bool> extended_pelvis = flatbuffers::nullopt,
    flatbuffers::Optional<bool> extended_knee = flatbuffers::nullopt,
    flatbuffers::Optional<bool> force_arms_from_hmd = flatbuffers::nullopt,
    flatbuffers::Optional<bool> floor_clip = flatbuffers::nullopt,
    flatbuffers::Optional<bool> skating_correction = flatbuffers::nullopt) {
  ModelTogglesBuilder builder_(_fbb);
  if(skating_correction) { builder_.add_skating_correction(*skating_correction); }
  if(floor_clip) { builder_.add_floor_clip(*floor_clip); }
  if(force_arms_from_hmd) { builder_.add_force_arms_from_hmd(*force_arms_from_hmd); }
  if(extended_knee) { builder_.add_extended_knee(*extended_knee); }
  if(extended_pelvis) { builder_.add_extended_pelvis(*extended_pelvis); }
  if(extended_spine) { builder_.add_extended_spine(*extended_spine); }
  return builder_.Finish();
}

/// Settings for the skeletal model that are ratios.
/// These values range from 0 to 1.
struct ModelRatios FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelRatiosBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMPUTE_WAIST_FROM_CHEST_HIP = 4,
    VT_IMPUTE_WAIST_FROM_CHEST_LEGS = 6,
    VT_IMPUTE_HIP_FROM_CHEST_LEGS = 8,
    VT_IMPUTE_HIP_FROM_WAIST_LEGS = 10,
    VT_INTERP_HIP_LEGS = 12,
    VT_INTERP_KNEE_TRACKER_ANKLE = 14
  };
  flatbuffers::Optional<float> impute_waist_from_chest_hip() const {
    return GetOptional<float, float>(VT_IMPUTE_WAIST_FROM_CHEST_HIP);
  }
  flatbuffers::Optional<float> impute_waist_from_chest_legs() const {
    return GetOptional<float, float>(VT_IMPUTE_WAIST_FROM_CHEST_LEGS);
  }
  flatbuffers::Optional<float> impute_hip_from_chest_legs() const {
    return GetOptional<float, float>(VT_IMPUTE_HIP_FROM_CHEST_LEGS);
  }
  flatbuffers::Optional<float> impute_hip_from_waist_legs() const {
    return GetOptional<float, float>(VT_IMPUTE_HIP_FROM_WAIST_LEGS);
  }
  /// Hip's yaw and roll is set to the average of legs when 1.0
  flatbuffers::Optional<float> interp_hip_legs() const {
    return GetOptional<float, float>(VT_INTERP_HIP_LEGS);
  }
  /// Knee trackers' yaw and roll is set to the ankle's when 1.0
  flatbuffers::Optional<float> interp_knee_tracker_ankle() const {
    return GetOptional<float, float>(VT_INTERP_KNEE_TRACKER_ANKLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_IMPUTE_WAIST_FROM_CHEST_HIP, 4) &&
           VerifyField<float>(verifier, VT_IMPUTE_WAIST_FROM_CHEST_LEGS, 4) &&
           VerifyField<float>(verifier, VT_IMPUTE_HIP_FROM_CHEST_LEGS, 4) &&
           VerifyField<float>(verifier, VT_IMPUTE_HIP_FROM_WAIST_LEGS, 4) &&
           VerifyField<float>(verifier, VT_INTERP_HIP_LEGS, 4) &&
           VerifyField<float>(verifier, VT_INTERP_KNEE_TRACKER_ANKLE, 4) &&
           verifier.EndTable();
  }
};

struct ModelRatiosBuilder {
  typedef ModelRatios Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_impute_waist_from_chest_hip(float impute_waist_from_chest_hip) {
    fbb_.AddElement<float>(ModelRatios::VT_IMPUTE_WAIST_FROM_CHEST_HIP, impute_waist_from_chest_hip);
  }
  void add_impute_waist_from_chest_legs(float impute_waist_from_chest_legs) {
    fbb_.AddElement<float>(ModelRatios::VT_IMPUTE_WAIST_FROM_CHEST_LEGS, impute_waist_from_chest_legs);
  }
  void add_impute_hip_from_chest_legs(float impute_hip_from_chest_legs) {
    fbb_.AddElement<float>(ModelRatios::VT_IMPUTE_HIP_FROM_CHEST_LEGS, impute_hip_from_chest_legs);
  }
  void add_impute_hip_from_waist_legs(float impute_hip_from_waist_legs) {
    fbb_.AddElement<float>(ModelRatios::VT_IMPUTE_HIP_FROM_WAIST_LEGS, impute_hip_from_waist_legs);
  }
  void add_interp_hip_legs(float interp_hip_legs) {
    fbb_.AddElement<float>(ModelRatios::VT_INTERP_HIP_LEGS, interp_hip_legs);
  }
  void add_interp_knee_tracker_ankle(float interp_knee_tracker_ankle) {
    fbb_.AddElement<float>(ModelRatios::VT_INTERP_KNEE_TRACKER_ANKLE, interp_knee_tracker_ankle);
  }
  explicit ModelRatiosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ModelRatios> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelRatios>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelRatios> CreateModelRatios(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<float> impute_waist_from_chest_hip = flatbuffers::nullopt,
    flatbuffers::Optional<float> impute_waist_from_chest_legs = flatbuffers::nullopt,
    flatbuffers::Optional<float> impute_hip_from_chest_legs = flatbuffers::nullopt,
    flatbuffers::Optional<float> impute_hip_from_waist_legs = flatbuffers::nullopt,
    flatbuffers::Optional<float> interp_hip_legs = flatbuffers::nullopt,
    flatbuffers::Optional<float> interp_knee_tracker_ankle = flatbuffers::nullopt) {
  ModelRatiosBuilder builder_(_fbb);
  if(interp_knee_tracker_ankle) { builder_.add_interp_knee_tracker_ankle(*interp_knee_tracker_ankle); }
  if(interp_hip_legs) { builder_.add_interp_hip_legs(*interp_hip_legs); }
  if(impute_hip_from_waist_legs) { builder_.add_impute_hip_from_waist_legs(*impute_hip_from_waist_legs); }
  if(impute_hip_from_chest_legs) { builder_.add_impute_hip_from_chest_legs(*impute_hip_from_chest_legs); }
  if(impute_waist_from_chest_legs) { builder_.add_impute_waist_from_chest_legs(*impute_waist_from_chest_legs); }
  if(impute_waist_from_chest_hip) { builder_.add_impute_waist_from_chest_hip(*impute_waist_from_chest_hip); }
  return builder_.Finish();
}

/// Settings for the skeletal model.
struct ModelSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOGGLES = 4,
    VT_RATIOS = 6
  };
  const solarxr_protocol::application::rpc::settings::ModelToggles *toggles() const {
    return GetPointer<const solarxr_protocol::application::rpc::settings::ModelToggles *>(VT_TOGGLES);
  }
  const solarxr_protocol::application::rpc::settings::ModelRatios *ratios() const {
    return GetPointer<const solarxr_protocol::application::rpc::settings::ModelRatios *>(VT_RATIOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOGGLES) &&
           verifier.VerifyTable(toggles()) &&
           VerifyOffset(verifier, VT_RATIOS) &&
           verifier.VerifyTable(ratios()) &&
           verifier.EndTable();
  }
};

struct ModelSettingsBuilder {
  typedef ModelSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_toggles(flatbuffers::Offset<solarxr_protocol::application::rpc::settings::ModelToggles> toggles) {
    fbb_.AddOffset(ModelSettings::VT_TOGGLES, toggles);
  }
  void add_ratios(flatbuffers::Offset<solarxr_protocol::application::rpc::settings::ModelRatios> ratios) {
    fbb_.AddOffset(ModelSettings::VT_RATIOS, ratios);
  }
  explicit ModelSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ModelSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModelSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModelSettings> CreateModelSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::application::rpc::settings::ModelToggles> toggles = 0,
    flatbuffers::Offset<solarxr_protocol::application::rpc::settings::ModelRatios> ratios = 0) {
  ModelSettingsBuilder builder_(_fbb);
  builder_.add_ratios(ratios);
  builder_.add_toggles(toggles);
  return builder_.Finish();
}

}  // namespace settings

struct RpcMessageHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RpcMessageHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TX_ID = 4,
    VT_MESSAGE_TYPE = 6,
    VT_MESSAGE = 8
  };
  /// For a request, this identifies the request. For a response, this corresponds
  /// to the request that it is responding to.
  const solarxr_protocol::datatypes::TransactionId *tx_id() const {
    return GetStruct<const solarxr_protocol::datatypes::TransactionId *>(VT_TX_ID);
  }
  solarxr_protocol::application::rpc::RpcMessage message_type() const {
    return static_cast<solarxr_protocol::application::rpc::RpcMessage>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const solarxr_protocol::application::rpc::HeartbeatRequest *message_as_HeartbeatRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::HeartbeatRequest ? static_cast<const solarxr_protocol::application::rpc::HeartbeatRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::HeartbeatResponse *message_as_HeartbeatResponse() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::HeartbeatResponse ? static_cast<const solarxr_protocol::application::rpc::HeartbeatResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::ResetRequest *message_as_ResetRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::ResetRequest ? static_cast<const solarxr_protocol::application::rpc::ResetRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::AssignTrackerRequest *message_as_AssignTrackerRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::AssignTrackerRequest ? static_cast<const solarxr_protocol::application::rpc::AssignTrackerRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::SettingsRequest *message_as_SettingsRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::SettingsRequest ? static_cast<const solarxr_protocol::application::rpc::SettingsRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::SettingsResponse *message_as_SettingsResponse() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::SettingsResponse ? static_cast<const solarxr_protocol::application::rpc::SettingsResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::ChangeSettingsRequest *message_as_ChangeSettingsRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::ChangeSettingsRequest ? static_cast<const solarxr_protocol::application::rpc::ChangeSettingsRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::RecordBVHRequest *message_as_RecordBVHRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::RecordBVHRequest ? static_cast<const solarxr_protocol::application::rpc::RecordBVHRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::RecordBVHStatus *message_as_RecordBVHStatus() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::RecordBVHStatus ? static_cast<const solarxr_protocol::application::rpc::RecordBVHStatus *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::SkeletonConfigRequest *message_as_SkeletonConfigRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::SkeletonConfigRequest ? static_cast<const solarxr_protocol::application::rpc::SkeletonConfigRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::ChangeSkeletonConfigRequest *message_as_ChangeSkeletonConfigRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::ChangeSkeletonConfigRequest ? static_cast<const solarxr_protocol::application::rpc::ChangeSkeletonConfigRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::SkeletonResetAllRequest *message_as_SkeletonResetAllRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::SkeletonResetAllRequest ? static_cast<const solarxr_protocol::application::rpc::SkeletonResetAllRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::SkeletonConfigResponse *message_as_SkeletonConfigResponse() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::SkeletonConfigResponse ? static_cast<const solarxr_protocol::application::rpc::SkeletonConfigResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::OpenSerialRequest *message_as_OpenSerialRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::OpenSerialRequest ? static_cast<const solarxr_protocol::application::rpc::OpenSerialRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::CloseSerialRequest *message_as_CloseSerialRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::CloseSerialRequest ? static_cast<const solarxr_protocol::application::rpc::CloseSerialRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::SetWifiRequest *message_as_SetWifiRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::SetWifiRequest ? static_cast<const solarxr_protocol::application::rpc::SetWifiRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::SerialUpdateResponse *message_as_SerialUpdateResponse() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::SerialUpdateResponse ? static_cast<const solarxr_protocol::application::rpc::SerialUpdateResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::AutoBoneProcessRequest *message_as_AutoBoneProcessRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::AutoBoneProcessRequest ? static_cast<const solarxr_protocol::application::rpc::AutoBoneProcessRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::AutoBoneProcessStatusResponse *message_as_AutoBoneProcessStatusResponse() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::AutoBoneProcessStatusResponse ? static_cast<const solarxr_protocol::application::rpc::AutoBoneProcessStatusResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::AutoBoneEpochResponse *message_as_AutoBoneEpochResponse() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::AutoBoneEpochResponse ? static_cast<const solarxr_protocol::application::rpc::AutoBoneEpochResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::OverlayDisplayModeRequest *message_as_OverlayDisplayModeRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::OverlayDisplayModeRequest ? static_cast<const solarxr_protocol::application::rpc::OverlayDisplayModeRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::OverlayDisplayModeChangeRequest *message_as_OverlayDisplayModeChangeRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::OverlayDisplayModeChangeRequest ? static_cast<const solarxr_protocol::application::rpc::OverlayDisplayModeChangeRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::OverlayDisplayModeResponse *message_as_OverlayDisplayModeResponse() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::OverlayDisplayModeResponse ? static_cast<const solarxr_protocol::application::rpc::OverlayDisplayModeResponse *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::SerialTrackerRebootRequest *message_as_SerialTrackerRebootRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::SerialTrackerRebootRequest ? static_cast<const solarxr_protocol::application::rpc::SerialTrackerRebootRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::SerialTrackerGetInfoRequest *message_as_SerialTrackerGetInfoRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::SerialTrackerGetInfoRequest ? static_cast<const solarxr_protocol::application::rpc::SerialTrackerGetInfoRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::SerialTrackerFactoryResetRequest *message_as_SerialTrackerFactoryResetRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::SerialTrackerFactoryResetRequest ? static_cast<const solarxr_protocol::application::rpc::SerialTrackerFactoryResetRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::DetectedDevicesRequest *message_as_DetectedDevicesRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::DetectedDevicesRequest ? static_cast<const solarxr_protocol::application::rpc::DetectedDevicesRequest *>(message()) : nullptr;
  }
  const solarxr_protocol::application::rpc::PairDeviceRequest *message_as_PairDeviceRequest() const {
    return message_type() == solarxr_protocol::application::rpc::RpcMessage::PairDeviceRequest ? static_cast<const solarxr_protocol::application::rpc::PairDeviceRequest *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<solarxr_protocol::datatypes::TransactionId>(verifier, VT_TX_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyRpcMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::application::rpc::HeartbeatRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::HeartbeatRequest>() const {
  return message_as_HeartbeatRequest();
}

template<> inline const solarxr_protocol::application::rpc::HeartbeatResponse *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::HeartbeatResponse>() const {
  return message_as_HeartbeatResponse();
}

template<> inline const solarxr_protocol::application::rpc::ResetRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::ResetRequest>() const {
  return message_as_ResetRequest();
}

template<> inline const solarxr_protocol::application::rpc::AssignTrackerRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::AssignTrackerRequest>() const {
  return message_as_AssignTrackerRequest();
}

template<> inline const solarxr_protocol::application::rpc::SettingsRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::SettingsRequest>() const {
  return message_as_SettingsRequest();
}

template<> inline const solarxr_protocol::application::rpc::SettingsResponse *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::SettingsResponse>() const {
  return message_as_SettingsResponse();
}

template<> inline const solarxr_protocol::application::rpc::ChangeSettingsRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::ChangeSettingsRequest>() const {
  return message_as_ChangeSettingsRequest();
}

template<> inline const solarxr_protocol::application::rpc::RecordBVHRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::RecordBVHRequest>() const {
  return message_as_RecordBVHRequest();
}

template<> inline const solarxr_protocol::application::rpc::RecordBVHStatus *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::RecordBVHStatus>() const {
  return message_as_RecordBVHStatus();
}

template<> inline const solarxr_protocol::application::rpc::SkeletonConfigRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::SkeletonConfigRequest>() const {
  return message_as_SkeletonConfigRequest();
}

template<> inline const solarxr_protocol::application::rpc::ChangeSkeletonConfigRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::ChangeSkeletonConfigRequest>() const {
  return message_as_ChangeSkeletonConfigRequest();
}

template<> inline const solarxr_protocol::application::rpc::SkeletonResetAllRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::SkeletonResetAllRequest>() const {
  return message_as_SkeletonResetAllRequest();
}

template<> inline const solarxr_protocol::application::rpc::SkeletonConfigResponse *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::SkeletonConfigResponse>() const {
  return message_as_SkeletonConfigResponse();
}

template<> inline const solarxr_protocol::application::rpc::OpenSerialRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::OpenSerialRequest>() const {
  return message_as_OpenSerialRequest();
}

template<> inline const solarxr_protocol::application::rpc::CloseSerialRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::CloseSerialRequest>() const {
  return message_as_CloseSerialRequest();
}

template<> inline const solarxr_protocol::application::rpc::SetWifiRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::SetWifiRequest>() const {
  return message_as_SetWifiRequest();
}

template<> inline const solarxr_protocol::application::rpc::SerialUpdateResponse *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::SerialUpdateResponse>() const {
  return message_as_SerialUpdateResponse();
}

template<> inline const solarxr_protocol::application::rpc::AutoBoneProcessRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::AutoBoneProcessRequest>() const {
  return message_as_AutoBoneProcessRequest();
}

template<> inline const solarxr_protocol::application::rpc::AutoBoneProcessStatusResponse *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::AutoBoneProcessStatusResponse>() const {
  return message_as_AutoBoneProcessStatusResponse();
}

template<> inline const solarxr_protocol::application::rpc::AutoBoneEpochResponse *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::AutoBoneEpochResponse>() const {
  return message_as_AutoBoneEpochResponse();
}

template<> inline const solarxr_protocol::application::rpc::OverlayDisplayModeRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::OverlayDisplayModeRequest>() const {
  return message_as_OverlayDisplayModeRequest();
}

template<> inline const solarxr_protocol::application::rpc::OverlayDisplayModeChangeRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::OverlayDisplayModeChangeRequest>() const {
  return message_as_OverlayDisplayModeChangeRequest();
}

template<> inline const solarxr_protocol::application::rpc::OverlayDisplayModeResponse *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::OverlayDisplayModeResponse>() const {
  return message_as_OverlayDisplayModeResponse();
}

template<> inline const solarxr_protocol::application::rpc::SerialTrackerRebootRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::SerialTrackerRebootRequest>() const {
  return message_as_SerialTrackerRebootRequest();
}

template<> inline const solarxr_protocol::application::rpc::SerialTrackerGetInfoRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::SerialTrackerGetInfoRequest>() const {
  return message_as_SerialTrackerGetInfoRequest();
}

template<> inline const solarxr_protocol::application::rpc::SerialTrackerFactoryResetRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::SerialTrackerFactoryResetRequest>() const {
  return message_as_SerialTrackerFactoryResetRequest();
}

template<> inline const solarxr_protocol::application::rpc::DetectedDevicesRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::DetectedDevicesRequest>() const {
  return message_as_DetectedDevicesRequest();
}

template<> inline const solarxr_protocol::application::rpc::PairDeviceRequest *RpcMessageHeader::message_as<solarxr_protocol::application::rpc::PairDeviceRequest>() const {
  return message_as_PairDeviceRequest();
}

struct RpcMessageHeaderBuilder {
  typedef RpcMessageHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tx_id(const solarxr_protocol::datatypes::TransactionId *tx_id) {
    fbb_.AddStruct(RpcMessageHeader::VT_TX_ID, tx_id);
  }
  void add_message_type(solarxr_protocol::application::rpc::RpcMessage message_type) {
    fbb_.AddElement<uint8_t>(RpcMessageHeader::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(RpcMessageHeader::VT_MESSAGE, message);
  }
  explicit RpcMessageHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RpcMessageHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RpcMessageHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<RpcMessageHeader> CreateRpcMessageHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    const solarxr_protocol::datatypes::TransactionId *tx_id = nullptr,
    solarxr_protocol::application::rpc::RpcMessage message_type = solarxr_protocol::application::rpc::RpcMessage::NONE,
    flatbuffers::Offset<void> message = 0) {
  RpcMessageHeaderBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_tx_id(tx_id);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct HeartbeatRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeartbeatRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HeartbeatRequestBuilder {
  typedef HeartbeatRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HeartbeatRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HeartbeatRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeartbeatRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeartbeatRequest> CreateHeartbeatRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HeartbeatRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HeartbeatResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeartbeatResponseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HeartbeatResponseBuilder {
  typedef HeartbeatResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HeartbeatResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HeartbeatResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeartbeatResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeartbeatResponse> CreateHeartbeatResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HeartbeatResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ResetRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResetRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESET_TYPE = 4
  };
  solarxr_protocol::application::rpc::ResetType reset_type() const {
    return static_cast<solarxr_protocol::application::rpc::ResetType>(GetField<uint8_t>(VT_RESET_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESET_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct ResetRequestBuilder {
  typedef ResetRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reset_type(solarxr_protocol::application::rpc::ResetType reset_type) {
    fbb_.AddElement<uint8_t>(ResetRequest::VT_RESET_TYPE, static_cast<uint8_t>(reset_type), 0);
  }
  explicit ResetRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResetRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResetRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResetRequest> CreateResetRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::application::rpc::ResetType reset_type = solarxr_protocol::application::rpc::ResetType::Quick) {
  ResetRequestBuilder builder_(_fbb);
  builder_.add_reset_type(reset_type);
  return builder_.Finish();
}

struct ResetResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResetResponseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ResetResponseBuilder {
  typedef ResetResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ResetResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResetResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResetResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResetResponse> CreateResetResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ResetResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AssignTrackerRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssignTrackerRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACKER_ID = 4,
    VT_BODY_POSITION = 6,
    VT_MOUNTING_ROTATION = 8,
    VT_DISPLAY_NAME = 10
  };
  const solarxr_protocol::datatypes::TrackerId *tracker_id() const {
    return GetPointer<const solarxr_protocol::datatypes::TrackerId *>(VT_TRACKER_ID);
  }
  solarxr_protocol::datatypes::BodyPart body_position() const {
    return static_cast<solarxr_protocol::datatypes::BodyPart>(GetField<uint8_t>(VT_BODY_POSITION, 0));
  }
  const solarxr_protocol::datatypes::math::Quat *mounting_rotation() const {
    return GetStruct<const solarxr_protocol::datatypes::math::Quat *>(VT_MOUNTING_ROTATION);
  }
  const flatbuffers::String *display_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACKER_ID) &&
           verifier.VerifyTable(tracker_id()) &&
           VerifyField<uint8_t>(verifier, VT_BODY_POSITION, 1) &&
           VerifyField<solarxr_protocol::datatypes::math::Quat>(verifier, VT_MOUNTING_ROTATION, 4) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           verifier.EndTable();
  }
};

struct AssignTrackerRequestBuilder {
  typedef AssignTrackerRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tracker_id(flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id) {
    fbb_.AddOffset(AssignTrackerRequest::VT_TRACKER_ID, tracker_id);
  }
  void add_body_position(solarxr_protocol::datatypes::BodyPart body_position) {
    fbb_.AddElement<uint8_t>(AssignTrackerRequest::VT_BODY_POSITION, static_cast<uint8_t>(body_position), 0);
  }
  void add_mounting_rotation(const solarxr_protocol::datatypes::math::Quat *mounting_rotation) {
    fbb_.AddStruct(AssignTrackerRequest::VT_MOUNTING_ROTATION, mounting_rotation);
  }
  void add_display_name(flatbuffers::Offset<flatbuffers::String> display_name) {
    fbb_.AddOffset(AssignTrackerRequest::VT_DISPLAY_NAME, display_name);
  }
  explicit AssignTrackerRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AssignTrackerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignTrackerRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignTrackerRequest> CreateAssignTrackerRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id = 0,
    solarxr_protocol::datatypes::BodyPart body_position = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::math::Quat *mounting_rotation = nullptr,
    flatbuffers::Offset<flatbuffers::String> display_name = 0) {
  AssignTrackerRequestBuilder builder_(_fbb);
  builder_.add_display_name(display_name);
  builder_.add_mounting_rotation(mounting_rotation);
  builder_.add_tracker_id(tracker_id);
  builder_.add_body_position(body_position);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssignTrackerRequest> CreateAssignTrackerRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::datatypes::TrackerId> tracker_id = 0,
    solarxr_protocol::datatypes::BodyPart body_position = solarxr_protocol::datatypes::BodyPart::NONE,
    const solarxr_protocol::datatypes::math::Quat *mounting_rotation = nullptr,
    const char *display_name = nullptr) {
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  return solarxr_protocol::application::rpc::CreateAssignTrackerRequest(
      _fbb,
      tracker_id,
      body_position,
      mounting_rotation,
      display_name__);
}

struct SettingsRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SettingsRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SettingsRequestBuilder {
  typedef SettingsRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SettingsRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SettingsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SettingsRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SettingsRequest> CreateSettingsRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SettingsRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SettingsResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SettingsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEAM_VR_TRACKERS = 4,
    VT_FILTERING = 6,
    VT_MODEL_SETTINGS = 8
  };
  const solarxr_protocol::application::rpc::SteamVRTrackersSetting *steam_vr_trackers() const {
    return GetPointer<const solarxr_protocol::application::rpc::SteamVRTrackersSetting *>(VT_STEAM_VR_TRACKERS);
  }
  const solarxr_protocol::application::rpc::FilteringSettings *filtering() const {
    return GetPointer<const solarxr_protocol::application::rpc::FilteringSettings *>(VT_FILTERING);
  }
  const solarxr_protocol::application::rpc::settings::ModelSettings *model_settings() const {
    return GetPointer<const solarxr_protocol::application::rpc::settings::ModelSettings *>(VT_MODEL_SETTINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STEAM_VR_TRACKERS) &&
           verifier.VerifyTable(steam_vr_trackers()) &&
           VerifyOffset(verifier, VT_FILTERING) &&
           verifier.VerifyTable(filtering()) &&
           VerifyOffset(verifier, VT_MODEL_SETTINGS) &&
           verifier.VerifyTable(model_settings()) &&
           verifier.EndTable();
  }
};

struct SettingsResponseBuilder {
  typedef SettingsResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_steam_vr_trackers(flatbuffers::Offset<solarxr_protocol::application::rpc::SteamVRTrackersSetting> steam_vr_trackers) {
    fbb_.AddOffset(SettingsResponse::VT_STEAM_VR_TRACKERS, steam_vr_trackers);
  }
  void add_filtering(flatbuffers::Offset<solarxr_protocol::application::rpc::FilteringSettings> filtering) {
    fbb_.AddOffset(SettingsResponse::VT_FILTERING, filtering);
  }
  void add_model_settings(flatbuffers::Offset<solarxr_protocol::application::rpc::settings::ModelSettings> model_settings) {
    fbb_.AddOffset(SettingsResponse::VT_MODEL_SETTINGS, model_settings);
  }
  explicit SettingsResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SettingsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SettingsResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SettingsResponse> CreateSettingsResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::application::rpc::SteamVRTrackersSetting> steam_vr_trackers = 0,
    flatbuffers::Offset<solarxr_protocol::application::rpc::FilteringSettings> filtering = 0,
    flatbuffers::Offset<solarxr_protocol::application::rpc::settings::ModelSettings> model_settings = 0) {
  SettingsResponseBuilder builder_(_fbb);
  builder_.add_model_settings(model_settings);
  builder_.add_filtering(filtering);
  builder_.add_steam_vr_trackers(steam_vr_trackers);
  return builder_.Finish();
}

struct ChangeSettingsRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChangeSettingsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEAM_VR_TRACKERS = 4,
    VT_FILTERING = 6,
    VT_MODEL_SETTINGS = 8
  };
  const solarxr_protocol::application::rpc::SteamVRTrackersSetting *steam_vr_trackers() const {
    return GetPointer<const solarxr_protocol::application::rpc::SteamVRTrackersSetting *>(VT_STEAM_VR_TRACKERS);
  }
  const solarxr_protocol::application::rpc::FilteringSettings *filtering() const {
    return GetPointer<const solarxr_protocol::application::rpc::FilteringSettings *>(VT_FILTERING);
  }
  const solarxr_protocol::application::rpc::settings::ModelSettings *model_settings() const {
    return GetPointer<const solarxr_protocol::application::rpc::settings::ModelSettings *>(VT_MODEL_SETTINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STEAM_VR_TRACKERS) &&
           verifier.VerifyTable(steam_vr_trackers()) &&
           VerifyOffset(verifier, VT_FILTERING) &&
           verifier.VerifyTable(filtering()) &&
           VerifyOffset(verifier, VT_MODEL_SETTINGS) &&
           verifier.VerifyTable(model_settings()) &&
           verifier.EndTable();
  }
};

struct ChangeSettingsRequestBuilder {
  typedef ChangeSettingsRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_steam_vr_trackers(flatbuffers::Offset<solarxr_protocol::application::rpc::SteamVRTrackersSetting> steam_vr_trackers) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_STEAM_VR_TRACKERS, steam_vr_trackers);
  }
  void add_filtering(flatbuffers::Offset<solarxr_protocol::application::rpc::FilteringSettings> filtering) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_FILTERING, filtering);
  }
  void add_model_settings(flatbuffers::Offset<solarxr_protocol::application::rpc::settings::ModelSettings> model_settings) {
    fbb_.AddOffset(ChangeSettingsRequest::VT_MODEL_SETTINGS, model_settings);
  }
  explicit ChangeSettingsRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ChangeSettingsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangeSettingsRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangeSettingsRequest> CreateChangeSettingsRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::application::rpc::SteamVRTrackersSetting> steam_vr_trackers = 0,
    flatbuffers::Offset<solarxr_protocol::application::rpc::FilteringSettings> filtering = 0,
    flatbuffers::Offset<solarxr_protocol::application::rpc::settings::ModelSettings> model_settings = 0) {
  ChangeSettingsRequestBuilder builder_(_fbb);
  builder_.add_model_settings(model_settings);
  builder_.add_filtering(filtering);
  builder_.add_steam_vr_trackers(steam_vr_trackers);
  return builder_.Finish();
}

struct SteamVRTrackersSetting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SteamVRTrackersSettingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WAIST = 4,
    VT_CHEST = 6,
    VT_LEGS = 8,
    VT_KNEES = 10,
    VT_ELBOWS = 12
  };
  bool waist() const {
    return GetField<uint8_t>(VT_WAIST, 0) != 0;
  }
  bool chest() const {
    return GetField<uint8_t>(VT_CHEST, 0) != 0;
  }
  bool legs() const {
    return GetField<uint8_t>(VT_LEGS, 0) != 0;
  }
  bool knees() const {
    return GetField<uint8_t>(VT_KNEES, 0) != 0;
  }
  bool elbows() const {
    return GetField<uint8_t>(VT_ELBOWS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_WAIST, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHEST, 1) &&
           VerifyField<uint8_t>(verifier, VT_LEGS, 1) &&
           VerifyField<uint8_t>(verifier, VT_KNEES, 1) &&
           VerifyField<uint8_t>(verifier, VT_ELBOWS, 1) &&
           verifier.EndTable();
  }
};

struct SteamVRTrackersSettingBuilder {
  typedef SteamVRTrackersSetting Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_waist(bool waist) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_WAIST, static_cast<uint8_t>(waist), 0);
  }
  void add_chest(bool chest) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_CHEST, static_cast<uint8_t>(chest), 0);
  }
  void add_legs(bool legs) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_LEGS, static_cast<uint8_t>(legs), 0);
  }
  void add_knees(bool knees) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_KNEES, static_cast<uint8_t>(knees), 0);
  }
  void add_elbows(bool elbows) {
    fbb_.AddElement<uint8_t>(SteamVRTrackersSetting::VT_ELBOWS, static_cast<uint8_t>(elbows), 0);
  }
  explicit SteamVRTrackersSettingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SteamVRTrackersSetting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SteamVRTrackersSetting>(end);
    return o;
  }
};

inline flatbuffers::Offset<SteamVRTrackersSetting> CreateSteamVRTrackersSetting(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool waist = false,
    bool chest = false,
    bool legs = false,
    bool knees = false,
    bool elbows = false) {
  SteamVRTrackersSettingBuilder builder_(_fbb);
  builder_.add_elbows(elbows);
  builder_.add_knees(knees);
  builder_.add_legs(legs);
  builder_.add_chest(chest);
  builder_.add_waist(waist);
  return builder_.Finish();
}

struct FilteringSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FilteringSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_AMOUNT = 6
  };
  solarxr_protocol::datatypes::FilteringType type() const {
    return static_cast<solarxr_protocol::datatypes::FilteringType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  /// 0 to 1. A higher value results in more smoothing or prediction
  float amount() const {
    return GetField<float>(VT_AMOUNT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<float>(verifier, VT_AMOUNT, 4) &&
           verifier.EndTable();
  }
};

struct FilteringSettingsBuilder {
  typedef FilteringSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(solarxr_protocol::datatypes::FilteringType type) {
    fbb_.AddElement<uint8_t>(FilteringSettings::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_amount(float amount) {
    fbb_.AddElement<float>(FilteringSettings::VT_AMOUNT, amount, 0.0f);
  }
  explicit FilteringSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FilteringSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FilteringSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<FilteringSettings> CreateFilteringSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::datatypes::FilteringType type = solarxr_protocol::datatypes::FilteringType::NONE,
    float amount = 0.0f) {
  FilteringSettingsBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_type(type);
  return builder_.Finish();
}

struct RecordBVHRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordBVHRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STOP = 4
  };
  bool stop() const {
    return GetField<uint8_t>(VT_STOP, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STOP, 1) &&
           verifier.EndTable();
  }
};

struct RecordBVHRequestBuilder {
  typedef RecordBVHRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stop(bool stop) {
    fbb_.AddElement<uint8_t>(RecordBVHRequest::VT_STOP, static_cast<uint8_t>(stop), 0);
  }
  explicit RecordBVHRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RecordBVHRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecordBVHRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecordBVHRequest> CreateRecordBVHRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool stop = false) {
  RecordBVHRequestBuilder builder_(_fbb);
  builder_.add_stop(stop);
  return builder_.Finish();
}

struct RecordBVHStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordBVHStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDING = 4
  };
  bool recording() const {
    return GetField<uint8_t>(VT_RECORDING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RECORDING, 1) &&
           verifier.EndTable();
  }
};

struct RecordBVHStatusBuilder {
  typedef RecordBVHStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_recording(bool recording) {
    fbb_.AddElement<uint8_t>(RecordBVHStatus::VT_RECORDING, static_cast<uint8_t>(recording), 0);
  }
  explicit RecordBVHStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RecordBVHStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecordBVHStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecordBVHStatus> CreateRecordBVHStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool recording = false) {
  RecordBVHStatusBuilder builder_(_fbb);
  builder_.add_recording(recording);
  return builder_.Finish();
}

struct SkeletonPart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkeletonPartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BONE = 4,
    VT_VALUE = 6
  };
  solarxr_protocol::application::rpc::SkeletonBone bone() const {
    return static_cast<solarxr_protocol::application::rpc::SkeletonBone>(GetField<uint8_t>(VT_BONE, 0));
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BONE, 1) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct SkeletonPartBuilder {
  typedef SkeletonPart Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bone(solarxr_protocol::application::rpc::SkeletonBone bone) {
    fbb_.AddElement<uint8_t>(SkeletonPart::VT_BONE, static_cast<uint8_t>(bone), 0);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(SkeletonPart::VT_VALUE, value, 0.0f);
  }
  explicit SkeletonPartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkeletonPart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkeletonPart>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkeletonPart> CreateSkeletonPart(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::application::rpc::SkeletonBone bone = solarxr_protocol::application::rpc::SkeletonBone::NONE,
    float value = 0.0f) {
  SkeletonPartBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_bone(bone);
  return builder_.Finish();
}

struct SkeletonConfigRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkeletonConfigRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SkeletonConfigRequestBuilder {
  typedef SkeletonConfigRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SkeletonConfigRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkeletonConfigRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkeletonConfigRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkeletonConfigRequest> CreateSkeletonConfigRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SkeletonConfigRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SkeletonConfigResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkeletonConfigResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKELETON_PARTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::SkeletonPart>> *skeleton_parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::SkeletonPart>> *>(VT_SKELETON_PARTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SKELETON_PARTS) &&
           verifier.VerifyVector(skeleton_parts()) &&
           verifier.VerifyVectorOfTables(skeleton_parts()) &&
           verifier.EndTable();
  }
};

struct SkeletonConfigResponseBuilder {
  typedef SkeletonConfigResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skeleton_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::SkeletonPart>>> skeleton_parts) {
    fbb_.AddOffset(SkeletonConfigResponse::VT_SKELETON_PARTS, skeleton_parts);
  }
  explicit SkeletonConfigResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkeletonConfigResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkeletonConfigResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkeletonConfigResponse> CreateSkeletonConfigResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::SkeletonPart>>> skeleton_parts = 0) {
  SkeletonConfigResponseBuilder builder_(_fbb);
  builder_.add_skeleton_parts(skeleton_parts);
  return builder_.Finish();
}

inline flatbuffers::Offset<SkeletonConfigResponse> CreateSkeletonConfigResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::application::rpc::SkeletonPart>> *skeleton_parts = nullptr) {
  auto skeleton_parts__ = skeleton_parts ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::application::rpc::SkeletonPart>>(*skeleton_parts) : 0;
  return solarxr_protocol::application::rpc::CreateSkeletonConfigResponse(
      _fbb,
      skeleton_parts__);
}

struct SkeletonResetAllRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkeletonResetAllRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SkeletonResetAllRequestBuilder {
  typedef SkeletonResetAllRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SkeletonResetAllRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkeletonResetAllRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkeletonResetAllRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkeletonResetAllRequest> CreateSkeletonResetAllRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SkeletonResetAllRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ChangeSkeletonConfigRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChangeSkeletonConfigRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BONE = 4,
    VT_VALUE = 6
  };
  solarxr_protocol::application::rpc::SkeletonBone bone() const {
    return static_cast<solarxr_protocol::application::rpc::SkeletonBone>(GetField<uint8_t>(VT_BONE, 0));
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BONE, 1) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct ChangeSkeletonConfigRequestBuilder {
  typedef ChangeSkeletonConfigRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bone(solarxr_protocol::application::rpc::SkeletonBone bone) {
    fbb_.AddElement<uint8_t>(ChangeSkeletonConfigRequest::VT_BONE, static_cast<uint8_t>(bone), 0);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(ChangeSkeletonConfigRequest::VT_VALUE, value, 0.0f);
  }
  explicit ChangeSkeletonConfigRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ChangeSkeletonConfigRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangeSkeletonConfigRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangeSkeletonConfigRequest> CreateChangeSkeletonConfigRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::application::rpc::SkeletonBone bone = solarxr_protocol::application::rpc::SkeletonBone::NONE,
    float value = 0.0f) {
  ChangeSkeletonConfigRequestBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_bone(bone);
  return builder_.Finish();
}

struct OpenSerialRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpenSerialRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OpenSerialRequestBuilder {
  typedef OpenSerialRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OpenSerialRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OpenSerialRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpenSerialRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpenSerialRequest> CreateOpenSerialRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OpenSerialRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CloseSerialRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CloseSerialRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CloseSerialRequestBuilder {
  typedef CloseSerialRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CloseSerialRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CloseSerialRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CloseSerialRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CloseSerialRequest> CreateCloseSerialRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CloseSerialRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SetWifiRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetWifiRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSID = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *ssid() const {
    return GetPointer<const flatbuffers::String *>(VT_SSID);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SSID) &&
           verifier.VerifyString(ssid()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           verifier.EndTable();
  }
};

struct SetWifiRequestBuilder {
  typedef SetWifiRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ssid(flatbuffers::Offset<flatbuffers::String> ssid) {
    fbb_.AddOffset(SetWifiRequest::VT_SSID, ssid);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(SetWifiRequest::VT_PASSWORD, password);
  }
  explicit SetWifiRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SetWifiRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetWifiRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetWifiRequest> CreateSetWifiRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ssid = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  SetWifiRequestBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_ssid(ssid);
  return builder_.Finish();
}

inline flatbuffers::Offset<SetWifiRequest> CreateSetWifiRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ssid = nullptr,
    const char *password = nullptr) {
  auto ssid__ = ssid ? _fbb.CreateString(ssid) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return solarxr_protocol::application::rpc::CreateSetWifiRequest(
      _fbb,
      ssid__,
      password__);
}

struct SerialUpdateResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerialUpdateResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOG = 4,
    VT_CLOSED = 6
  };
  const flatbuffers::String *log() const {
    return GetPointer<const flatbuffers::String *>(VT_LOG);
  }
  bool closed() const {
    return GetField<uint8_t>(VT_CLOSED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOG) &&
           verifier.VerifyString(log()) &&
           VerifyField<uint8_t>(verifier, VT_CLOSED, 1) &&
           verifier.EndTable();
  }
};

struct SerialUpdateResponseBuilder {
  typedef SerialUpdateResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_log(flatbuffers::Offset<flatbuffers::String> log) {
    fbb_.AddOffset(SerialUpdateResponse::VT_LOG, log);
  }
  void add_closed(bool closed) {
    fbb_.AddElement<uint8_t>(SerialUpdateResponse::VT_CLOSED, static_cast<uint8_t>(closed), 0);
  }
  explicit SerialUpdateResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SerialUpdateResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerialUpdateResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerialUpdateResponse> CreateSerialUpdateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> log = 0,
    bool closed = false) {
  SerialUpdateResponseBuilder builder_(_fbb);
  builder_.add_log(log);
  builder_.add_closed(closed);
  return builder_.Finish();
}

inline flatbuffers::Offset<SerialUpdateResponse> CreateSerialUpdateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *log = nullptr,
    bool closed = false) {
  auto log__ = log ? _fbb.CreateString(log) : 0;
  return solarxr_protocol::application::rpc::CreateSerialUpdateResponse(
      _fbb,
      log__,
      closed);
}

/// Reboots the tracker connected to the serial monitor
struct SerialTrackerRebootRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerialTrackerRebootRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SerialTrackerRebootRequestBuilder {
  typedef SerialTrackerRebootRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SerialTrackerRebootRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SerialTrackerRebootRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerialTrackerRebootRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerialTrackerRebootRequest> CreateSerialTrackerRebootRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SerialTrackerRebootRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Sends the GET INFO cmd to the current tracker on the serial monitor
struct SerialTrackerGetInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerialTrackerGetInfoRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SerialTrackerGetInfoRequestBuilder {
  typedef SerialTrackerGetInfoRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SerialTrackerGetInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SerialTrackerGetInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerialTrackerGetInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerialTrackerGetInfoRequest> CreateSerialTrackerGetInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SerialTrackerGetInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Sends the FRST cmd to the currently over the Serial Montior connected Tracker
struct SerialTrackerFactoryResetRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerialTrackerFactoryResetRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SerialTrackerFactoryResetRequestBuilder {
  typedef SerialTrackerFactoryResetRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SerialTrackerFactoryResetRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SerialTrackerFactoryResetRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerialTrackerFactoryResetRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerialTrackerFactoryResetRequest> CreateSerialTrackerFactoryResetRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SerialTrackerFactoryResetRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AutoBoneProcessRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoBoneProcessRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROCESS_TYPE = 4
  };
  solarxr_protocol::application::rpc::AutoBoneProcessType process_type() const {
    return static_cast<solarxr_protocol::application::rpc::AutoBoneProcessType>(GetField<uint8_t>(VT_PROCESS_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PROCESS_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct AutoBoneProcessRequestBuilder {
  typedef AutoBoneProcessRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_process_type(solarxr_protocol::application::rpc::AutoBoneProcessType process_type) {
    fbb_.AddElement<uint8_t>(AutoBoneProcessRequest::VT_PROCESS_TYPE, static_cast<uint8_t>(process_type), 0);
  }
  explicit AutoBoneProcessRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AutoBoneProcessRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoBoneProcessRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoBoneProcessRequest> CreateAutoBoneProcessRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::application::rpc::AutoBoneProcessType process_type = solarxr_protocol::application::rpc::AutoBoneProcessType::NONE) {
  AutoBoneProcessRequestBuilder builder_(_fbb);
  builder_.add_process_type(process_type);
  return builder_.Finish();
}

struct AutoBoneProcessStatusResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoBoneProcessStatusResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROCESS_TYPE = 4,
    VT_MESSAGE = 6,
    VT_CURRENT = 8,
    VT_TOTAL = 10,
    VT_COMPLETED = 12,
    VT_SUCCESS = 14
  };
  solarxr_protocol::application::rpc::AutoBoneProcessType process_type() const {
    return static_cast<solarxr_protocol::application::rpc::AutoBoneProcessType>(GetField<uint8_t>(VT_PROCESS_TYPE, 0));
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  uint32_t current() const {
    return GetField<uint32_t>(VT_CURRENT, 0);
  }
  uint32_t total() const {
    return GetField<uint32_t>(VT_TOTAL, 0);
  }
  bool completed() const {
    return GetField<uint8_t>(VT_COMPLETED, 0) != 0;
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PROCESS_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyField<uint32_t>(verifier, VT_CURRENT, 4) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL, 4) &&
           VerifyField<uint8_t>(verifier, VT_COMPLETED, 1) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
};

struct AutoBoneProcessStatusResponseBuilder {
  typedef AutoBoneProcessStatusResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_process_type(solarxr_protocol::application::rpc::AutoBoneProcessType process_type) {
    fbb_.AddElement<uint8_t>(AutoBoneProcessStatusResponse::VT_PROCESS_TYPE, static_cast<uint8_t>(process_type), 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(AutoBoneProcessStatusResponse::VT_MESSAGE, message);
  }
  void add_current(uint32_t current) {
    fbb_.AddElement<uint32_t>(AutoBoneProcessStatusResponse::VT_CURRENT, current, 0);
  }
  void add_total(uint32_t total) {
    fbb_.AddElement<uint32_t>(AutoBoneProcessStatusResponse::VT_TOTAL, total, 0);
  }
  void add_completed(bool completed) {
    fbb_.AddElement<uint8_t>(AutoBoneProcessStatusResponse::VT_COMPLETED, static_cast<uint8_t>(completed), 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(AutoBoneProcessStatusResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit AutoBoneProcessStatusResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AutoBoneProcessStatusResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoBoneProcessStatusResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoBoneProcessStatusResponse> CreateAutoBoneProcessStatusResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::application::rpc::AutoBoneProcessType process_type = solarxr_protocol::application::rpc::AutoBoneProcessType::NONE,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    uint32_t current = 0,
    uint32_t total = 0,
    bool completed = false,
    bool success = false) {
  AutoBoneProcessStatusResponseBuilder builder_(_fbb);
  builder_.add_total(total);
  builder_.add_current(current);
  builder_.add_message(message);
  builder_.add_success(success);
  builder_.add_completed(completed);
  builder_.add_process_type(process_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AutoBoneProcessStatusResponse> CreateAutoBoneProcessStatusResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::application::rpc::AutoBoneProcessType process_type = solarxr_protocol::application::rpc::AutoBoneProcessType::NONE,
    const char *message = nullptr,
    uint32_t current = 0,
    uint32_t total = 0,
    bool completed = false,
    bool success = false) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return solarxr_protocol::application::rpc::CreateAutoBoneProcessStatusResponse(
      _fbb,
      process_type,
      message__,
      current,
      total,
      completed,
      success);
}

struct AutoBoneEpochResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoBoneEpochResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURRENT_EPOCH = 4,
    VT_TOTAL_EPOCHS = 6,
    VT_EPOCH_ERROR = 8,
    VT_ADJUSTED_SKELETON_PARTS = 10
  };
  uint32_t current_epoch() const {
    return GetField<uint32_t>(VT_CURRENT_EPOCH, 0);
  }
  uint32_t total_epochs() const {
    return GetField<uint32_t>(VT_TOTAL_EPOCHS, 0);
  }
  float epoch_error() const {
    return GetField<float>(VT_EPOCH_ERROR, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::SkeletonPart>> *adjusted_skeleton_parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::SkeletonPart>> *>(VT_ADJUSTED_SKELETON_PARTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CURRENT_EPOCH, 4) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_EPOCHS, 4) &&
           VerifyField<float>(verifier, VT_EPOCH_ERROR, 4) &&
           VerifyOffset(verifier, VT_ADJUSTED_SKELETON_PARTS) &&
           verifier.VerifyVector(adjusted_skeleton_parts()) &&
           verifier.VerifyVectorOfTables(adjusted_skeleton_parts()) &&
           verifier.EndTable();
  }
};

struct AutoBoneEpochResponseBuilder {
  typedef AutoBoneEpochResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_current_epoch(uint32_t current_epoch) {
    fbb_.AddElement<uint32_t>(AutoBoneEpochResponse::VT_CURRENT_EPOCH, current_epoch, 0);
  }
  void add_total_epochs(uint32_t total_epochs) {
    fbb_.AddElement<uint32_t>(AutoBoneEpochResponse::VT_TOTAL_EPOCHS, total_epochs, 0);
  }
  void add_epoch_error(float epoch_error) {
    fbb_.AddElement<float>(AutoBoneEpochResponse::VT_EPOCH_ERROR, epoch_error, 0.0f);
  }
  void add_adjusted_skeleton_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::SkeletonPart>>> adjusted_skeleton_parts) {
    fbb_.AddOffset(AutoBoneEpochResponse::VT_ADJUSTED_SKELETON_PARTS, adjusted_skeleton_parts);
  }
  explicit AutoBoneEpochResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AutoBoneEpochResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoBoneEpochResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoBoneEpochResponse> CreateAutoBoneEpochResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t current_epoch = 0,
    uint32_t total_epochs = 0,
    float epoch_error = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::SkeletonPart>>> adjusted_skeleton_parts = 0) {
  AutoBoneEpochResponseBuilder builder_(_fbb);
  builder_.add_adjusted_skeleton_parts(adjusted_skeleton_parts);
  builder_.add_epoch_error(epoch_error);
  builder_.add_total_epochs(total_epochs);
  builder_.add_current_epoch(current_epoch);
  return builder_.Finish();
}

inline flatbuffers::Offset<AutoBoneEpochResponse> CreateAutoBoneEpochResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t current_epoch = 0,
    uint32_t total_epochs = 0,
    float epoch_error = 0.0f,
    const std::vector<flatbuffers::Offset<solarxr_protocol::application::rpc::SkeletonPart>> *adjusted_skeleton_parts = nullptr) {
  auto adjusted_skeleton_parts__ = adjusted_skeleton_parts ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::application::rpc::SkeletonPart>>(*adjusted_skeleton_parts) : 0;
  return solarxr_protocol::application::rpc::CreateAutoBoneEpochResponse(
      _fbb,
      current_epoch,
      total_epochs,
      epoch_error,
      adjusted_skeleton_parts__);
}

/// Requests the current state of `OverlayDisplayModeResponse`.
struct OverlayDisplayModeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OverlayDisplayModeRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OverlayDisplayModeRequestBuilder {
  typedef OverlayDisplayModeRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OverlayDisplayModeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OverlayDisplayModeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OverlayDisplayModeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OverlayDisplayModeRequest> CreateOverlayDisplayModeRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OverlayDisplayModeRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Changes the state of the overlay's display mode.
struct OverlayDisplayModeChangeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OverlayDisplayModeChangeRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_VISIBLE = 4,
    VT_IS_MIRRORED = 6
  };
  flatbuffers::Optional<bool> is_visible() const {
    return GetOptional<uint8_t, bool>(VT_IS_VISIBLE);
  }
  flatbuffers::Optional<bool> is_mirrored() const {
    return GetOptional<uint8_t, bool>(VT_IS_MIRRORED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_VISIBLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_MIRRORED, 1) &&
           verifier.EndTable();
  }
};

struct OverlayDisplayModeChangeRequestBuilder {
  typedef OverlayDisplayModeChangeRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_visible(bool is_visible) {
    fbb_.AddElement<uint8_t>(OverlayDisplayModeChangeRequest::VT_IS_VISIBLE, static_cast<uint8_t>(is_visible));
  }
  void add_is_mirrored(bool is_mirrored) {
    fbb_.AddElement<uint8_t>(OverlayDisplayModeChangeRequest::VT_IS_MIRRORED, static_cast<uint8_t>(is_mirrored));
  }
  explicit OverlayDisplayModeChangeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OverlayDisplayModeChangeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OverlayDisplayModeChangeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OverlayDisplayModeChangeRequest> CreateOverlayDisplayModeChangeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Optional<bool> is_visible = flatbuffers::nullopt,
    flatbuffers::Optional<bool> is_mirrored = flatbuffers::nullopt) {
  OverlayDisplayModeChangeRequestBuilder builder_(_fbb);
  if(is_mirrored) { builder_.add_is_mirrored(*is_mirrored); }
  if(is_visible) { builder_.add_is_visible(*is_visible); }
  return builder_.Finish();
}

/// The current state of the overlay's display mode.
struct OverlayDisplayModeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OverlayDisplayModeResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_VISIBLE = 4,
    VT_IS_MIRRORED = 6
  };
  bool is_visible() const {
    return GetField<uint8_t>(VT_IS_VISIBLE, 0) != 0;
  }
  bool is_mirrored() const {
    return GetField<uint8_t>(VT_IS_MIRRORED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_VISIBLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_MIRRORED, 1) &&
           verifier.EndTable();
  }
};

struct OverlayDisplayModeResponseBuilder {
  typedef OverlayDisplayModeResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_visible(bool is_visible) {
    fbb_.AddElement<uint8_t>(OverlayDisplayModeResponse::VT_IS_VISIBLE, static_cast<uint8_t>(is_visible), 0);
  }
  void add_is_mirrored(bool is_mirrored) {
    fbb_.AddElement<uint8_t>(OverlayDisplayModeResponse::VT_IS_MIRRORED, static_cast<uint8_t>(is_mirrored), 0);
  }
  explicit OverlayDisplayModeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OverlayDisplayModeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OverlayDisplayModeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<OverlayDisplayModeResponse> CreateOverlayDisplayModeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_visible = false,
    bool is_mirrored = false) {
  OverlayDisplayModeResponseBuilder builder_(_fbb);
  builder_.add_is_mirrored(is_mirrored);
  builder_.add_is_visible(is_visible);
  return builder_.Finish();
}

struct DetectedDevice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectedDeviceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFOS = 4,
    VT_MAC_ADDRESS = 6
  };
  const solarxr_protocol::device::pairing::PairingInfo *infos() const {
    return GetPointer<const solarxr_protocol::device::pairing::PairingInfo *>(VT_INFOS);
  }
  const solarxr_protocol::datatypes::hardware_info::HardwareAddress *mac_address() const {
    return GetStruct<const solarxr_protocol::datatypes::hardware_info::HardwareAddress *>(VT_MAC_ADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INFOS) &&
           verifier.VerifyTable(infos()) &&
           VerifyField<solarxr_protocol::datatypes::hardware_info::HardwareAddress>(verifier, VT_MAC_ADDRESS, 8) &&
           verifier.EndTable();
  }
};

struct DetectedDeviceBuilder {
  typedef DetectedDevice Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_infos(flatbuffers::Offset<solarxr_protocol::device::pairing::PairingInfo> infos) {
    fbb_.AddOffset(DetectedDevice::VT_INFOS, infos);
  }
  void add_mac_address(const solarxr_protocol::datatypes::hardware_info::HardwareAddress *mac_address) {
    fbb_.AddStruct(DetectedDevice::VT_MAC_ADDRESS, mac_address);
  }
  explicit DetectedDeviceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DetectedDevice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectedDevice>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectedDevice> CreateDetectedDevice(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::device::pairing::PairingInfo> infos = 0,
    const solarxr_protocol::datatypes::hardware_info::HardwareAddress *mac_address = nullptr) {
  DetectedDeviceBuilder builder_(_fbb);
  builder_.add_mac_address(mac_address);
  builder_.add_infos(infos);
  return builder_.Finish();
}

struct DetectedDevicesRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectedDevicesRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::DetectedDevice>> *devices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::DetectedDevice>> *>(VT_DEVICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICES) &&
           verifier.VerifyVector(devices()) &&
           verifier.VerifyVectorOfTables(devices()) &&
           verifier.EndTable();
  }
};

struct DetectedDevicesRequestBuilder {
  typedef DetectedDevicesRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_devices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::DetectedDevice>>> devices) {
    fbb_.AddOffset(DetectedDevicesRequest::VT_DEVICES, devices);
  }
  explicit DetectedDevicesRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DetectedDevicesRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectedDevicesRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectedDevicesRequest> CreateDetectedDevicesRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::DetectedDevice>>> devices = 0) {
  DetectedDevicesRequestBuilder builder_(_fbb);
  builder_.add_devices(devices);
  return builder_.Finish();
}

inline flatbuffers::Offset<DetectedDevicesRequest> CreateDetectedDevicesRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::application::rpc::DetectedDevice>> *devices = nullptr) {
  auto devices__ = devices ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::application::rpc::DetectedDevice>>(*devices) : 0;
  return solarxr_protocol::application::rpc::CreateDetectedDevicesRequest(
      _fbb,
      devices__);
}

struct PairDeviceRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PairDeviceRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAIR = 4,
    VT_MAC_ADDRESS = 6
  };
  bool pair() const {
    return GetField<uint8_t>(VT_PAIR, 0) != 0;
  }
  const solarxr_protocol::datatypes::hardware_info::HardwareAddress *mac_address() const {
    return GetStruct<const solarxr_protocol::datatypes::hardware_info::HardwareAddress *>(VT_MAC_ADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAIR, 1) &&
           VerifyField<solarxr_protocol::datatypes::hardware_info::HardwareAddress>(verifier, VT_MAC_ADDRESS, 8) &&
           verifier.EndTable();
  }
};

struct PairDeviceRequestBuilder {
  typedef PairDeviceRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pair(bool pair) {
    fbb_.AddElement<uint8_t>(PairDeviceRequest::VT_PAIR, static_cast<uint8_t>(pair), 0);
  }
  void add_mac_address(const solarxr_protocol::datatypes::hardware_info::HardwareAddress *mac_address) {
    fbb_.AddStruct(PairDeviceRequest::VT_MAC_ADDRESS, mac_address);
  }
  explicit PairDeviceRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PairDeviceRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PairDeviceRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<PairDeviceRequest> CreatePairDeviceRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool pair = false,
    const solarxr_protocol::datatypes::hardware_info::HardwareAddress *mac_address = nullptr) {
  PairDeviceRequestBuilder builder_(_fbb);
  builder_.add_mac_address(mac_address);
  builder_.add_pair(pair);
  return builder_.Finish();
}

}  // namespace rpc

namespace pub_sub {

/// A `TopicId` identifies an application-specific category of data. Because it
/// is application-specific, it is up to the application within the specified
/// organization to define its semantics/meaning.
///
/// For example, "bob" may have an "overlay" app with a "settings" topic for controlling
/// the overlay visibility and other settings, as well as a "video feed" topic for
/// allowing other applications to display video data in a wrist mounted window in VR.
struct TopicId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopicIdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORGANIZATION = 4,
    VT_APP_NAME = 6,
    VT_TOPIC = 8
  };
  /// The organization/developer that defines the meaning of this feature. Avoids name
  /// clashes. Should be something unique - same idea as java package identifier.
  const flatbuffers::String *organization() const {
    return GetPointer<const flatbuffers::String *>(VT_ORGANIZATION);
  }
  /// The name of the application/device. Should be unique within the organization.
  const flatbuffers::String *app_name() const {
    return GetPointer<const flatbuffers::String *>(VT_APP_NAME);
  }
  /// The name of the topic. Should be unique within the application.
  const flatbuffers::String *topic() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPIC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORGANIZATION) &&
           verifier.VerifyString(organization()) &&
           VerifyOffset(verifier, VT_APP_NAME) &&
           verifier.VerifyString(app_name()) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           verifier.VerifyString(topic()) &&
           verifier.EndTable();
  }
};

struct TopicIdBuilder {
  typedef TopicId Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_organization(flatbuffers::Offset<flatbuffers::String> organization) {
    fbb_.AddOffset(TopicId::VT_ORGANIZATION, organization);
  }
  void add_app_name(flatbuffers::Offset<flatbuffers::String> app_name) {
    fbb_.AddOffset(TopicId::VT_APP_NAME, app_name);
  }
  void add_topic(flatbuffers::Offset<flatbuffers::String> topic) {
    fbb_.AddOffset(TopicId::VT_TOPIC, topic);
  }
  explicit TopicIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopicId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicId>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicId> CreateTopicId(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> organization = 0,
    flatbuffers::Offset<flatbuffers::String> app_name = 0,
    flatbuffers::Offset<flatbuffers::String> topic = 0) {
  TopicIdBuilder builder_(_fbb);
  builder_.add_topic(topic);
  builder_.add_app_name(app_name);
  builder_.add_organization(organization);
  return builder_.Finish();
}

inline flatbuffers::Offset<TopicId> CreateTopicIdDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *organization = nullptr,
    const char *app_name = nullptr,
    const char *topic = nullptr) {
  auto organization__ = organization ? _fbb.CreateString(organization) : 0;
  auto app_name__ = app_name ? _fbb.CreateString(app_name) : 0;
  auto topic__ = topic ? _fbb.CreateString(topic) : 0;
  return solarxr_protocol::application::pub_sub::CreateTopicId(
      _fbb,
      organization__,
      app_name__,
      topic__);
}

/// A handle for the topic, allows referencing a topic without sending a huge
/// `TopicId`.
struct TopicHandle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopicHandleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID, 2) &&
           verifier.EndTable();
  }
};

struct TopicHandleBuilder {
  typedef TopicHandle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(TopicHandle::VT_ID, id, 0);
  }
  explicit TopicHandleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopicHandle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicHandle>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicHandle> CreateTopicHandle(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0) {
  TopicHandleBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

/// Response for `TopicHandleRequest` or `SubscriptionRequest`.
struct TopicMapping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopicMappingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_HANDLE = 6
  };
  const solarxr_protocol::application::pub_sub::TopicId *id() const {
    return GetPointer<const solarxr_protocol::application::pub_sub::TopicId *>(VT_ID);
  }
  const solarxr_protocol::application::pub_sub::TopicHandle *handle() const {
    return GetPointer<const solarxr_protocol::application::pub_sub::TopicHandle *>(VT_HANDLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_HANDLE) &&
           verifier.VerifyTable(handle()) &&
           verifier.EndTable();
  }
};

struct TopicMappingBuilder {
  typedef TopicMapping Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<solarxr_protocol::application::pub_sub::TopicId> id) {
    fbb_.AddOffset(TopicMapping::VT_ID, id);
  }
  void add_handle(flatbuffers::Offset<solarxr_protocol::application::pub_sub::TopicHandle> handle) {
    fbb_.AddOffset(TopicMapping::VT_HANDLE, handle);
  }
  explicit TopicMappingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopicMapping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicMapping>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicMapping> CreateTopicMapping(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::application::pub_sub::TopicId> id = 0,
    flatbuffers::Offset<solarxr_protocol::application::pub_sub::TopicHandle> handle = 0) {
  TopicMappingBuilder builder_(_fbb);
  builder_.add_handle(handle);
  builder_.add_id(id);
  return builder_.Finish();
}

/// Request to get the `FeatureHandle` from a `FeatureId`. This is useful for reducing
/// bandwidth, since `FeatureId` can be large.
struct TopicHandleRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopicHandleRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const solarxr_protocol::application::pub_sub::TopicId *id() const {
    return GetPointer<const solarxr_protocol::application::pub_sub::TopicId *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           verifier.EndTable();
  }
};

struct TopicHandleRequestBuilder {
  typedef TopicHandleRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<solarxr_protocol::application::pub_sub::TopicId> id) {
    fbb_.AddOffset(TopicHandleRequest::VT_ID, id);
  }
  explicit TopicHandleRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopicHandleRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicHandleRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicHandleRequest> CreateTopicHandleRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<solarxr_protocol::application::pub_sub::TopicId> id = 0) {
  TopicHandleRequestBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

/// Requests a subscription to `topic`. Replies with a `TopicMapping`.
struct SubscriptionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubscriptionRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_TYPE = 4,
    VT_TOPIC = 6
  };
  solarxr_protocol::application::pub_sub::Topic topic_type() const {
    return static_cast<solarxr_protocol::application::pub_sub::Topic>(GetField<uint8_t>(VT_TOPIC_TYPE, 0));
  }
  const void *topic() const {
    return GetPointer<const void *>(VT_TOPIC);
  }
  template<typename T> const T *topic_as() const;
  const solarxr_protocol::application::pub_sub::TopicHandle *topic_as_TopicHandle() const {
    return topic_type() == solarxr_protocol::application::pub_sub::Topic::TopicHandle ? static_cast<const solarxr_protocol::application::pub_sub::TopicHandle *>(topic()) : nullptr;
  }
  const solarxr_protocol::application::pub_sub::TopicId *topic_as_TopicId() const {
    return topic_type() == solarxr_protocol::application::pub_sub::Topic::TopicId ? static_cast<const solarxr_protocol::application::pub_sub::TopicId *>(topic()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TOPIC_TYPE, 1) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           VerifyTopic(verifier, topic(), topic_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::application::pub_sub::TopicHandle *SubscriptionRequest::topic_as<solarxr_protocol::application::pub_sub::TopicHandle>() const {
  return topic_as_TopicHandle();
}

template<> inline const solarxr_protocol::application::pub_sub::TopicId *SubscriptionRequest::topic_as<solarxr_protocol::application::pub_sub::TopicId>() const {
  return topic_as_TopicId();
}

struct SubscriptionRequestBuilder {
  typedef SubscriptionRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_type(solarxr_protocol::application::pub_sub::Topic topic_type) {
    fbb_.AddElement<uint8_t>(SubscriptionRequest::VT_TOPIC_TYPE, static_cast<uint8_t>(topic_type), 0);
  }
  void add_topic(flatbuffers::Offset<void> topic) {
    fbb_.AddOffset(SubscriptionRequest::VT_TOPIC, topic);
  }
  explicit SubscriptionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubscriptionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubscriptionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubscriptionRequest> CreateSubscriptionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::application::pub_sub::Topic topic_type = solarxr_protocol::application::pub_sub::Topic::NONE,
    flatbuffers::Offset<void> topic = 0) {
  SubscriptionRequestBuilder builder_(_fbb);
  builder_.add_topic(topic);
  builder_.add_topic_type(topic_type);
  return builder_.Finish();
}

struct PubSubHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PubSubHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_U_TYPE = 4,
    VT_U = 6
  };
  solarxr_protocol::application::pub_sub::PubSubUnion u_type() const {
    return static_cast<solarxr_protocol::application::pub_sub::PubSubUnion>(GetField<uint8_t>(VT_U_TYPE, 0));
  }
  const void *u() const {
    return GetPointer<const void *>(VT_U);
  }
  template<typename T> const T *u_as() const;
  const solarxr_protocol::application::pub_sub::Message *u_as_Message() const {
    return u_type() == solarxr_protocol::application::pub_sub::PubSubUnion::Message ? static_cast<const solarxr_protocol::application::pub_sub::Message *>(u()) : nullptr;
  }
  const solarxr_protocol::application::pub_sub::SubscriptionRequest *u_as_SubscriptionRequest() const {
    return u_type() == solarxr_protocol::application::pub_sub::PubSubUnion::SubscriptionRequest ? static_cast<const solarxr_protocol::application::pub_sub::SubscriptionRequest *>(u()) : nullptr;
  }
  const solarxr_protocol::application::pub_sub::TopicHandleRequest *u_as_TopicHandleRequest() const {
    return u_type() == solarxr_protocol::application::pub_sub::PubSubUnion::TopicHandleRequest ? static_cast<const solarxr_protocol::application::pub_sub::TopicHandleRequest *>(u()) : nullptr;
  }
  const solarxr_protocol::application::pub_sub::TopicMapping *u_as_TopicMapping() const {
    return u_type() == solarxr_protocol::application::pub_sub::PubSubUnion::TopicMapping ? static_cast<const solarxr_protocol::application::pub_sub::TopicMapping *>(u()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_U_TYPE, 1) &&
           VerifyOffset(verifier, VT_U) &&
           VerifyPubSubUnion(verifier, u(), u_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::application::pub_sub::Message *PubSubHeader::u_as<solarxr_protocol::application::pub_sub::Message>() const {
  return u_as_Message();
}

template<> inline const solarxr_protocol::application::pub_sub::SubscriptionRequest *PubSubHeader::u_as<solarxr_protocol::application::pub_sub::SubscriptionRequest>() const {
  return u_as_SubscriptionRequest();
}

template<> inline const solarxr_protocol::application::pub_sub::TopicHandleRequest *PubSubHeader::u_as<solarxr_protocol::application::pub_sub::TopicHandleRequest>() const {
  return u_as_TopicHandleRequest();
}

template<> inline const solarxr_protocol::application::pub_sub::TopicMapping *PubSubHeader::u_as<solarxr_protocol::application::pub_sub::TopicMapping>() const {
  return u_as_TopicMapping();
}

struct PubSubHeaderBuilder {
  typedef PubSubHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_u_type(solarxr_protocol::application::pub_sub::PubSubUnion u_type) {
    fbb_.AddElement<uint8_t>(PubSubHeader::VT_U_TYPE, static_cast<uint8_t>(u_type), 0);
  }
  void add_u(flatbuffers::Offset<void> u) {
    fbb_.AddOffset(PubSubHeader::VT_U, u);
  }
  explicit PubSubHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PubSubHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PubSubHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<PubSubHeader> CreatePubSubHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::application::pub_sub::PubSubUnion u_type = solarxr_protocol::application::pub_sub::PubSubUnion::NONE,
    flatbuffers::Offset<void> u = 0) {
  PubSubHeaderBuilder builder_(_fbb);
  builder_.add_u(u);
  builder_.add_u_type(u_type);
  return builder_.Finish();
}

/// Data that is sent from publishers to subscribers
struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_TYPE = 4,
    VT_TOPIC = 6,
    VT_PAYLOAD_TYPE = 8,
    VT_PAYLOAD = 10
  };
  solarxr_protocol::application::pub_sub::Topic topic_type() const {
    return static_cast<solarxr_protocol::application::pub_sub::Topic>(GetField<uint8_t>(VT_TOPIC_TYPE, 0));
  }
  const void *topic() const {
    return GetPointer<const void *>(VT_TOPIC);
  }
  template<typename T> const T *topic_as() const;
  const solarxr_protocol::application::pub_sub::TopicHandle *topic_as_TopicHandle() const {
    return topic_type() == solarxr_protocol::application::pub_sub::Topic::TopicHandle ? static_cast<const solarxr_protocol::application::pub_sub::TopicHandle *>(topic()) : nullptr;
  }
  const solarxr_protocol::application::pub_sub::TopicId *topic_as_TopicId() const {
    return topic_type() == solarxr_protocol::application::pub_sub::Topic::TopicId ? static_cast<const solarxr_protocol::application::pub_sub::TopicId *>(topic()) : nullptr;
  }
  solarxr_protocol::application::pub_sub::Payload payload_type() const {
    return static_cast<solarxr_protocol::application::pub_sub::Payload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const solarxr_protocol::datatypes::StringTable *payload_as_solarxr_protocol_datatypes_StringTable() const {
    return payload_type() == solarxr_protocol::application::pub_sub::Payload::solarxr_protocol_datatypes_StringTable ? static_cast<const solarxr_protocol::datatypes::StringTable *>(payload()) : nullptr;
  }
  const solarxr_protocol::datatypes::Bytes *payload_as_solarxr_protocol_datatypes_Bytes() const {
    return payload_type() == solarxr_protocol::application::pub_sub::Payload::solarxr_protocol_datatypes_Bytes ? static_cast<const solarxr_protocol::datatypes::Bytes *>(payload()) : nullptr;
  }
  const solarxr_protocol::application::pub_sub::KeyValues *payload_as_KeyValues() const {
    return payload_type() == solarxr_protocol::application::pub_sub::Payload::KeyValues ? static_cast<const solarxr_protocol::application::pub_sub::KeyValues *>(payload()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TOPIC_TYPE, 1) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           VerifyTopic(verifier, topic(), topic_type()) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyPayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const solarxr_protocol::application::pub_sub::TopicHandle *Message::topic_as<solarxr_protocol::application::pub_sub::TopicHandle>() const {
  return topic_as_TopicHandle();
}

template<> inline const solarxr_protocol::application::pub_sub::TopicId *Message::topic_as<solarxr_protocol::application::pub_sub::TopicId>() const {
  return topic_as_TopicId();
}

template<> inline const solarxr_protocol::datatypes::StringTable *Message::payload_as<solarxr_protocol::datatypes::StringTable>() const {
  return payload_as_solarxr_protocol_datatypes_StringTable();
}

template<> inline const solarxr_protocol::datatypes::Bytes *Message::payload_as<solarxr_protocol::datatypes::Bytes>() const {
  return payload_as_solarxr_protocol_datatypes_Bytes();
}

template<> inline const solarxr_protocol::application::pub_sub::KeyValues *Message::payload_as<solarxr_protocol::application::pub_sub::KeyValues>() const {
  return payload_as_KeyValues();
}

struct MessageBuilder {
  typedef Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_type(solarxr_protocol::application::pub_sub::Topic topic_type) {
    fbb_.AddElement<uint8_t>(Message::VT_TOPIC_TYPE, static_cast<uint8_t>(topic_type), 0);
  }
  void add_topic(flatbuffers::Offset<void> topic) {
    fbb_.AddOffset(Message::VT_TOPIC, topic);
  }
  void add_payload_type(solarxr_protocol::application::pub_sub::Payload payload_type) {
    fbb_.AddElement<uint8_t>(Message::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(Message::VT_PAYLOAD, payload);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    solarxr_protocol::application::pub_sub::Topic topic_type = solarxr_protocol::application::pub_sub::Topic::NONE,
    flatbuffers::Offset<void> topic = 0,
    solarxr_protocol::application::pub_sub::Payload payload_type = solarxr_protocol::application::pub_sub::Payload::NONE,
    flatbuffers::Offset<void> payload = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_topic(topic);
  builder_.add_payload_type(payload_type);
  builder_.add_topic_type(topic_type);
  return builder_.Finish();
}

struct KeyValues FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KeyValuesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS = 4,
    VT_VALUES = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_KEYS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           verifier.VerifyVectorOfStrings(keys()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfStrings(values()) &&
           verifier.EndTable();
  }
};

struct KeyValuesBuilder {
  typedef KeyValues Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> keys) {
    fbb_.AddOffset(KeyValues::VT_KEYS, keys);
  }
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> values) {
    fbb_.AddOffset(KeyValues::VT_VALUES, values);
  }
  explicit KeyValuesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<KeyValues> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValues>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyValues> CreateKeyValues(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> keys = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> values = 0) {
  KeyValuesBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_keys(keys);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyValues> CreateKeyValuesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *keys = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *values = nullptr) {
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*keys) : 0;
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*values) : 0;
  return solarxr_protocol::application::pub_sub::CreateKeyValues(
      _fbb,
      keys__,
      values__);
}

}  // namespace pub_sub

/// MessageBundle contains all of the messages for the data feed system and the
/// rpc system that will be sent in one buffer.
struct MessageBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_FEED_MSGS = 4,
    VT_RPC_MSGS = 6,
    VT_PUB_SUB_MSGS = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::DataFeedMessageHeader>> *data_feed_msgs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::DataFeedMessageHeader>> *>(VT_DATA_FEED_MSGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::RpcMessageHeader>> *rpc_msgs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::RpcMessageHeader>> *>(VT_RPC_MSGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::pub_sub::PubSubHeader>> *pub_sub_msgs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::pub_sub::PubSubHeader>> *>(VT_PUB_SUB_MSGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA_FEED_MSGS) &&
           verifier.VerifyVector(data_feed_msgs()) &&
           verifier.VerifyVectorOfTables(data_feed_msgs()) &&
           VerifyOffset(verifier, VT_RPC_MSGS) &&
           verifier.VerifyVector(rpc_msgs()) &&
           verifier.VerifyVectorOfTables(rpc_msgs()) &&
           VerifyOffset(verifier, VT_PUB_SUB_MSGS) &&
           verifier.VerifyVector(pub_sub_msgs()) &&
           verifier.VerifyVectorOfTables(pub_sub_msgs()) &&
           verifier.EndTable();
  }
};

struct MessageBundleBuilder {
  typedef MessageBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_feed_msgs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::DataFeedMessageHeader>>> data_feed_msgs) {
    fbb_.AddOffset(MessageBundle::VT_DATA_FEED_MSGS, data_feed_msgs);
  }
  void add_rpc_msgs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::RpcMessageHeader>>> rpc_msgs) {
    fbb_.AddOffset(MessageBundle::VT_RPC_MSGS, rpc_msgs);
  }
  void add_pub_sub_msgs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::pub_sub::PubSubHeader>>> pub_sub_msgs) {
    fbb_.AddOffset(MessageBundle::VT_PUB_SUB_MSGS, pub_sub_msgs);
  }
  explicit MessageBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MessageBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageBundle> CreateMessageBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::DataFeedMessageHeader>>> data_feed_msgs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::rpc::RpcMessageHeader>>> rpc_msgs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<solarxr_protocol::application::pub_sub::PubSubHeader>>> pub_sub_msgs = 0) {
  MessageBundleBuilder builder_(_fbb);
  builder_.add_pub_sub_msgs(pub_sub_msgs);
  builder_.add_rpc_msgs(rpc_msgs);
  builder_.add_data_feed_msgs(data_feed_msgs);
  return builder_.Finish();
}

inline flatbuffers::Offset<MessageBundle> CreateMessageBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<solarxr_protocol::application::data_feed::DataFeedMessageHeader>> *data_feed_msgs = nullptr,
    const std::vector<flatbuffers::Offset<solarxr_protocol::application::rpc::RpcMessageHeader>> *rpc_msgs = nullptr,
    const std::vector<flatbuffers::Offset<solarxr_protocol::application::pub_sub::PubSubHeader>> *pub_sub_msgs = nullptr) {
  auto data_feed_msgs__ = data_feed_msgs ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::application::data_feed::DataFeedMessageHeader>>(*data_feed_msgs) : 0;
  auto rpc_msgs__ = rpc_msgs ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::application::rpc::RpcMessageHeader>>(*rpc_msgs) : 0;
  auto pub_sub_msgs__ = pub_sub_msgs ? _fbb.CreateVector<flatbuffers::Offset<solarxr_protocol::application::pub_sub::PubSubHeader>>(*pub_sub_msgs) : 0;
  return solarxr_protocol::application::CreateMessageBundle(
      _fbb,
      data_feed_msgs__,
      rpc_msgs__,
      pub_sub_msgs__);
}

}  // namespace application

namespace datatypes {

namespace hardware_info {

}  // namespace hardware_info
}  // namespace datatypes

namespace device {
namespace pairing {

}  // namespace pairing

namespace packets {

}  // namespace packets

}  // namespace device

namespace application {
namespace data_feed {
namespace tracker {

}  // namespace tracker

namespace device_data {

}  // namespace device_data

}  // namespace data_feed

namespace rpc {
namespace settings {

}  // namespace settings

}  // namespace rpc

namespace pub_sub {

}  // namespace pub_sub

}  // namespace application

namespace device {

inline bool VerifyServerBoundMessage(flatbuffers::Verifier &verifier, const void *obj, ServerBoundMessage type) {
  switch (type) {
    case ServerBoundMessage::NONE: {
      return true;
    }
    case ServerBoundMessage::solarxr_protocol_device_pairing_PairingInfo: {
      auto ptr = reinterpret_cast<const solarxr_protocol::device::pairing::PairingInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerBoundMessage::solarxr_protocol_device_pairing_PairingResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::device::pairing::PairingResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerBoundMessage::PingResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::device::PingResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerBoundMessage::solarxr_protocol_device_packets_DeviceStatus: {
      auto ptr = reinterpret_cast<const solarxr_protocol::device::packets::DeviceStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerBoundMessage::solarxr_protocol_device_packets_ImuStatus: {
      auto ptr = reinterpret_cast<const solarxr_protocol::device::packets::ImuStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerBoundMessage::solarxr_protocol_device_packets_ImuMovement: {
      auto ptr = reinterpret_cast<const solarxr_protocol::device::packets::ImuMovement *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyServerBoundMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<ServerBoundMessage> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyServerBoundMessage(
        verifier,  values->Get(i), types->GetEnum<ServerBoundMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyDeviceBoundMessage(flatbuffers::Verifier &verifier, const void *obj, DeviceBoundMessage type) {
  switch (type) {
    case DeviceBoundMessage::NONE: {
      return true;
    }
    case DeviceBoundMessage::solarxr_protocol_device_pairing_DiscoverRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::device::pairing::DiscoverRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DeviceBoundMessage::solarxr_protocol_device_pairing_PairingRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::device::pairing::PairingRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DeviceBoundMessage::PingRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::device::PingRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDeviceBoundMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<DeviceBoundMessage> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDeviceBoundMessage(
        verifier,  values->Get(i), types->GetEnum<DeviceBoundMessage>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace device

namespace application {
namespace data_feed {

inline bool VerifyDataFeedMessage(flatbuffers::Verifier &verifier, const void *obj, DataFeedMessage type) {
  switch (type) {
    case DataFeedMessage::NONE: {
      return true;
    }
    case DataFeedMessage::PollDataFeed: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::data_feed::PollDataFeed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataFeedMessage::StartDataFeed: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::data_feed::StartDataFeed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataFeedMessage::DataFeedUpdate: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::data_feed::DataFeedUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataFeedMessage::DataFeedConfig: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::data_feed::DataFeedConfig *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDataFeedMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<DataFeedMessage> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDataFeedMessage(
        verifier,  values->Get(i), types->GetEnum<DataFeedMessage>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace data_feed

namespace rpc {

inline bool VerifyRpcMessage(flatbuffers::Verifier &verifier, const void *obj, RpcMessage type) {
  switch (type) {
    case RpcMessage::NONE: {
      return true;
    }
    case RpcMessage::HeartbeatRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::HeartbeatRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::HeartbeatResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::HeartbeatResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::ResetRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::ResetRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AssignTrackerRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::AssignTrackerRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SettingsRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::SettingsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SettingsResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::SettingsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::ChangeSettingsRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::ChangeSettingsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::RecordBVHRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::RecordBVHRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::RecordBVHStatus: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::RecordBVHStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SkeletonConfigRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::SkeletonConfigRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::ChangeSkeletonConfigRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::ChangeSkeletonConfigRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SkeletonResetAllRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::SkeletonResetAllRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SkeletonConfigResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::SkeletonConfigResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::OpenSerialRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::OpenSerialRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::CloseSerialRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::CloseSerialRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SetWifiRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::SetWifiRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SerialUpdateResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::SerialUpdateResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AutoBoneProcessRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::AutoBoneProcessRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AutoBoneProcessStatusResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::AutoBoneProcessStatusResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::AutoBoneEpochResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::AutoBoneEpochResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::OverlayDisplayModeRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::OverlayDisplayModeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::OverlayDisplayModeChangeRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::OverlayDisplayModeChangeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::OverlayDisplayModeResponse: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::OverlayDisplayModeResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SerialTrackerRebootRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::SerialTrackerRebootRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SerialTrackerGetInfoRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::SerialTrackerGetInfoRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::SerialTrackerFactoryResetRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::SerialTrackerFactoryResetRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::DetectedDevicesRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::DetectedDevicesRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RpcMessage::PairDeviceRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::rpc::PairDeviceRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRpcMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<RpcMessage> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRpcMessage(
        verifier,  values->Get(i), types->GetEnum<RpcMessage>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace rpc

namespace pub_sub {

inline bool VerifyTopic(flatbuffers::Verifier &verifier, const void *obj, Topic type) {
  switch (type) {
    case Topic::NONE: {
      return true;
    }
    case Topic::TopicHandle: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::pub_sub::TopicHandle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Topic::TopicId: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::pub_sub::TopicId *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTopicVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Topic> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTopic(
        verifier,  values->Get(i), types->GetEnum<Topic>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyPubSubUnion(flatbuffers::Verifier &verifier, const void *obj, PubSubUnion type) {
  switch (type) {
    case PubSubUnion::NONE: {
      return true;
    }
    case PubSubUnion::Message: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::pub_sub::Message *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PubSubUnion::SubscriptionRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::pub_sub::SubscriptionRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PubSubUnion::TopicHandleRequest: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::pub_sub::TopicHandleRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PubSubUnion::TopicMapping: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::pub_sub::TopicMapping *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPubSubUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<PubSubUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPubSubUnion(
        verifier,  values->Get(i), types->GetEnum<PubSubUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyPayload(flatbuffers::Verifier &verifier, const void *obj, Payload type) {
  switch (type) {
    case Payload::NONE: {
      return true;
    }
    case Payload::solarxr_protocol_datatypes_StringTable: {
      auto ptr = reinterpret_cast<const solarxr_protocol::datatypes::StringTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::solarxr_protocol_datatypes_Bytes: {
      auto ptr = reinterpret_cast<const solarxr_protocol::datatypes::Bytes *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::KeyValues: {
      auto ptr = reinterpret_cast<const solarxr_protocol::application::pub_sub::KeyValues *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Payload> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPayload(
        verifier,  values->Get(i), types->GetEnum<Payload>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace pub_sub
}  // namespace application
}  // namespace solarxr_protocol

#endif  // FLATBUFFERS_GENERATED_ALL_SOLARXR_PROTOCOL_H_
