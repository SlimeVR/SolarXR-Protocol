/// This file contains all messages related to the RPC system. Unlike the data feed
/// system, the RPC system is focused on providing a reliable RPC communication pattern.
///
/// It can be used either for sending commands to mutate state, or reliably sending
/// evented updates of data that should be guaranteed to be observed, such as a user
/// initiated button push.

include "datatypes/datatypes.fbs";
include "settings/model.fbs";

namespace solarxr_protocol.rpc;


union RpcMessage {
    HeartbeatRequest,
    HeartbeatResponse,
    ResetRequest,
    AssignTrackerRequest,
    SettingsRequest,
    SettingsResponse,
    ChangeSettingsRequest,
    RecordBVHRequest,
    RecordBVHStatus,
    SkeletonConfigRequest,
    ChangeSkeletonConfigRequest,
    SkeletonResetAllRequest,
    SkeletonConfigResponse,
    OpenSerialRequest,
    CloseSerialRequest,
    SetWifiRequest,
    SerialUpdateResponse,
    AutoBoneProcessRequest,
    AutoBoneProcessStatusResponse,
    AutoBoneEpochResponse,
    OverlayDisplayModeRequest,
    OverlayDisplayModeChangeRequest,
    OverlayDisplayModeResponse,
    SerialTrackerRebootRequest,
    SerialTrackerGetInfoRequest,
    SerialTrackerFactoryResetRequest,
    SerialDevicesRequest,
    SerialDevicesResponse
}

table RpcMessageHeader {
    /// For a request, this identifies the request. For a response, this corresponds
    /// to the request that it is responding to.
    tx_id: solarxr_protocol.datatypes.TransactionId;
    message: RpcMessage;
}


table HeartbeatRequest {}

table HeartbeatResponse {}


enum ResetType: uint8 {
    Quick,
    Full,
    Recalibrate,
    /// Second pose for calibrating mounting rotation
    Mounting,
}


table ResetRequest {
    reset_type: ResetType;
}
table ResetResponse {}


table AssignTrackerRequest {
    tracker_id: solarxr_protocol.datatypes.TrackerId;
    body_position: solarxr_protocol.datatypes.BodyPart;
    mounting_orientation: solarxr_protocol.datatypes.math.Quat;
    display_name: string;
    allow_drift_compensation: bool;
}

// ---- Settings ----

table SettingsRequest {}

table SettingsResponse {
    steam_vr_trackers: SteamVRTrackersSetting;
    filtering: FilteringSettings;
    drift_compensation: DriftCompensationSettings;
    osc_router: OSCRouterSettings;
    vrc_osc: VRCOSCSettings;
    model_settings: solarxr_protocol.rpc.settings.ModelSettings;
    tap_detection_settings: TapDetectionSettings;
}

table ChangeSettingsRequest {
    steam_vr_trackers: SteamVRTrackersSetting;
    filtering: FilteringSettings;
    drift_compensation: DriftCompensationSettings;
    osc_router: OSCRouterSettings;
    vrc_osc: VRCOSCSettings;
    model_settings: solarxr_protocol.rpc.settings.ModelSettings;
    tap_detection_settings: TapDetectionSettings;
}

table SteamVRTrackersSetting {
    waist: bool;
    chest: bool;
    feet: bool;
    knees: bool;
    elbows: bool;
    hands: bool;
}

table FilteringSettings {
    type: solarxr_protocol.datatypes.FilteringType;
    /// 0 to 1. A higher value results in more smoothing or prediction
    amount: float32;
}

/// Settings related to IMU yaw drift compensation
table DriftCompensationSettings {
    enabled: bool;
    /// 0 to 1. A higher value results in more yaw drift compensation
    amount: float32;
    /// Number of previous resets to take into account when calculating yaw drift
    max_resets: uint16;
}

/// OSC router forwards messages it receives, to allow the usage of multiple OSC programs for the same app.
table OSCRouterSettings {
    osc_settings: OSCSettings;
}

/// OSC Settings specific to VRChat
table VRCOSCSettings {
    osc_settings: OSCSettings;
    trackers: OSCTrackersSetting;
}

/// OSC Settings that are used in *any* osc application.
table OSCSettings {
    enabled: bool;
    portIn: uint16;
    portOut: uint16;
    address: string;
}

table OSCTrackersSetting {
    head: bool;
    chest: bool;
    waist: bool;
    knees: bool;
    feet: bool;
    elbows: bool;
    hands: bool;
}

table TapDetectionSettings {
    tap_reset_delay: float = null;
    tap_reset_enabled: bool = null;
    tap_reset_taps: uint8 = null;
    tap_quick_reset_delay: float = null;
    tap_quick_reset_enabled: bool = null;
    tap_quick_reset_taps: uint8 = null;
    tap_mounting_reset_delay: float = null;
    tap_mounting_reset_enabled: bool = null;
    tap_mounting_reset_taps: uint8 = null;
}

table RecordBVHRequest {
    stop: bool;
}

table RecordBVHStatus {
    recording: bool;
}


enum SkeletonBone: uint8 {
    NONE = 0,
    HEAD = 1,
    NECK = 2,
    TORSO = 3,
    CHEST = 4,
    WAIST = 5,
    HIP_OFFSET = 6,
    HIPS_WIDTH = 7,
    LEGS_LENGTH = 8,
    KNEE_HEIGHT = 9,
    FOOT_LENGTH = 10,
    FOOT_SHIFT = 11,
    SKELETON_OFFSET = 12,
    CONTROLLER_DISTANCE_Z = 13,
    CONTROLLER_DISTANCE_Y = 14,
    FOREARM_LENGTH = 15,
    SHOULDERS_DISTANCE = 16,
    SHOULDERS_WIDTH = 17,
    UPPER_ARM_LENGTH = 18,
    ELBOW_OFFSET = 19
}

table SkeletonPart {
    bone: SkeletonBone;
    value: float;
}

table SkeletonConfigRequest {}
table SkeletonConfigResponse {
    skeleton_parts: [SkeletonPart];
}

table SkeletonResetAllRequest {}

table ChangeSkeletonConfigRequest {
    bone: SkeletonBone;
    value: float;
}

table SerialDevice {
    port: string;
    name: string;
}
table OpenSerialRequest {
    /// Automaticaly pick the first serial device available
    auto: bool;
    port: string;
}
table CloseSerialRequest {}
table SetWifiRequest {
    ssid: string;
    password: string;
}
table SerialUpdateResponse {
    log: string;
    closed: bool;
}

/// Reboots the tracker connected to the serial monitor
table SerialTrackerRebootRequest {}

/// Sends the GET INFO cmd to the current tracker on the serial monitor
table SerialTrackerGetInfoRequest {}

/// Sends the FRST cmd to the currently over the Serial Montior connected Tracker
table SerialTrackerFactoryResetRequest {}

table SerialDevicesRequest {}

table SerialDevicesResponse {
    devices: [SerialDevice];
}

enum AutoBoneProcessType: uint8 {
    NONE = 0,
    RECORD = 1,
    SAVE = 2,
    PROCESS = 3,
    APPLY = 4
}

table AutoBoneProcessRequest {
    process_type: AutoBoneProcessType;
}

table AutoBoneProcessStatusResponse {
    process_type: AutoBoneProcessType;
    message: string;
    current: uint32;
    total: uint32;
    completed: bool;
    success: bool;
}

table AutoBoneEpochResponse {
    current_epoch: uint32;
    total_epochs: uint32;
    epoch_error: float32;
    adjusted_skeleton_parts: [SkeletonPart];
}

// ---- Overlay ----

/// Requests the current state of `OverlayDisplayModeResponse`.
table OverlayDisplayModeRequest {}

/// Changes the state of the overlay's display mode.
table OverlayDisplayModeChangeRequest {
    is_visible: bool = null;
    is_mirrored: bool = null;
}

/// The current state of the overlay's display mode.
table OverlayDisplayModeResponse {
    is_visible: bool;
    is_mirrored: bool;
}
